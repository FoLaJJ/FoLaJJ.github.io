[TOC]



# 一.工具向

## 1.Git

Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。

**安装（ubuntu环境下）**

```shell
sudo apt-get install git
```

**查看版本号**

```shell
git --version
```

**初始化仓库操作（init）**

```shell
git init
```

可以看到生成了一个`.git`的隐藏子目录，可以查看。

**添加文件到暂存区（add）**

添加一个或多个文件到暂存区：

```shell
git add	[file1]	[file2]
```

添加指定目录到暂存区，包括子目录：

```shell
git add [dir]
```

添加当前目录下的所有文件到暂存区：

```shell
git add .
```

**将暂存区的内容添加到本地仓库中（commit）**

提交暂存区到本地仓库中：

```shell
git commit -m [message]
```

message是一些备注信息；

提交指定文件：

```shell
git commit [file1] [file2] ... -m [message]
```

**-a** 参数设置修改文件后不需要执行 git add 命令，直接来提交

```shell
$ git commit -a
```

**查看文件是否被再次更改（status）**

```shell
git status <-s>
-s 获得简短的输出结果
```

**比较文件的不同（diff）**

显示暂存区和工作区的差异:

```shell
$ git diff [file]
```

显示暂存区和上一次提交(commit)的差异:

```shell
$ git diff --cached [file]
或
$ git diff --staged [file]
```

显示两次提交之间的差异:

```shell
$ git diff [first-branch]...[second-branch]
```

**回退版本（reset）**

git reset 命令用于回退版本，可以指定退回某一次提交的版本。

git reset 命令语法格式如下：

```shell
git reset [--soft | --mixed | --hard] [HEAD]
```

**--mixed** 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。

```shell
git reset  [HEAD] 
```

回退一百个版本：

```c
git reset --hard HEAD~100
```

**拷贝操作（clone）**

```shell
git clone <repo> <directory>
```

- repo：Git仓库
- directory：本地目录

如：

```shell
git clone git://github.com/schacon/grit.git mygrit
```

后面一个参数可填可不填，不填就默认存到当前目录；

**查看提交历史（log）**

```shell
git log <--oneline> <--graph> <--reverse> <--author==xxx>
```

- --oneline看最简版本；
-  --graph ，查看历史中什么时候出现了分支、合并；
- **--reverse** 参数来逆向显示所有日志。
- --author 查看某作者的提交记录

下面是查看Linus的提交记录；

```shell
$ git log --author=Linus --oneline -5
81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory
3bb7256 make "index-pack" a built-in
377d027 make "git pack-redundant" a built-in
b532581 make "git unpack-file" a built-in
112dd51 make "mktag" a built-in
```



**git blame**

用于查看某文件的修改记录：

```shell
git blame <file>
```

**上传本地版本与远程合并（push）**

**git push** 命令用于从将本地的分支版本上传到远程并合并。

命令格式如下：

```shell
git push <远程主机名> <本地分支名>:<远程分支名>
```

如果本地分支名与远程分支名相同，则可以省略冒号：

```shell
git push <远程主机名> <本地分支名>
```

**下载远程代码然后与本地合并（pull）**

**git pull** 命令用于从远程获取代码并合并本地的版本。

**git pull** 其实就是 **git fetch** 和 **git merge FETCH_HEAD** 的简写。

命令格式如下：

```shell
git pull <远程主机名> <远程分支名>:<本地分支名>
```



`git fetch` 命令用于从远程仓库下载最新的代码，但是不会自动将代码合并到本地分支中。它只是将最新的代码下载到本地，然后将其存储在远程跟踪分支中。通过使用 `git fetch`，您可以在本地查看远程仓库中的最新代码，然后可以手动将其合并到本地分支中。

`git pull` 命令可以让您从远程仓库下载最新的代码，并自动将其合并到本地分支中。它实际上是一个包含两个步骤的命令，首先它运行 `git fetch` 命令来下载代码，然后运行 `git merge` 命令来合并代码到本地分支中。



## 2.Source Insight使用

安装破解版，正常使用，跳转定义方便；

## 3.Linux命令

**ls（查看文件或目录）**

```
ls [属性] [文件或目录]
-a 查看全部文件（隐藏的文件也查看）
-l 查看文件的详细情况
-lh 查看文件的详细情况，并转换文件大小格式
-r 查看文件时，位置反转
```

**pwd（查看当前目录的绝对路径）**

```
pwd
```

**du（查看目录、文件所占用磁盘空间的大小）**



```
du [属性]du [属性] [文件名]#查看指定文件大小
-h                ：以人类可读的方式显示
-a                ：显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小
-s                ：显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小
-c                ：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和
--apparent-size   ：显示目录或文件自身的大小
-l                ：统计硬链接占用磁盘空间的大小
-L                ：统计符号链接所指向的文件占用的磁盘空间大小　　
```

**cd指令（切换目录）**

这个也是重点，十分之重。

```shell
cd
cd ~ 
#返回家目录
cd [目录]
#进入下级目录
cd ..
#返回上级目录
cd ../../xxx.xx
#相对路径跳转
cd /home/ubuntu/api
#绝对路径跳
```

**mkdir指令（创建目录）**

主要用来创建目录（文件夹）

```
mkdir [文件夹名]
-p #创建多级目录
```

**rmdir指令（删除文件或目录）**

这个指令相信大家都不陌生，删库跑路的事也常有发生，所以用这个指令一定要小心再小心，删了就很难找回了。

```shell
rmdir [目录]
#有内容时无法删除

rm -rf [目录或文件名]
#递归强制删除所有文件

rm -r [目录或文件名]
#递归删除整个文件夹，有提示

rm -f [目录或文件名]
#强制删除不提示
```

**touch指令（创建文件不编辑）**

简单的创造一个空文件但不编辑。

```shell
touch [文件名字]
```

**cp指令（复制指令）**

顾名思义就是copy的简写，就是复制并粘贴。

```shell
cp -r [需要复制的文件名或目录名] [复制到终点目录]
```

**mv指令（移动指令还可以重命名）**

mv指令就是move，但还有重命名的作用。

```shell
mv [给它爱.txt] [吃鸡.txt]
#两个文件在同一目录下就是重命名

mv [文件目录1] [文件目录2]
#如果两个不同目录就剪切
```

**ln软链接**

link软链接，类似于Windows系统里面的创建快捷方式一样，可以比较方便的实现文件应用的共享。

```shell
ln -s [需要软链接的目录文件] [放置位置]
```

**history指令（查看历史命令）**

这个指令的作用是用来查看历史命令，可以在你忘记命令或是找出原因的情况下给你帮助。

```shell
history 
#查看全部历史命令
history 10
#查看最近10条命令
history | more
#在more上查看
！4执行第四条指令
history | grep "ls"
#查找历史命令中ls命令
```

**man（查看命令手册）**

```shell
man [命令]
[命令] --help
```

**1.用户及用户组：**

首先我们得知道从哪里看到我们的用户以及用户组。（一般一个用户组可以拥有很多用户）

```shell
cat /etc/passwd
#查看用户
cat /etc/group
#查看用户组
cat /etc/shadow
#查看用户的密码（需要root权限）
#里面是加密的密码，需要根据加密方式进行解密
```

知道怎样查询该Linux系统的用户及密码之后，我们发现这样查询要接上grep指令才可能快速一点，所以我们可以偷偷懒：

```shell
id  [用户名]
#查询是否有这个用户名并且显示所在组
w
#查看当前活跃的用户列表
```

**文件权限**

<img src="https://mmbiz.qpic.cn/mmbiz_png/pp2wicyibt7JoDok8GybNRVuh0sWs3nibicuvcrOzcpmEFeylkr3dqNrdZZs1cp9nYNrzKqEV4vexXgs0fJWUTwbbA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" />

简单来说：

- 第0位显示文件类型（d，-，l，c，b）
- l是连接，相当于快捷方式
- d是目录，相当于文件夹
- c是字符设备文件，鼠标，键盘等
- b是设备，如块设备、硬盘
- -是普通文件
- 1-3位确定所有者拥有的权限
- 4-6位确定所属用户组拥有的权限
- 7-9位确定其他用户拥有的文件权限

其中r代表可读（read），w代表可写（write），x代表可执行（execute）。

并且rwx的数字表示都不一样，所以开发者就将r=4，w=2.x=1作为更便携的表示方法，并且由他们排列组合，能够完整将权限组合表示出来，所以我们一般用数字来表示文件权限！

7种情况如下：

- 1x
- 2w
- 3wx
- 4r
- 5rx
- 6rw
- 7rwx

**ifconfig**

**手动启动、查看与修改网络接口的相关参数，包括IP参数以及MTU等；**

```bash
ifconfig {interface} {options}
//通常都是eth0以及你的网卡wlan0，
//可以通过这个启动和关闭
//可以看到指定网络接口的参数
```

**重置网络**

```bash
/etc/init.d/network restart
//没事多试试这个，有大用！
//修改配置后
```

**ufw英文全称：uncomplicated firewall**

看名字就很好理解，不复杂的防火墙，那就是简单的防火墙。

第一步：检查是否安装，并且后续都是默认在root用户下，如不是，请使用root用户或是sudo；

```shell
sudo ufw version
```

第二步：如果没有安装的话，请安装：

```bash
sudo apt-get install ufw
```

第三步：打开防火墙，请注意！如果在云服务器上设置防火墙时，请第一时间打开22端口，否则后续你会被迫用非ssh连接来进入你的Linux系统；

```bash
sudo ufw enable
//关闭是disable
sudo ufw disable
```

第四步：开启或禁用端口：

```bash
sudo ufw allow 端口号
sudo ufw deny 端口号
//开启22端口
sudo ufw allow 22
```

第五步：查看防火墙的状态或是防火墙规则：你配置的规则都会在这里显示：

```bash
sudo ufw status
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/pp2wicyibt7Jrts7bjPAFXTcmNEd4cCtzS6vynfy5BaD4zU2hibic3mKEYyCSicSKp0e2WuCPXENJTcjEPXq3kZw9Bw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

第六步：删除自己不再需要的规则：

```bash
 sudo ufw delete allow 22 
 sudo ufw delete +规则
```

第七步：允许或是禁止某个ip访问本机所有端口：

```bash
sudo ufw allow from 192.168.222.1
sudo ufw deny from 192.168.222.1
```

还要注意的是它的相关文件放置的地点，你也可以通过更改它的文件配置再重启ufw以达到命令设置一样的结果。

- /etc/ufw 是ufw的环境配置文件，一般不做改动。感兴趣可以去看一下，主要是：

![图片](https://mmbiz.qpic.cn/mmbiz_png/pp2wicyibt7Jrts7bjPAFXTcmNEd4cCtzSA60LuWGBGaI9POPKxiachjmRFCzKFnsuaicEDMtNgFvTmsD8B2nq8f7w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 具体系统装载文件的位置是不一样的，想具体了解可以使用whereis来快速查询文件位置：然后再一个个找：

![图片](https://mmbiz.qpic.cn/mmbiz_png/pp2wicyibt7Jrts7bjPAFXTcmNEd4cCtzSiaZDwd2fMwuvy85aGlFK8TEMvwyhNMBgDKNaQkSSMIaibxtNhZ4AOnvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

查看网络：

ss查看socket连接

```c
ss
 -h, –help 帮助
 -V, –version 显示版本号
 -t, –tcp 显示 TCP 协议的 sockets
 -u, –udp 显示 UDP 协议的 sockets
 -x, –unix 显示 unix domain sockets，与 -f 选项相同
 -n, –numeric 不解析服务的名称，如 “22” 端口不会显示成 “ssh”
 -l, –listening 只显示处于监听状态的端口
 -p, –processes 显示监听端口的进程(Ubuntu 上需要 sudo)
 -a, –all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接
 -r, –resolve 把 IP 解释为域名，把端口号解释为协议名称
```

## 4.makefile

本系列复习只要求浅浅浏览即可。

不需要过多的深入了解！

makefile文件

```makefile
gcc -c -o a.o a.c
gcc -c -o b.o b.c
gcc -o test a.o b.o
```



makefile隐藏着时间的规则

```makefile
test:a.o b.o
	gcc -o test a.o b.o
a.o:a.c
	gcc -c -o a.o a.c
b.o:b.c
	gcc -c -o b.o b.c
```



```makefile
test:a.o b.o
	gcc -o test $^
%.o:%.c
	gcc -c -o $@ $<
```



```makefile
test:a.o b.o
	gcc -o test $^
%.o:%.c
	gcc -c -o $@ $<
clean:
	rm *.o test
.PHONY:clean
```





```makefile
.PHONY:clean
```

防止有clean同名文件影响



两种变量赋值方法

```makefile
A:=xxx	#实时赋值，xxx为变量还没初始化的话就为空
B=xxx	#延时赋值，B使用时才去确定
:= #即时
=	#延时
?=	#延时，如果前面已经定义了，则忽略这句话
+=	#附加，延时和即时取决于前面定义
```



```makefile
A = a b c
B = $(foreach f,$(A),$(f).o)
#变量循环赋值
all:
	echo B=$(B)
```



```makefile
A = a b c
B = $(foreach f,$(A),$(f).o)
#变量循环赋值

C = a b c d/
D = $(filter %/,$(C))
#找出符合格式的变量

E = $(filter-out %/,$(C))
#不符合格式

files = $(wildcard *.c)
#找出目录下符合格式的文件

dep_files = $(patsubst %.c,%.d,$(files))
#将变量下所有.c替换为.d

all:
	echo B=$(B)
	echo D=$(D)
	echo E=$(E)
	echo files=$(files)
	echo dep_files=$(dep_files)
	
```





```makefile
test:a.o b.o
	gcc -o test $^
c.o:c.c c.h
%.o:%.c
	gcc -c -o $@ $<
clean:
	rm *.o test
.PHONY:clean
```



```bash
gcc -M c.c
```

获取c.c所用的头文件依赖



```bash
gcc  -M -MF c.c c.d
```

生成c.c所用的头文件依赖到c.d



所以直接

```bash
gcc -c -o c.o c.c -MD -MF c.d
```



```makefile
objs = a.o b.o c.o

dep_files:= $(patsubst %, .%.d, $(objs))
dep_files:=$(wildcard $(dep_files))

CFLAGS = -Werror
#把所有警告当成错误

test : $(objs)
	gcc -o test $^
	
ifneq ($(dep_files),)
include $(dep_files)
endif

%.o:%.c
	gcc $(CFLAGS) -c -o $@ $< -MD -MF .$@.d
	
clean:
	rm *.o test
	
distclean:
	rm $(dep_files)
	
.PHONY:clean
```



## 5.Shell Scripts

后缀为.sh

记得chmod 更改权限



定义变量及使用变量

```bash
your_name="qinjx"
echo $your_name
echo ${your_name}
#一般使用下面这一种，便于看，赋值没有$，使用才有$
```



删除变量，使用unset删除该变量后，后续输出将为空

```bash
unset your_name
```



双引号字符串和单引号字符串

```bash
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1

# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
```



输出：

```bash
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !
```



输出字符串长度：

```bash
string="abcd"
echo ${#string}   # 输出 4
```



提取字符串；

```bash
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```





## 6.FFmpeg



官方参考文档：[ffmpeg Documentation](https://www.ffmpeg.org/ffmpeg.html)

FFmpeg是一个强大的开源多媒体框架，提供了多个命令行工具和库函数，可以用于处理视频、音频、字幕等多媒体数据。下面是一些常见的FFmpeg参数的说明：

- -i：指定输入文件名
- -f：指定输入/输出格式
- -vcodec：指定视频编解码器
- -acodec：指定音频编解码器
- -s：指定视频分辨率
- -b：指定视频码率
- -ar：指定音频采样率
- -ab：指定音频码率
- -t：指定输出时长
- -ss：指定开始时间
- -r：指定帧率
- -filter_complex：指定复杂的过滤器图形
- -map：指定输入流映射到输出流
- -y：覆盖输出文件
- -v：设置日志级别

以上只是FFmpeg的一些常见参数，具体使用还需要根据实际需要进行选择。



-v4l2是ffmpeg中用于捕获视频设备的一个输入设备，常用于摄像头的视频采集。

以下是常用的-v4l2参数说明：

- -video_size：设置视频分辨率，如640x480；
- -framerate：设置视频帧率，如30fps；
- -input_format：设置输入格式，如yuyv422；
- -i：指定输入设备，如/dev/video0；
- -t：设置录制时长，如60秒；
- -f：设置输出格式，如mp4；
- -vcodec：设置视频编码格式，如h264；
- -b:v：设置视频比特率，如2M；
- -acodec：设置音频编码格式，如aac；
- -b:a：设置音频比特率，如128k；
- -ar：设置音频采样率，如44100；
- -ac：设置音频通道数，如2。

更详细的参数说明可以参考ffmpeg官方文档。



在FFmpeg中使用alsa进行音频采集，需要使用以下参数：

```c
-alsa [input_options] -i <input_file> [output_options] <output_file>
```



alsa参考链接：[FFmpeg Devices Documentation](https://ffmpeg.org/ffmpeg-devices.html#alsa)



其中 input_options 和 output_options 都是可选的，可以用来设置采集和输出的相关参数，例如采集的声卡设备号、采样率、通道数等等。一些常用的参数包括：

- -f alsa：强制使用alsa作为输入格式。
- -i <input_file>：指定输入文件，可以是声卡设备号或者音频文件路径。
- -ac \<channels>：设置音频的通道数。
- -ar <sample_rate>：设置音频的采样率。
- -t \<duration>：设置采集的时长。
- -ab <audio_bitrate>：设置音频的比特率。
- -acodec \<codec>：设置音频编码器。

例如，以下命令可以用于采集alsa设备号为hw:0,0的音频数据，并将其编码为AAC格式保存到文件中：

```c
ffmpeg -f alsa -ac 2 -i hw:0,0 -t 10 -acodec aac output.aac
```





```c
 snprintf(command, 1024,"ffmpeg -f v4l2 -input_format mjpeg -video_size %s -framerate %s -i %s -f alsa -ac %s -i %s -c:v %s -preset %s -c:a %s -strict %s %s",VIDEO_SIZE, FRAMERATE, VIDEO_DEVICE, AUDIO_CHANNELS, AUDIO_DEVICE, VIDEO_CODEC, PRESET, AUDIO_CODEC, STRICT, output_file);
```

由左到右分别是：

-f v4l2强制使用v4l2的格式，

-input_format

-video_size：设置分辨率，如640x480

-framerate：设置帧率，30fps

-i：指定输入设备，如/dev/video0；



-f alsa强制使用alsa的框架

-ac 设置音频通道数

-i 指定输入文件

-c:v 设置视频编码器，如libx264，好64_omx

-preset 控制编码速度和质量的权衡

-c:a 设置音频编码器，aac，mp3，pcm_s16le

-strict 旧版本才有，用于指定编解码器的严格级别，现已整合到其他参数中，不需要额外指定了。









# 二.八股文向

## 1.计算机网络：

### OSI的7层网络模型？

分为应用层、表示层、会话层、运输层、网络层、链路层、物理层。

- 应用层(数据)：确定进程之间**通信的性质**以及满足用户需要以及提供网络和用户应用，为应用程序提供服务，DNS，HTTP，HTTPS，DHCP，FTP，POP3(Post Office Protocol)、SMTP(Simple Mail Transfer Protocol)都是这层的协议。
- 表示层(数据)：主要解决用户信息的**语法表示**问题，表示层提供各种**用于应用层数据的编码和转换功能**,确保一个系统的应用层发送的数据能被另一个系统的应用层识别，**如数据转换，压缩和加密，解密**。
- 会话层(数据)：会话层就是负责**建立、管理和终止表示层实体之间的通信会话**。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 比如服务器验证用户登录就是在会话层。
- 传输层(段)：实现网络不同主机上的用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制，拥塞控制。TCP UDP就这层。
- 网络层(包)：本层通过**IP寻址**来建立两个节点之间的连接，为源端的运输层送来的分组，**选择合适的路由和交换节点**，正确无误地按照地址传送给目的端的运输层。IP就是这层。
- 数据链路层(帧)：将上层数据封装成帧，用**MAC**地址访问媒介，并由错误检测和修正
- 物理层(比特流)：设备之间比特流的传输，物理接口，电气特性(常用设备有(各种物理设备)集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。)



**OSI（物联网淑惠试用）**

其中表示层和会话层用途如下：

- 表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不用的问题；
- 会话层：建立及管理会话；

五层协议没有表示层和会话层，而是将这些功能留给应用程序的开发者进行处理；





### TCP/IP四层协议

TCP四层模型是我们实践过程中发现比较合理的分层，虽然我们实际过程中都没有按OSI分为七层，但是OSI对我们实践过程分层有着指导性的意义。

![img](https://pic.imgdb.cn/item/63ef20b3f144a01007340007.jpg)



**计算机网络体系结构**

![image.png](https://pic.leetcode-cn.com/1646808843-xTHZBZ-image.png)

**简短的概述：**

- 应用层：负责给应用程序提供统一的接口；
- 表示层：负责把数据转换成兼容另一个系统能识别的格式；
- 会话层：负责建立、管理和终止表示层实体之间的通信会话；
- 传输层：负责端到端的数据传输；
- 网络层：负责数据的路由、转发、分片；
- 数据链路层：负责数据的封帧和差错检测，以及MAC寻址；
- 物理层，负责在物理网络中传输数据帧；





**五层协议：**

- 应用层：为特定应用程序提供数据传输服务，例如HTTP、DNS等/协议。数据单位为报文；
- 传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据段。TCP主要提供完整性服务，UDP主要提供及时性服务；
- 网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或用户数据报封装成分组；
- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧；
- 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异；（集线器、中继器、调制解调器、网线、双绞线、同轴电缆等）







**TCP/IP协议**

只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

应用在各层传输时，向下过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。



**TCP/IP四层模型代表协议：**

应用层

传输层

网络层

网络接口层





**1.TCP、UDP的区别？**

- TCP是面向连接的，UDP是面向无连接的。

- TCP是面向字节流的，UDP是基于数据报的。

- TCP提供可靠服务（正确性、顺序性），UDP提供不可靠服务。

- TCP程序结构复杂，占用资源多；UDP程序结构简单，占用资源少。

- TCP有拥塞控制；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，适合于实时应用，如IP电话、实时视频会议。

- TCP只支持一对一；UDP支持一对一、一对多、多对一、多对多。

  

**2. TCP如何保证可靠传输？**

- **校验和：**发送数据报的二进制相加然后取反，检测数据在传输过程中的变化，有差错则丢弃。

- **确认应答：**接收方收到正确的报文就会确认。

- **超时重传**：发送方等待一定时间后没有收到确认报文则重传。

- **序列号：**发送方对每一个数据包编号，接收方对数据包排序，保证不乱序、不重复。

- **窗口机制（流量控制）**：双方会协调发送的数据包大小，保证接收方能及时接收。

- **拥塞控制机制：**如果网络拥塞，发送方会降低发送速率，降低整个网络的拥塞程度。

**3.应用程序ping发出的是什么报文？**

应用程序ping发出的是**ICMP请求报文。**

ping的原理是利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，通过对方回复的数据包来确定两台网络机器是否连接相通，时延是多少。

**4.路由器、交换机、集线器的区别？**

（1）路由器工作在网络层，根据网络层提供的信息（IP地址）来选择路由。

（2）交换机工作在数据链路层，通过数据链路层提供的信息（MAC地址）来选择端口。

（3）集线器工作在物理层，只对信号进行整形、放大后再重发（广播给其他所有端口）。

（4）调制解调器是模拟信号和数字信号的“翻译员”；

（5）双绞线可以减少电磁辐射和外部电磁干扰的影响；

**5.TCP三次握手，四次挥手？**

| 标记    | 含义                                                 |
| ------- | ---------------------------------------------------- |
| URG     | Urgent：紧急位，URG=1，表示紧急数据                  |
| **ACK** | **Acknowledgement：确认位，ACK=1，确认号才生效**     |
| PSH     | Push：推送位，PSH=1，尽快地把数据交付给应用层        |
| PST     | Reset：重置位，RST=1，重新建立连接                   |
| **SYN** | **Synchronization：同步位，SYN=1，表示连接请求报文** |
| **FIN** | **Finish：终止位，FIN=1表示释放连接**                |

**1.三次握手的流程？**

[![v7Z7DK.png](https://s1.ax1x.com/2022/09/05/v7Z7DK.png)](https://imgse.com/i/v7Z7DK)



第一次握手：客户端告诉服务端，我可以发；

第二次握手：服务端收到客户端发来的信息，再发送确认信息回去，告诉客户端，我可以收也可以发；

第三次握手：客户端收到服务端发来的信息，再发送确认信息回去，告诉服务端，我可以收。



**五句话拓展：**

服务端新建套接字，绑定地址信息后开始监听，进入LISTEN状态。

客户端新建套接字绑定地址信息后调用connect，发送连接请求SYN，并进入SYN_SENT状态，等待服务器的确认。

服务端一旦监听到连接请求，就会将连接放入内核等待队列中，并向客户端发送SYN和确认报文段ACK，进入SYN_RECD状态。

客户端收到SYN+ACK报文后向服务端发送确认报文段ACK，并进入ESTABLISHED状态，开始读写数据。

服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，就可以进行读写数据了


**具体流程：**

- `第一次`：客户向服务器发送连接请求段，建立连接请求控制段（SYN=1），表示传输的报文段的第一个数据字节的序列号是x，此序列号代表整个报文段的序号（seq=x）；客户端进入 SYN_SEND （同步发送状态）；

- `第二次`：服务器发回确认报文段，同意建立新连接的确认段（SYN=1），确认序号字段有效（ACK=1），服务器告诉客户端报文段序号是y（seq=y），表示服务器已经收到客户端序号为x的报文段，准备接受客户端序列号为x+1的报文段（ack_seq=x+1）；服务器由LISTEN进入SYN_RCVD （同步收到状态）;

- `第三次`:客户对服务器的同一连接进行确认.确认序号字段有效(ACK=1),客户此次的报文段的序列号是x+1(seq=x+1),客户期望接受服务器序列号为y+1的报文段(ack_seq=y+1);当客户发送ack时，客户端进入ESTABLISHED 状态;当服务收到客户发送的ack后，也进入ESTABLISHED状态;第三次握手可携带数据;



**1.为什么是三次？而不是两次或者是四次？**

先总结：两次不安全，四次太多了。tcp通信需要确保双方都具有数据收发的能力，得到ACK响应则认为对方具有数据收发的能力，因此双方都要发送SYN确保对方具有通信的能力。第一次握手是客户端发送SYN，服务端接收，服务端得出客户端的发送能力和服务端的接收能力都正常；第二次握手是服务端发送SYN+ACK，客户端接收，客户端得出客户端发送接收能力正常，服务端发送接收能力也都正常，但是此时服务器并不能确认客户端的接收能力是否正常；第三次握手客户端发送ACK，服务器接收，服务端才能得出客户端发送接收能力正常，服务端自己发送接收能力也都正常。

**2.三次握手可以携带数据吗？**

第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。假设第一次可以携带数据，如果有人恶意攻击服务器，每次都在第一次握手中的SYN报文放入大量数据，重复发送大量SYN报文，此时服务器会花费大量内存空间来缓冲这些报文，服务器就更容易被攻击了。

**3.握手失败，服务端会怎样处理？**

握手失败的原因有两种（按照发生在哪一步骤来进行区分），第一种是服务端没有收到SYN，则什么都不做；

第二种是服务端回复了SYN+ACK后，长时间没有收到ACK响应，则超时后就会发送RST重置连接报文，释放资源。

**4.ISN代表什么？意义何在？ISN是固定不变的吗？ISN为何要动态随机**

ISN全称是`Initial Sequence Number`，是TCP发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号。

ISN如果是固定的，攻击者很容易猜出后序的确认号，为了安全起见，避免被第三方猜到从而发送伪造的RST报文，因此ISN是动态生成的。

**5.什么是半连接队列**

服务器第一次收到客户端的SYN之后，就会处于SYN_RECD状态，此时双方还没有完全建立连接。

服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起来连接的就会放在全连接队列中，如果队列满了就有可能出现丢包现象。

**6.为什么服务器端易受SYN攻击？有什么防范措施吗？**

- 因为服务器端的资源是在第二次握手时分配的，而客户端的资源是在第三次握手时才分配的，若服务器收到大量伪造的IP地址发来的SYN包，则需要不断回复并等待确认，由于等待不到确认这些连接就会占满未连接队列，导致后来正常的连接请求报文被丢弃，从而引起网络拥塞甚至系统瘫痪。

- 防范措施：限制单个IP地址最大连接数、限制单位时间内连接数、修改重传次数为0（只要收不到客户端的响应则立即丢弃该连接）。

**2.四次挥手的流程？**

[![v7eZ2n.png](https://s1.ax1x.com/2022/09/05/v7eZ2n.png)](https://imgse.com/i/v7eZ2n)



第一次挥手：客户端向服务端发起请求，说我要释放连接啦；

第二次挥手：服务端向客户端发起确认，但这里还有一些东西没处理完，说处理完就下；

第三次挥手：服务端处理完后就向客户端发起释放连接请求；

第四次挥手：客户端收到请求后，发送信息给服务端，说好吧，你下吧；然后客户端等待2MSL后，才自己下机。



**7句话拓展：**

客户端主动调用close时，向服务端发送结束报文段FIN报，同时进入FIN_WAIT1状态；

服务器会收到结束报文段FIN报，服务器返回确认报文段ACK并进入CLOSE_WAIT状态，此时如果服务端有数据要发送的话，客户端依然需要接收。

客户端收到服务器对结束报文段的确认，就会进入到FIN_WAIT2状态，开始等待服务器的结束报文段；

服务器端数据发送完毕后，当服务器真正调用close关闭连接时，会向客户端发送结束报文段FIN包，此时服务器进入LAST_ACK状态，等待最后一个ACK的带来；

客户端收到服务器发来的结束报文段, 进入TIME_WAIT, 并发出送确认报文段ACK；

服务器收到了对结束报文段确认的ACK，进入CLOSED状态，断开连接。

而客户端要等待2MSL的时间，才会进入到CLOSED状态


**具体流程：**

- `第一次`：客户向服务器发送释放连接报文段，发送端数据发送完毕，请求释放连接（FIN=1），传输的第一个数据字节的序号是x（seq=x）；客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待1状态）；

- `第二次`：服务器向客户发送确认段，确认字号段有效（ACK=1），服务器传输的数据序号是y（seq=y），服务器期望接收客户数据序号为x+1（ack_seq=x+1）;服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）；客户端收到ACK段后，由FIN_WAIT_1进入FIN_WAIT_2；

- `第三次`:服务器向客户发送释放连接报文段，请求释放连接（FIN=1），确认字号段有效（ACK=1），表示服务器期望接收客户数据序号为x+1（ack_seq=x+1）;表示自己传输的第一个字节序号是y+1（seq=y+1）；服务器状态由CLOSE_WAIT 进入 LAST_ACK （最后确认状态）；

- `第四次`：客户向服务器发送确认段，确认字号段有效（ACK=1），表示客户传输的数据序号是x+1（seq=x+1），表示客户期望接收服务器数据序号为y+1+1（ack_seq=y+1+1）；客户端状态由FIN_WAIT_2进入TIME_WAIT，等待2MSL时间，进入CLOSED状态；服务器在收到最后一次ACK后，由LAST_ACK进入CLOSED；



**1.为什么握手是三次，而挥手时需要四次呢？**

其实在TCP握手的时候，接收端将SYN包和ACK确认包合并到一个包中发送的，所以减少了一次包的发送。对于四次挥手，由于TCP是全双工通信，主动关闭方发送FIN请求不代表完全断开连接，只能表示主动关闭方不再发送数据了。而接收方可能还要发送数据，就不能立即关闭服务器端到客户端的数据通道，所以就不能将服务端的FIN包和对客户端的ACK包合并发送，只能先确认ACK，等服务器无需发送数据时在发送FIN包，所以四次挥手时需要四次数据包的交互。

**2.TIME_WAIT状态有什么作用，为什么主动关闭方没有直接进入CLOSED状态释放资源？**

答：如果主动关闭方进入CLOSED状态后，被动关闭方发送FIN包后没有得到ACK确认，超时后就会重传一个FIN包。如果客户端没有TIME_WAIT状态而直接进入CLOSED状态释放资源，下次启动新的客户端就可能使用了与之前客户端相同的地址信息，有两个危害，第一种是这个刚启动的新的客户端绑定地址成功时，就会收到了一个重传的FIN包，对新连接就会造成影响。第二种是如果该新客户端向相同的服务端发送SYN连接请求，但是此时服务端处于LAST_ACK状态，要求收到的是ACK而不是SYN，因此就会发送RST重新建立请求。

**3.为什么TIME_WAIT状态需要经过2MSL才能进入CLOASE状态?**

答：MSL指的是报文在网络中最大生存时间。在客户端发送对服务端的FIN确认包ACK后，这个ACK包有可能到达不了，服务器端如果接收不到ACK包就会重新发送FIN包。所以客户端发送ACK后需要留出2MSL时间（ACK到达服务器器+服务器发送FIN重传包，一来一回）等待确认服务器端缺失收到了ACK包。也就是说客户端如果等待2MSL时间也没收到服务器端重传的FIN包，则就可以确认服务器已经收到客户端发送的ACK包。

- 1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端
- 1个 MSL 保证对端没有收到 ACK 之后进行重传的 FIN 报文能够到达

**4.一台主机上出现大量的TIME_WAIT是什么原因？应该如何处理？**

TIME_WAIT是主动关闭方出现的，一台主机出现大量的TIME_WAIT证明这台主机上发起大量的主动关闭连接。常见于一些爬虫服务器。这时候我们应该调整TIME_WAIT的等待时间，或者开启套接字地址重用选项。

**5.一台主机上出现大量的CLOSE_WAIT是什么原因？应该如何处理？**

答：CLOSE_WAIT是被动关闭方收到FIN请求进行回复之后的状态，等待上层程序进一步处理，若出现大量CLOSE_WAIT，有可能是被动关闭方主机程序中忘了最后一步断开连接后调用close释放资源。这是一个 BUG.，只需要加上对应的 close 即可解决问题。

**tcp连接管理中的保活机制**

答：tcp通信中，若两端长时间没有数据往来，则这时候每隔一段时间，服务端会向客户端发送一个保活探测数据报，要求客户端进行回复。若连续多次没有收到响应，就认为连接已经断开。长时间默认为7200s，每隔一段时间默认为75s，连续多次无响应默认为9次。这些数据都可以在套接字中修改，接口：Setsockopt。

**为什么TCP建立连接是三次握手，而关闭连接却是四次挥手？**

- 建立连接的时候，服务器在LISTEN状态下，不需要等待，可以立即建立连接，把ACK和SYN放在一个报文里发送给客户端，因此只需要三次握手。

- 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接受数据，而自己未必将所有数据都发送完了，所以服务器可以立即关闭，也可以发送一些数据后再关闭，所以服务器的确认报文（ACK=1）和连接释放报文（FIN=1，ACK=1）一般分开发送，因此形成四次握手。

**网络编程的作用？**

网络编程的本质使用套接字来进行进程间通信，但这些进程是分布在不同主机上的进程，因此网络编程在物联网方面有比较大的作用。

**TCP连接可能出错在什么地方**

TCP连接出错可能出现在以下几个环节：

- 三次握手：TCP连接建立的第一步是三次握手，如果客户端发送的SYN包没有被服务器正确响应，或者服务器发送的SYN+ACK包没有被客户端正确响应，就会导致连接建立失败。
- 数据传输：在数据传输的过程中，如果一个数据包在传输过程中丢失或者出现错误，就会触发超时重传机制。如果重传次数达到了阈值，就会放弃该数据包的传输，导致连接中断。
- 滑动窗口：TCP协议使用滑动窗口机制来控制数据包的发送和接收。如果滑动窗口的大小设置不当，就会导致数据包的丢失和延迟，进而导致连接失败。
- 超时控制：TCP协议使用超时重传机制来控制数据包的传输。如果超时时间设置过短，就会导致过多的数据包重传，影响传输效率；如果超时时间设置过长，就会导致连接的延迟和断开。
- 拥塞控制：TCP协议使用拥塞控制机制来防止网络拥塞。如果拥塞窗口的大小设置不当，就会导致网络拥塞，影响数据传输效率。



**TCP超时重传机制？**

TCP（Transmission Control Protocol）是一种面向连接的传输协议，在数据传输过程中会有超时重传机制，以确保数据传输的可靠性。当发送端发送数据时，如果在一定时间内未收到接收端的确认信息（ACK），就会触发超时重传机制，发送端会重新发送未收到确认的数据。

具体来说，==TCP中的超时重传机制是基于定时器实现的==。当发送端发送数据时，会启动一个定时器，并在定时器到期之前等待接收端的确认信息。如果在定时器到期之前收到了接收端的确认信息，则定时器被取消。如果在定时器到期时未收到确认信息，则发送端会将未收到确认的数据重新发送，并重新启动定时器，等待接收端的确认信息。

TCP超时重传的时间间隔是根据网络情况自适应调整的。当网络延迟较大时，超时重传的时间间隔会相应增加，以避免重复发送过多的数据，影响网络带宽的利用率。当网络延迟较小时，超时重传的时间间隔会相应缩短，以尽快获取接收端的确认信息，提高数据传输的效率。

总之，TCP的超时重传机制是通过定时器实现的，当发送端未收到接收端的确认信息时，会重新发送未确认的数据，并重新启动定时器，等待接收端的确认信息，以确保数据传输的可靠性。

TCP超时重传机制的实现是在操作系统的内核中完成的。以Linux内核为例，下面是一个简单的超时重传的流程：

发送端发送数据包，并启动定时器，计时器的超时时间是由TCP协议的内部算法计算得出的；
如果在计时器到期之前，接收到了ACK确认报文，就取消该定时器；
如果定时器超时了，但是还没有收到ACK确认报文，则重传该数据包，并再次启动一个新的定时器；
如果在超时重传次数达到了一定的阈值，就放弃该数据包的发送。

下面是一个简化的TCP超时重传的内核代码实现，具体实现可能因为不同的内核版本、不同的操作系统而有所不同：

```c
// 超时重传的定时器
struct timer_list retransmit_timer;

// 发送数据包
void tcp_send_packet(struct tcp_sock *tsk, struct tcp_packet *pkt) {
    // 启动定时器
    mod_timer(&retransmit_timer, jiffies + tsk->rto);
}

// 超时重传的处理函数
void tcp_retransmit_timer_handler(unsigned long arg) {
    struct tcp_sock *tsk = (struct tcp_sock *)arg;
    // 重传数据包
    tcp_send_packet(tsk, &tsk->snd_buf[tsk->snd_una]);
    // 重新启动定时器
    mod_timer(&retransmit_timer, jiffies + tsk->rto);
}

// 初始化超时重传定时器
void tcp_init_retransmit_timer(struct tcp_sock *tsk) {
    init_timer(&retransmit_timer);
    retransmit_timer.function = tcp_retransmit_timer_handler;
    retransmit_timer.expires = jiffies + tsk->rto;
    retransmit_timer.data = (unsigned long)tsk;
}
```


在上面的代码中，tcp_send_packet函数用于发送数据包，如果该数据包超时未收到确认报文，则会启动超时重传定时器；tcp_retransmit_timer_handler函数是定时器的回调函数，当定时器超时时，会执行该函数，实现数据包的重传；tcp_init_retransmit_timer函数用于初始化超时重传的定时器。

当发送方发送数据包后，如果在超时时间内未收到ACK确认报文，超时重传定时器会被触发，tcp_retransmit_timer_handler函数会被调用，实现数据包的重传。在数据包被重传后，超时重传定时器会被重新启动，等待下一次超时重传。

**TCP拥塞控制**

TCP拥塞控制算法是指TCP协议中通过控制发送数据包的速率来避免网络拥塞的一种机制。TCP协议中的拥塞控制算法主要包括以下四种：慢启动、拥塞避免、快速重传和快速恢复。

慢启动：在发送数据之前，TCP首先将拥塞窗口设为1，然后随着每次传输成功，窗口大小会加倍，直到达到一个阈值，此时切换到拥塞避免状态。慢启动算法的优点是在网络开始拥塞时能够快速适应并减少发送数据包的数量，但是由于窗口增长速度过快可能会引起网络拥塞。

拥塞避免：在拥塞避免状态下，TCP每次传输成功，拥塞窗口会按照线性增长的方式增加，而不是指数级增长。这样可以在保持一定发送速率的同时，避免网络拥塞。拥塞避免算法的优点是可以有效地避免网络拥塞，但是增长速度过慢可能会导致网络利用率降低。

快速重传：当TCP发现一个数据包丢失时，通常需要等待一定时间再进行重传，但快速重传算法可以在接收到重复的确认包时立即重传数据包。快速重传算法的优点是可以提高数据传输的效率，但是可能会增加网络负担。

快速恢复：快速恢复算法是在快速重传的基础上进行改进的，当接收到三个重复的确认包时，TCP可以假设之前发送的数据包已经到达接收端，并立即将拥塞窗口大小减半，以此来避免网络拥塞。快速恢复算法的优点是可以快速地恢复传输速率，但是可能会导致网络拥塞。

以上四种拥塞控制算法各有优缺点，可以根据具体的网络环境和传输需求选择合适的算法。





### TCP和UDP的区别？重要

- TCP是面向连接的。在通信之前需要三次握手建立连接，通信之后断开连接时需要四次挥手；UDP不需要进行连接建立。
- TCP是可靠传输服务。通过TCP传输数据可以保证数据无差错、不丢失、不重复；UDP尽最大努力交付，不保证可靠交付。
- 每个TCP对应的是点对点的连接；UDP支持一对一、一对多、多对一、多对多等多种方式的通讯。
- UDP对系统资源要求较少，通讯效率高，实时性好，应用于高速传输并且对实时性有要求的通信；TCP适合需要可靠连接，比如付费、加密数据等等方向都需要依靠TCP。
- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的；UDP 首部只有 8 个字节，并且是固定不变的。
- TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，可能会丢包和乱序。
- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。
- 应用场景：TCP用于FTP文件传输，HTTP / HTTPS；UDP用于包总量较少的通信，如 DNS、SNMP 等，视频、音频等多媒体通信，广播通信。





### PING是怎么工作的？

ICMP主要的功能包括：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置等。在IP通信中如果某个IP包因为某种原因未能达到目标地址，具体的原因将由ICMP通知。

ping命令执行的时候，源主机首先会构建一个ICMP回送请求消息数据包，由ICMP协议将这个数据包连同服务端IP一起交给IP层，IP层将以服务端IP作为目的地址，本机IP地址作为源地址，协议字段设置为1，再加上一些其他控制信息，构建一个IP数据包；然后加入MAC头；如果在本地ARP映射表中查找出服务端IP所对应的MAC地址，则可以直接使用，如果没有，则需要发送ARP协议查询MAC地址。获得MAC地址后，由数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址则是本机的MAC地址；还要附加上一些控制信息，依据以太网的介质访问规则将它们传送出去。



目的收到这个数据帧后，先检查它的目的MAC地址，并和本机的MAC地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层。IP层检查后，将有用的信息提取后交给ICMP协议。主机B会构建一个ICMP回送响应消息数据包，回送响应数据包的类型字段为0，序号为接收到的请求数据包中的序号，然后再发送出去给主机A。

在规定的时候间内，源主机如果没有接到ICMP的应答包，则说明目标主机不可达；如果接收到了ICMP回送响应消息，则说明目标主机可达。



### Socket编程

在Socket编程中，实现多线程的方式有多种，其中常用的方式包括：

基于pthread的多线程：这种方式使用pthread库实现多线程，每个客户端连接请求都会创建一个新的线程来处理。由于线程的切换开销较大，这种方式适合处理少量客户端连接的情况。

基于select的多路复用：这种方式使用select系统调用来实现多路复用，可以同时监听多个Socket文件描述符，一旦有文件描述符准备好可以读或写，就会通知程序进行相应的处理。这种方式适合处理大量连接，但是由于select的缺陷，在处理大量连接时性能会受到限制。

基于epoll的多路复用：这种方式使用epoll系统调用来实现多路复用，它比select更加高效，可以处理大量连接，并且能够支持较大的并发连接数。

基于poll的多路复用：这种方式与select类似，也是使用系统调用来实现多路复用，但相对于select而言，poll更加高效，并且能够支持更多的并发连接数。

总的来说，选择哪种方式取决于具体应用场景和需求。如果处理的连接数较少，可以选择基于pthread的多线程方式；如果需要处理大量连接，可以选择基于select、epoll或poll的多路复用方式。在选择时还需要考虑程序的可靠性、易用性、性能等因素。



**Socket流程：**

在对Socket有了大致了解之后，再来理解Socket的通信流程就容易很多了，Socket通信流程图如下：

![img](https://img-blog.csdnimg.cn/20191225154007754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9maWdodHN5ai5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

简单描述一下Socket的通信流程：

- 服务端这边首先创建一个Socket（Socket()），然后绑定IP地址和端口号（Bind()），之后注册监听（Listen()），这样服务端就可以监听指定的Socket地址了；
- 客户端这边也创建一个Socket（Socket()）并打开，然后根据服务器IP地址和端口号向服务器Socket发送连接请求（Connect()）；
- 服务器Socket监听到客户端Socket发来的连接请求之后，被动打开，并调用Accept()函数接收请求，这样客户端和服务器之间的连接就建立好了；
- 成功建立连接之后就可以你侬我侬了，客户端和服务器进行数据交互（Receive()、Send()）；
- 在腻歪完之后，各自关闭连接（Close()），交互结束；
  



### select，poll，epoll的使用场景以及区别？

I/O多路复用，就是一个进程维护多个Socket连接。

select/poll/epoll是内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。

多线程类型（pthread）的非阻塞IO缺点在于每一次发起系统调用只能检查一个文件描述符是否就绪，当文件描述符很多的时候，系统调用成本很高；

多路复用（select，poll，epoll）通过一次系统调用，检查多个文件描述符的状态。避免了频繁的用户态和内核态的切换，减少了系统调用的开销；

进程可以通过 select、poll、epoll 发起 I/O 多路复用的系统调用，这些系统调用都是同步阻塞的：**如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则如果所有文件描述符都未就绪，就阻塞调用进程，直到某个描述符就绪，或者阻塞时长超过设置的 timeout 后，再返回**。I/O 多路复用内部使用**非阻塞 I/O** 检查每个描述符的就绪状态。



#### select

工作原理：

select 原理将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。

==需要进行两次【遍历】文件描述符集合，一次内核一次用户；还会发生两次【拷贝】文件描述符集合。==

select使用固定长度的BitsMap，表示文件描述符集合。在Linux中，内核默认最大值为1024，就是只能监听0~1023的文件描述符；



#### poll

与select工作原理类似，但是将BitsMap存储集合方式改为了动态数组，以链表形式来组织，没有文件描述符个数限制；



#### epoll


epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

**对比**：

- `select`：调用开销大(需要复制集合)；集合大小有限制；需要遍历整个集合找到就绪的描述符
- `poll`：poll 采用数组的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别
- `epoll`：调用开销小(不需要复制)；集合大小无限制；采用回调机制，不需要遍历整个集合

`select`、`poll` 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；`epoll` 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符。





## 2.操作系统：

进程：运行态、就绪态、阻塞态、（创建态）、（结束态）

挂起状态：描述进程没有占用实际的物理内存空间的情况；

- 阻塞挂起状态：进程在外存并等待某个事件的出现；
- 就绪挂起状态：进程在外存，但只要进入内存，即刻开始运行；

PCB（process control block）进程控制块，是一种数据结构。

里面的信息为：

- 进程描述信息：
  - 进程标识符：标识各个进程，每个进程都有唯一一个标识符；
  - 用户标识符：进程归属的用户，用户标识符只要为共享和保护服务；

- 进程控制和管理信息：
  - 进程当前状态：如new，ready，running，waiting，blocked等；
  - 进程优先级：进程抢占CPU时的优先级；

- 资源分配清单：有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的I/O设备信息；
- CPU相关信息：CPU中各个寄存器的值，当进程被切换时，CPU的状态信息都会被保存在相应的PCB中，以便进程重新执行时，能从断点处继续执行；

PCB通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列；

就绪队列，阻塞队列；



线程：

线程之间可以并发运行且共享相同的地址空间；

线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

线程的缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。



游戏的用户设计不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程；



**线程与进程的比较：**

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是CPU调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

线程相比进程能减少开销，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的终止时间比进程快，因为线程释放的资源相比进程少得多；
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；



进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。



**线程是调度的基本单位，而进程则是资源拥有的基本单位；**



**调度原则：**

- CPU利用率：调度程序应确保CPU是始终匆忙的状态，这可以提高CPU的利用率；
- 系统吞吐量：吞吐量表示的是单位时间内CPU完成进程的数量，长作业的进程会占用较长的CPU资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- 周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；
- 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。



**调度算法：**

单核CPU系统：

- 先来先服务调度算法：

非抢占式的先来先服务（First Come First Seved，FCFS）算法。每次从就绪队列选择最先进入队列的进程，然后一直运行，知道进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

不利于短作业，对长作业有利，适用于CPU繁忙型作业的系统，而不是用I/O繁忙型作业的系统。

- 最短作业优先调度算法：

最短作业优先（Shortest Job First，SJF）调度算法。优先选择运行时间最短的进程来进行，有助于提高系统的吞吐量。

缺陷：对长作业不友好，比如一个就绪队列中存在很多的短作业，而只有一个长作业，此时就是一直执行短作业而不去执行长作业，使该长作业长期不会被执行；

- 高响应比优先调度算法：

权衡短作业和长作业。

每次进行进程调度时，先计算【响应比优先级】，然后把【响应比优先级】最高的进程投入进行。

$优先权=(等待时间+要求服务时间)/要求服务时间$

- 时间片轮转调度算法：

最古老、最简单、最公平、使用最广的算法就是时间片轮转（Round Robin，RR）调度算法。

每个进程运行的时间片都是一样的。

每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。

时间片设为20ms~50ms 通常是一个比较合理的折中值；



- 最高优先级调度算法：

希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。

静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；

动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。



处理优先级的方法：

非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程；

抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行；



- 多级反馈队列调度算法：

多级反馈队列（Multilevel Feedback Queue）调度算法是【时间片轮转算法】和【最高优先级算法】的综合和发展。

【多级】表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短；

【反馈】表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；





















进程：

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

守护进程（Daemon）：是在一类脱离终端在后台执行的程序, 通常以 d 结尾, 随系统启动, 其父进程 (ppid) 通常是init 进程



父进程先退出，没有进行处理的话，子进程变为孤儿进程，交由init进程管理，无危害；

子进程先退出，父进程没有获取其状态消息的话，子进程的进程描述符保留在系统中，称为僵尸进程，造成资源浪费，危害大；此时杀死父进程的话，僵尸进程就会变为孤儿进程，从而被init守护进程回收；









进程：

每个进程的用户地址空间都是独立的，一般是不能互相访问的，但是内核空间是每个进程都共享的，所以进程之间要通信必须通过内核；

进程间通信机制：管道、消息队列、共享内存、信号量

**管道**

管道：分为无名管道和有名管道

管道就是内核里面的一串缓存，管道传输的数据是无格式的流且大小受限；

无名管道就是Linux命令中那`|`用法，只不过是单向的，用完即销毁：

```shell
$ histroy | grep "ls"
```

有名管道：FIFO，要指定管道名字：

```shell
$ mkfifo myPipe
```

这个文件的类型为p

写入数据：

```shell
$ echo "hello" > myPipe
#然后会停住

$ cat < myPipe
#才可以读出，然后正常退出
```

- **管道通信效率极低，不适合进程间频繁地交换数据；**
- **好处是简单，并且可以得知管道中的数据是否被另一进程读取；**



**消息队列：**（跟邮件一样）

消息队列可以解决管道不适合进程间频繁地交换数据的缺点；消息队列是保存在内核中的消息链表；

- 通信不及时，数据大小有限制
- 消息队列通信过程中，存在用户态和内核态之间的数据拷贝开销；



**共享内存：**

使用共享内存可以很好的解决消息队列中用户态和内核态之间的数据拷贝开销的问题；

共享内存的机制就是进程双方拿出一块虚拟地址空间来，映射到相同的物理内存去。这样进程A写入的数据，进程B可以立马知道；

- 不能解决多个进程同时修改一个共享内存的问题，也就是冲突；
- 多进程竞争资源，而造成的数据错乱；



**信号量：**

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量。

**信号量本质上是一个整型的计数器，主要用于实现进程间的互斥和同步，而不是用于缓存进程间通信的数据；**

- ⼀个是 **P** **操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。

- 另⼀个是 **V** **操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。

**信号初始化为 1 ，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。**

使用场景：

操作同一内存空间

**信号初始化为 0 ，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执⾏。**

使用场景：

进程A生成数据后进行V操作，唤醒进程B进行P操作读取数据；



**信号：**

异常情况下的工作模式，就需要使用【信号】的方式来通知进程；信号与信号量并无直接关系。

linux中，提供的信号可以用 `kill -l`来进行查看，常见的`kill 9 PID号`就是如此操作信号；

信号是进程间通信机制中唯一的异步通信机制。并且信号产生，有以下几种对信号的处理方式。

1. 执行默认操作；
2. 捕捉信号；可以定义信号处理函数，当信号发生时可以执行相应的操作；
3. 忽略信号；不希望处理某信号时，可以忽略该信号，不做任何处理。但是有两个信号是应用进程无法捕捉和忽略的，即`SIGKILL` 即标号9，`SEGSTOP`，，它们可以在任何时候中断或结束某一进程。



**Socket：**

管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，而Socket能实现跨网络与不同主机上的进程之间进行通信；（也能实现同一主机上进程间通信）

Socket系统调用：

```c
int socket (int domain,int type,int protocal)
```

- domain参数用来指定协议族，比如`AF_INET`用于表示`IPV4`、`AF_INET6`用于`IPV6`、`AF_LOACL/AF_UNIX`用于本机；
- type参数用来指定通信特性，比如`SOCK_STREAM`表示的是字节流，对应TCP，`SOCK_DGRAM`表示数据报，对应UDP，`SOCK_RAW`表示原始套接字；
- protocal参数原本是用来指定通信协议的，但现在基本废弃。因为前面两个参数已经指定完成，一般此参数为0；

服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket，后续⽤来传输数据。

所以，监听的 socket 和真正⽤来传送数据的 socket，是「**两个**」 socket，⼀个叫作**监听** **socket**，⼀个叫作**已完成连接** **socket**。



UDP通信则是调用sendto和recvfrom，每次都要传入目标主机的IP地址和端口；

本地socket不需要绑定IP地址和端口，而是绑定一个本地文件；



线程：

避免多线程资源竞争的互斥、同步的方法。

竞争条件下输出结果存在不确定性。由于多线程之星操作共享变量的这段代码可能会导致竞争状态，因此将此段代码称为临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。

我们希望这段代码，也就是临界区是互斥的（mutualexclusion），也就是说保证一个线程在临界区执行时，其他线程应该被组织进入临界区。



**同步：**

同步就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。

实现互斥与同步一般有如下两种方法：

- 锁：加锁、解锁操作；
- 信号量：P、V操作；

当获取不到锁时，线程就会一直while循环，不做任何事情，所以就被称为【忙等待锁】，也被称为自旋锁【spin lock】。

信号链通常做法：

```c
//信号量数据结构
type struct sem_t{
    int sem;// 资源个数
    queue_t*q //等待队列
} sem_t;

//初始化信号量
void init(sem_t *s, int sem)
{
    S->sem = sem;
    queue_init(s->q);
}

//P操作
void P(sem_t *s)
{
	S->Sem--;
    if(s->sem<0)
    {
		1.保留调用线程CPU现场
		2.将该线程的TCB插入到S的等待队列；
        3. 设置该线程为等待状态
        4. 执行调度程序
    }
}

//V操作
void V(sem_t *s)
{
	S->sem++;
    if(s->sem <= 0)
    {
		1. 移出 s 等待队列首元素
        2.将该线程的TCB插入就绪队列
        3. 设置该线程为「就绪」状态
    }
}
```





**生产者——消费者问题**

[![](https://s1.ax1x.com/2022/09/16/vzhcUP.png)](https://imgse.com/i/vzhcUP)

实现代码：

[![vzhfgg.png](https://s1.ax1x.com/2022/09/16/vzhfgg.png)](https://imgse.com/i/vzhfgg)





死锁问题：

死锁要同时满足四个条件才能发生：

- 互斥条件；
- 持有并等待条件；
- 不可剥夺条件；
- 环路等待条件；

互斥条件是指多个线程不能同时使用同一个资源；

持有并等待条件：当一个线程想申请某个资源时，该资源被另一线程持有了，此时这个线程会处在等待状态，并且不会释放自己已经持有的资源；

不可剥夺条件：当线程已经持有资源，在自己用完之前不能被其他线程获取；

环路等待条件：在死锁发生的时候，两个线程获取资源的顺序构成了环形链；

[![vz4mqA.png](https://s1.ax1x.com/2022/09/16/vz4mqA.png)](https://imgse.com/i/vz4mqA)



最常用的就是使用资源有序分配法来破坏环路等待条件；

加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题；

- 互斥锁加锁失败后，线程会释放CPU，给其他线程；
- 自旋锁加锁失败后，线程会忙等待，直到它拿到锁；

读写锁在读多写少的场景，能发挥出优势；

互斥锁、自旋锁、读写锁都属于悲观锁；

悲观锁认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁；

 乐观锁假定冲突的概率很低。工作时先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作； （在线文档）





操作系统三大调度机制：【进程调度】、【页面置换】、【磁盘调度算法】

【进程调度】看上面；



【页面置换】

缺页异常（缺页中断）：当CPU访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。

- 缺页中断在指令执行【期间】产生和处理中断信号，而一般中断在一条指令执行【完成】后检查和处理中断信号；

- 缺页中断返回到该指令的开始重新执行【该指令】，而一般中断返回回到该指令的【下一条指令】执行。

[![xpmBj0.png](https://s1.ax1x.com/2022/09/17/xpmBj0.png)](https://imgse.com/i/xpmBj0)

若发生缺页中断，找不到空闲页时，便需要【页面置换算法】

[![xpnCVS.png](https://s1.ax1x.com/2022/09/17/xpnCVS.png)](https://imgse.com/i/xpnCVS)

- 状态位：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问参考；
- 访问字段：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考；
- 修改位：表示该页在调入内存后是否有被修改过；
- 硬盘地址：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用；

页面置换算法的功能是：当出现缺页异常，需要调入新页面而内存已满时，选择被置换的物理页面；

算法的目的是尽可能减少页面的换入换出的次数，常见如下：

- 最佳页面置换算法（OPT）；
- 先进先出置换算法（FIFO）；
- 最近最久未使用的置换算法（LRU）；
- 时钟页面置换算法（Lock）；
- 最不常用置换算法（LFU）；



**设备管理：**

操作系统为了屏蔽设备之间的差异，给每个设备都增加一个叫设备控制器（Device Control）的组件；

设备控制器有三类寄存器，分别是【状态寄存器】（Status Register）、【命令寄存器】（Command Register）以及【数据寄存器】（Data Register）：

- 数据寄存器：CPU向I/O设备写入需要传输的数据，比如要打印的内容是【Hello】，CPU就要发送一个H字符给到对应的I/O设备；
- 命令寄存器：CPU发送一个命令，告诉I/O设备，要进行输入/输出操作，于是就会交给I/O设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成；
- 状态寄存器：目的是告诉CPU，现在已经在工作或工作已经完成，如果已经在工作状态，CPU再发送数据或命令过来，都是没有用的；

输入输出设备可以分为两大类：【块设备】（Block Device）和【字符设备】（Character Device）：

- 块设备：把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB是常见的块设备；
- 字符设备：以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作；

块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的数据缓冲区。

- CPU写入数据得等缓冲区的数据到一定量时才会发给设备；
- CPU从控制器的缓冲区读取数据时，也需要缓冲区屯够一部分，才进行拷贝到内存；

CPU与设备的控制寄存器和数据缓冲区进行通信的方法：

- 端口I/O，每个控制寄存器被分配一个I/O端口，可以通过特殊的汇编指令操作这些寄存器，比如in/out类似的指令；
- 内存映射I/O，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区；



I/O控制方式：轮询、软中断、硬中断、DMA

DMA（Direct Memory Access）

[![xpME2d.png](https://s1.ax1x.com/2022/09/17/xpME2d.png)](https://imgse.com/i/xpME2d)



**I/O多路复用：**

使用一个进程来维护多个socket，I/O多路复用技术。

select/poll/epoll



**select:**

select实现多路复用的方式是，将已连接的Socket都放在一个==文件描述符集合==，然后调用select函数将文件描述符集合==拷贝==到内核里，让内核来检查是否有网络事件产生，检查的方式就是==遍历==文件描述符集合。当检查到有事件产生后，将此Socket标记为可读或可写，接着再把整个文件描述符集合==拷贝==回用户态里，然后用户态还需要再通过==遍历==的方法找到可读或可写的Socket，然后再进行处理。

select使用固定长度的BitsMap，表示文件描述符集合，在Linux系统中，由内核中的FD_SETSIZE限制，默认最大值为1024。



**poll：**

poll不再使用BitsMap来存储所关注的文件描述符，取而代之使用动态数组，以链表形式来组织。但与select并无多大差别。



select和poll都是使用线性结构存储进程关注的Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的Socket，时间复杂度O(n)，而且也需要在用户态和内核态之间拷贝文件描述符集合。



**epoll：**

- epoll在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的Socket通过epoll_ctl()函数加入内核中的红黑树中；
- epoll使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用epoll_wait()函数时，只会返回有事件发生的文件描述符的个数。



所以epoll就使用一个相对智能的回调机制：**当某个文件准备好之后要唤醒等待线程时，它不是简单的把等待者设置为可运行，它还会进一步在等待者的结构中刻上“XXX到此一游”，**这样，当线程被唤醒之后，它就可以通过这些留言看到是谁唤醒了自己，而不是逐个询问刚才是谁把我唤醒了。



| 系统调用                               | select                                                       | poll                                                         | epoll                                                        |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事件集合                               | 用户通过3个参数分别传入感兴趣的可读可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。这使得用户每次调用select都要重置这3个参数 | 统一处理所有事件类型，因此只需要一个事件集参数，用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件 | 内核通过一个事件表直接管理用户感兴趣的所有事件，因此每次调用epoll_wait时，无须反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件 |
| 应用程序索引就绪文件描述符的时间复杂度 | O(n)                                                         | O(n)                                                         | O(1)                                                         |
| 最大支持文件描述符数                   | 一般有最大值                                                 | 65535                                                        | 65535                                                        |
| 工作模式                               | LT                                                           | LT                                                           | 支持ET高效模式                                               |
| 内核实现和工作效率                     | 轮询，算法事件复杂度O(n)                                     | 轮询，算法事件复杂度O(n)                                     | 回调，算法事件复杂度O(1)                                     |



## 3.ARM：

晶振震荡12次为一个机器周期。

机器周期=12*（时钟周期）



**1.STM32启动过程：**

STM32启动过程主要指的是，系统上电后CPU执行的第一条指令，到调用用户写的main函数这一段过程。

1. 上电复位，硬件设置SP、PC的值；
2. 找到了Reset_Handler的地址后，CPU就从这里开始取指令运行程序；
3. 调用SystemInit函数，设置系统时钟；
4. 调用__main函数，软件对SP寄存器赋值，完成数据段的重定位、消除bss段，初始化栈空间等操作；
5. 最终__main函数会调用用户的main函数，进入到用户程序中。



大小端模式：

- 大端：符号位在所表示的内存的低地址，用于快速判断数据的正负和大小；
- 小端：CPU运算效率更高；
- x86结构为小端模式，KEIL C51为大端模式。很多ARM，DSP为小端模式，有些ARM处理器可以由硬件决定大端还是小端；



**ARM处理器模式：**==一共有7种模式==

- 用户模式（User）；
- 快速中断模式（FIQ）；
- 普通中断模式（IRQ）；
- 管理模式（Svc）；
- 数据访问中止模式（Abort）；
- 未定义指令中止模式（Und）；
- 系统模式（Sys）；

在每一种处理器模式中有一组相应的寄存器。在任意一种处理器模式下，可见的寄存器包括 15 个通用寄存器（R0~R14）、一个或者二个状态寄存器以及程序计数器（PC）。在所有的寄存器中，有些是各模式共用同一个物理寄存器，有些寄存器是各个模式自己拥有独立的物理寄存器



**ARM寄存器**

==一共有37个寄存器==

包括：

- 31个通用寄存器，包括R15——PC（程序计数器）在内；
- 6个状态寄存器

以上都是32位寄存器

ARM 架构中有多种寄存器，包括通用寄存器、程序计数器、状态寄存器等。



其中最重要的是通用寄存器，它们用于存储数据、地址和中间结果。以下是 ARMv7 架构中通用寄存器的概述：

STM32就是ARMv7-M

| 寄存器   | 名称                   | 作用                                             |
| -------- | ---------------------- | ------------------------------------------------ |
| R0 ~ R3  | 通用寄存器             | 主要用于在子程序间传递参数                       |
| R4~R11   | 通用寄存器             | 主要用于保存局部变量                             |
| IP (R12) | 子程序间scratch寄存器  | 用于保存SP，在函数返回时使用该寄存器出栈，记作ip |
| SP (R13) | 堆栈指针               | 用于管理堆栈                                     |
| LR (R14) | 链接寄存器             | 用于存储函数调用后返回地址                       |
| PC (R15) | 程序计数器             | 用于存储下一条指令的地址                         |
| CPSR     | 当前程序状态寄存器     | 用于存储当前指令的执行状态和程序状态             |
| SPSR     | 异常模式状态寄存器     | 存储异常模式下的 CPSR 值                         |
| SPSR_svc | 内核模式状态寄存器     | 存储在内核模式下的 CPSR 值                       |
| SPSR_irq | 中断模式状态寄存器     | 存储在中断模式下的 CPSR 值                       |
| SPSR_fiq | 快速中断模式状态寄存器 | 存储在快速中断模式下的 CPSR 值                   |

其中 R0 - R12 和 SP 可以被程序直接访问，LR 和 PC 可以被程序修改但通常由系统管理，CPSR 只能被系统修改。

在 ARMv8 架构中，除了通用寄存器以外还引入了 NEON 寄存器和 FP 寄存器，用于处理向量计算和浮点计算。





**SP寄存器**

SP 是 ARM 架构中的一个重要寄存器，全称为堆栈指针寄存器（Stack Pointer Register），也叫做栈顶指针寄存器。

它用于存储当前程序使用的堆栈顶部地址，指向当前栈顶所在的内存地址。

在 ARM 处理器中，栈是以向下增长的方式实现的，也就是栈顶地址比栈底地址小。

在函数调用和返回过程中，SP 寄存器用于管理栈的空间，通过改变 SP 寄存器的值，可以向栈中压入数据、弹出数据，以及调整栈的大小。

当函数被调用时，SP 寄存器会指向当前函数的栈帧的栈顶，这样就可以将参数和局部变量等数据压入栈中。

当函数返回时，SP 寄存器会恢复到原来的值，这样就可以将栈帧中的数据弹出，返回到调用函数。

在异常处理过程中，SP 寄存器也发挥了重要作用。

当发生异常时，处理器会自动保存一些寄存器的值，包括 PC、LR 和 CPSR 等，以便于异常处理结束后恢复现场。

同时，处理器还会切换到特定的异常处理模式（如 IRQ 模式或者 SVC 模式），并将 SP 寄存器切换到该模式下的堆栈空间中。

这样，异常处理程序就可以使用该模式下的堆栈空间，而不会影响到其他模式的堆栈。

需要注意的是，SP 寄存器的值必须是 4 字节对齐的，这是因为在 ARM 处理器中，栈顶地址必须是 4 的倍数，这样才能保证访问栈中的数据时可以正确对齐。因此，在使用 SP 寄存器时，需要注意栈帧大小和对齐方式，避免发生访问异常或者数据损坏等问题。







51和32架构的区别 

MCU可以运行Liunux吗，为什么 

STM32启动过程（上电开始->main执行的过程） 

中断响应执行流程，中断上下文指的什么，保存中断上下文是完成的什么操作，以STM32为例，都有哪些寄存器被保存 

STM32 F1和F4的区别 

Cotex-M系列使用浮点运算对STM32中断效率会产生什么影响 

STM32常见寄存器:R13(SP,堆栈指针)，R14(LR，连接寄存器)，R15（PC程序计数器）作用 

什么是大小端模式 





**轮询与中断：**

如果是I/O设备：

轮询就是CPU定时依次询问每一个周边设备是否需要服务嘛，需要的话就给予服务，服务结束后再问下一个设备；

每个设备都有相同的机会执行，处理设备数量有限，效率低下

增加系统开销，并且无法及时感知设备的变化。



中断就是：

I/O设备导致CPU核上的中断线发生信号变化，会发起硬中断，CPU执行上下文切换，跳转到中断处理程序中执行。

处理器利用率明显提高，I/O设备并行操作效率提高，但是中断发生过多，处理器的缓冲区溢出，反而会导致处理器去处理情况的次数变多，效率降低。



总的来说，二者并没有谁更优谁更劣，只是说在哪些应用场景下，使用哪种方法更合适！



**动态内存分配函数：**



- malloc函数是C标准库提供的动态内存分配函数，用于在用户空间分配内存，不适用于内核开发。

- kmalloc函数是Linux内核提供的动态内存分配函数，用于在内核空间分配小块内存，一般用于分配小于4KB的内存。kmalloc会自动管理内存碎片，避免内存泄漏。

- alloc函数是一种可插拔的内存分配机制，可以使用不同的内存分配算法，如SLAB、SLUB和SLOB等，用于在内核空间分配小块内存。alloc函数相对于kmalloc更加灵活，但也更加复杂。

- vmalloc函数用于在内核空间分配大块内存，一般用于分配大于4KB的内存。vmalloc会将分配的内存映射到虚拟地址空间中，而不是直接映射到物理地址空间中。这种映射方式使得vmalloc的内存分配速度较慢，但适用于大块内存的分配和释放。

在Linux内核开发中，常用的是kmalloc和vmalloc函数，需要根据具体的需求选择合适的函数。



在嵌入式面试中，会涉及到一些与CPU相关的知识，常见的包括：

CPU架构：嵌入式系统中常用的CPU架构包括ARM、MIPS、PowerPC、x86等。面试官可能会询问你对某种CPU架构的了解程度，以及其特点和应用场景等。

CPU指令集：面试官可能会问到某种CPU的指令集，如ARM指令集、MIPS指令集等。你需要了解该指令集的基本指令、寄存器、内存访问方式等。

CPU中断：面试官可能会问到CPU中断的相关知识，包括中断类型、中断向量表、中断处理函数等。你需要了解中断的作用、触发方式、处理流程等。

CPU缓存：面试官可能会问到CPU缓存的相关知识，包括缓存结构、缓存一致性、缓存替换算法等。你需要了解缓存的作用、原理以及在嵌入式系统中的应用。

CPU时钟：面试官可能会问到CPU时钟的相关知识，包括时钟频率、时钟分频、时钟源等。你需要了解时钟的作用、基本原理以及时钟管理的相关技术。

以上是一些常见的与CPU相关的知识点，当然还可能会涉及到更深入的技术细节。在面试前，建议对所涉及的CPU架构和技术有一定的了解，并对可能涉及到的问题做好准备。



## 4.数电模电：

### (1)EEPROM和FLASH的区别？

| 区别/类别 | EEPROM                       | FLASH                     |
| --------- | ---------------------------- | ------------------------- |
| 掉电丢失  | 否                           | 否                        |
| 存储方式  | 电子擦除的可编程只读存储器   | 电荷擦除的可编程存储器    |
| 擦除方式  | 字节可编程                   | 块可编程（通常4KB或更大） |
| 读写速度  | 每个字节进行单独的编程和擦除 | 写慢，读快                |
| 寿命      | 比FLASH长                    | 稍短                      |
| 使用场景  | 频繁擦写                     | 一次擦除，多次读的场景    |
|           |                              |                           |

EEPROM和FLASH都是非易失性存储器，可以在掉电后保留数据。它们之间的主要区别如下：

存储方式：EEPROM（Electrically Erasable Programmable Read-Only Memory）是一种可以通过电子擦除的可编程只读存储器，而FLASH（Floating-gate memory cell）则是一种通过电荷擦除的可编程存储器。

擦除方式：EEPROM是一种字节可编程的存储器，可以对单个字节进行编程和擦除，而FLASH需要对整个块（通常是4KB或更大）进行擦除。这意味着，如果需要修改EEPROM中的某个字节，只需擦除该字节并写入新数据，而在FLASH中，如果需要修改某个字节，必须先擦除整个块，然后将修改后的所有数据写入该块。

读写速度：一般来说，FLASH的读写速度比EEPROM快得多。这是因为FLASH可以在一次擦除之后写入多个字节，而EEPROM需要对每个字节进行单独的编程和擦除。

寿命：由于EEPROM可以单独擦除每个字节，因此它的寿命通常比FLASH更长。在FLASH中，每次擦除都会损坏一些细胞，因此随着擦除次数的增加，FLASH的寿命会逐渐缩短。

总之，EEPROM和FLASH都有各自的优点和缺点，选择哪种取决于具体的应用场景和需求。



Flash和EEPROM都是存储器类型，但是它们和RAM和ROM都有所不同。

Flash是一种非易失性存储器，类似于ROM，但可以重写。它通常用于存储程序代码和其他常量数据。与ROM不同的是，Flash可以被多次编程和擦除，而ROM通常只能在生产过程中编程一次。Flash通常比EEPROM更快速和更大容量，但是它的擦除和编程过程需要更长的时间。

EEPROM也是一种非易失性存储器，类似于Flash，但是它比Flash更慢、更小容量，且更昂贵。EEPROM可以通过电子擦除和编程来写入和读取数据，因此适用于需要频繁读写的应用，例如存储配置数据和校准参数。

与RAM不同，Flash和EEPROM在断电时也可以保存数据，因此它们是非易失性存储器。RAM则是一种易失性存储器，当断电时，其中的数据会被清空。

总的来说，Flash和EEPROM都是存储器，但是它们的特点和应用场景有所不同。Flash比EEPROM更快速、更大容量，但是擦写速度较慢；EEPROM则适合需要频繁读写的应用，但是容量较小且更昂贵。



STM32读取FLASH需要配置：

在STM32中读写FLASH需要配置以下内容：

1. 使能FLASH接口时钟：需要在RCC寄存器中设置FLASH接口时钟的使能位。
2. 设置FLASH访问延迟：在FLASH访问之前，需要将Flash_ACR寄存器中的LATENCY位设置为适当的值以匹配系统时钟频率。
3. 解锁FLASH：使用FLASH_Unlock()函数解锁FLASH。
4. 擦除FLASH：使用FLASH_Erase_Sector()函数擦除需要操作的FLASH扇区。
5. 编程FLASH：使用FLASH_Program()函数将需要写入FLASH的数据编程到指定的FLASH地址。
6. 锁定FLASH：使用FLASH_Lock()函数锁定FLASH。

使能FLASH接口时钟并设置FLASH访问延迟，然后解锁FLASH并擦除需要操作的FLASH扇区。接下来，将需要写入FLASH的数据编程到指定的FLASH地址，并最后锁定FLASH。在主循环中，从FLASH中读取数据并进行相应的处理。



### (2)ADC和DAC

ADC（Analog-to-Digital Converter）

ADC是一种模拟信号转换成数字信号的电路，用于将模拟信号转换成数字信号，以便于嵌入式系统进行数字信号处理。ADC通常由模拟前端、采样保持电路、比较器、计数器、数字输出接口等部分组成。

ADC的工作原理是将模拟信号进行采样，然后将采样值与参考电压进行比较，得到一个比较结果，再将比较结果通过计数器进行数字化，得到一个数字量表示模拟信号的大小。ADC的精度一般由比较器的精度、参考电压的精度、采样率和计数器的位数决定。



DAC（Digital-to-Analog Converter）

DAC是一种数字信号转换成模拟信号的电路，用于将数字信号转换成模拟信号，以便于嵌入式系统进行模拟信号处理。DAC通常由数字输入接口、数模转换电路、滤波电路和输出放大器等部分组成。

DAC的工作原理是将数字量转换成电压或电流信号，通过滤波电路去除高频噪声，并经过输出放大器放大到合适的电平，以便于控制外部设备。

在嵌入式系统中，DAC通常用于输出模拟控制信号、音频信号、马达控制信号等模拟量信号，将数字信号转换成模拟信号以便于控制外部设备的工作。

需要注意的是，ADC和DAC的精度、采样率、输出范围等都需要根据具体的应用需求进行选型和设计。同时，ADC和DAC的设计需要考虑到电源噪声、电磁干扰、接地等问题，以确保信号的准确性和可靠性。



ADC采样频率

ADC采样频率是指ADC模块在一定时间内能够完成多少次采样操作。通常，ADC采样频率越高，能够处理的信号频率也就越高，但同时也需要更高的处理速度和更高的精度来保证信号的准确性。

ADC采样频率的选择需要根据具体的应用需求来决定，一般有以下几个方面需要考虑：

信号频率：ADC的采样频率需要至少满足被采集信号的两倍频率（即奈奎斯特采样定理），否则会产生采样失真。

处理速度：ADC的采样频率需要满足系统的处理速度，以确保处理器能够及时处理采集到的数据。

精度：ADC的采样频率越高，需要更高的精度来保证信号的准确性，否则会产生量化误差。

功耗：ADC采样频率越高，所需的功耗也就越大，需要考虑系统的电源供应能力。

需要注意的是，不同的ADC模块具有不同的采样速率范围，一般在几百KHz到几百MHz之间，需要根据具体的应用需求来选择适当的ADC模块和采样频率。同时，在使用ADC模块时，需要注意模拟前端的滤波、放大和参考电压等问题，以确保采集到的信号符合要求。

电压值 = 数字量 * 参考电压 / 分辨率



奈奎斯特采样定理

奈奎斯特采样定理，又称为奈奎斯特-香农采样定理，是一条关于信号采样的基本定理，指出在采集模拟信号时，必须以不小于信号最高频率的两倍的采样率进行采样，才能够完整地重构信号。

具体来说，假设信号最高频率为fmax，根据奈奎斯特采样定理，采样频率fs应该满足：

fs >= 2 * fmax

只有在满足这个条件的情况下，采样得到的数字信号才能够准确地代表原始的模拟信号。如果采样频率不足2倍最高频率，则会出现抽样失真，即信号的高频成分会被采样成低频成分，从而导致信息丢失或失真。

举个例子，假设要对一个最高频率为4kHz的信号进行采样，根据奈奎斯特采样定理，采样频率应该满足：

fs >= 2 * 4kHz = 8kHz

也就是说，采样频率应该不小于8kHz才能够保证采样到的数字信号能够准确地代表原始信号。如果采样频率过低，例如只有4kHz，则会出现抽样失真，导致采样得到的数字信号无法准确地反映原始信号。

奈奎斯特采样定理在信号处理和通信系统中具有重要的应用，可以保证信号的准确性和可靠性。同时，需要注意的是，采样频率并不是越高越好，过高的采样频率会浪费系统资源，增加系统成本。因此，需要根据具体的应用需求来选择合适的采样频率。





### (3)虚短和虚断：

虚短和虚断是电路分析中常用的两种假设，用于简化电路分析。虚短指的是将一个二极管或晶体管的基极或集电极看作直接短路，虚断则是将其看作直接断路。在实际电路中，由于二极管和晶体管的特性，这种假设通常是合理的。

### (4)分波整流：

分波整流电路是一种常用的电路，用于将交流信号转换为直流信号。它通过将输入信号分成正半周和负半周两部分，然后分别进行整流和滤波，最终得到一个平滑的直流信号。分波整流电路常用于电源电路中，用于将交流电源转换为直流电源。

### (5)甲类和乙类放大电路：

甲类放大电路指的是放大器工作时电流始终流过输出管，即输出信号的波形始终与输入信号同相，但是功率效率较低。乙类放大电路则是在输入信号小于一定幅值时，输出管处于截止状态，电流不流过输出管，因此功率效率较高，但是会出现信号失真的问题。

### (6)布尔代数运算

==卡诺图化简==

逻辑代数是一种数学分支，主要研究逻辑命题之间的关系和逻辑函数的性质。在逻辑代数中，有许多基本定理，其中比较重要的包括以下几个：

同一律（Identity Law）：$A+0=A$，$A \cdot 1=A$，其中0和1分别表示逻辑和和逻辑或的零元和单位元。

零律（Null Law）：$A+1=1$，$A \cdot 0=0$，其中0和1分别表示逻辑和和逻辑或的零元和单位元。

互补律（Complement Law）：$\overline{\overline{A}}=A$，即一个命题的否定的否定等于该命题本身。

结合律（Associative Law）：$A+(B+C)=(A+B)+C$，$A \cdot (B \cdot C)=(A \cdot B) \cdot C$，即逻辑和和逻辑或的结合法则和逻辑与的结合法则。

分配律（Distributive Law）：$A \cdot (B+C)=A \cdot B+A \cdot C$，$A+(B \cdot C)=(A+B) \cdot (A+C)$，即逻辑和和逻辑或的分配法则和逻辑与和逻辑或的分配法则。

吸收律（Absorption Law）：$A+(A \cdot B)=A$，$A \cdot (A+B)=A$，即当A包含在B中时，逻辑和和逻辑或的吸收法则。

摩根定律和德摩根定律不是同一个东西，但它们是相互关联的。摩根定律是指逻辑代数中的两个基本定理之一，描述了逻辑非和逻辑与、逻辑或之间的关系，其表述为：

逻辑非的摩根定律：$\overline{A+B}=\overline{A} \cdot \overline{B}$，$\overline{A \cdot B}=\overline{A}+ \overline{B}$。

逻辑与和逻辑或的摩根定律：$(A+B)'=A' \cdot B'$，$(A \cdot B)'=A'+B'$。

德摩根定律是基于摩根定律的基础上进一步发展出来的定理，也描述了逻辑非和逻辑与、逻辑或之间的关系。其具体表述如下：

逻辑非的德摩根定律：$\overline{A+B}=\overline{A} \cdot \overline{B}$，$\overline{A \cdot B}=\overline{A}+ \overline{B}$。

逻辑与和逻辑或的德摩根定律：$\overline{A \cdot B}= \overline{A}+ \overline{B}$，$\overline{A+B}=\overline{A} \cdot \overline{B}$。



### (7)单片机IO口

单片机的IO口通常包括数字IO和模拟IO两种类型。数字IO只能进行高低电平的输入输出操作，而模拟IO则可以进行模拟信号的输入输出操作，需要使用ADC和DAC等外设进行转换。

在模拟IO中，常用的知识点包括开漏输出和三态输出等。其中，开漏输出是指输出端可以拉低，但是不能拉高，需要外接上拉电阻才能实现高电平输出。在实现开漏输出时，常常使用MOS管来实现，示意图如下：


其中，MOS管的源极连接到IO口，漏极接地，而栅极则由IO口控制。当IO口输出低电平时，MOS管导通，将输出端拉低；当IO口输出高电平时，MOS管截止，输出端不受影响，需要外接上拉电阻才能实现高电平输出。

除了开漏输出，三态输出也是常用的模拟IO模式之一，其输出端可以输出高低电平，也可以不输出电平，即悬空状态。三态输出通常使用三态门实现，通过使输出口既可以连接到高电平、低电平、也可以不连接（即悬空）来实现三态输出。

STM32标准库中GPIO的输入输出模式主要有以下几种：

- 推挽输出（GPIO_Mode_OUT_PP）：IO口作为输出时，输出高低电平的方式是通过内部的推挽电路实现的，可驱动普通负载如LED等。输出端口可以输出高电平和低电平，可以提供较大的输出电流，适合驱动负载较大的器件。
- 开漏输出（GPIO_Mode_OUT_OD）：IO口作为输出时，输出高电平时与电源正极连接，输出低电平时开启开漏输出管，与地相连，可驱动开漏输出负载。输出端口只能输出低电平，高电平需要外接上拉电阻。可以防止输出端口短路，适合驱动开关、LED等低功耗负载。
- 通用输入（GPIO_Mode_IN_FLOATING）：IO口作为输入时，没有内部上下拉电阻，通过外部电路来控制输入信号。
- 上拉输入（GPIO_Mode_IN_PULLUP）：IO口作为输入时，内部带有上拉电阻，当外部电路不接通时，IO口输入高电平。
- 下拉输入（GPIO_Mode_IN_PULLDOWN）：IO口作为输入时，内部带有下拉电阻，当外部电路不接通时，IO口输入低电平。
- 模拟输入（GPIO_Mode_AIN）：IO口作为模拟输入时，可以连接模拟信号源，用于模拟量采集。

还有一些复用的功能。

### (8)基尔霍夫定律:

基尔霍夫定律是电学中的基本定律之一，用于描述电路中电流和电压之间的守恒关系。基尔霍夫定律分为基尔霍夫电流定律（KCL）和基尔霍夫电压定律（KVL）两个部分。

基尔霍夫电流定律（KCL）：KCL用来描述在一个节点上，流入该节点的电流等于流出该节点的电流之和。简单地说，即电流守恒定律。

如果一个节点有n条支路（即有n个电流流入该节点），则该节点的KCL公式可以表示为：

$$\sum_{i=1}^n I_i = 0$$

其中，Ii表示第i条支路上的电流，单位为安培（A）。

例如，在一个电路中，一个节点有3条支路，分别有2A、3A和4A的电流流入该节点，则根据KCL可得：

$$2A + 3A + 4A = 0$$

这显然不符合守恒定律，因此说明KCL公式应该是写成：

$$\sum_{i=1}^n I_i = I_{in} - I_{out} = 0$$

其中，Iin表示进入该节点的电流，Iout表示离开该节点的电流。



基尔霍夫电压定律（KVL）：KVL用来描述沿着任意一个闭合回路的电压之和等于零。简单地说，即电压守恒定律。

如果一个回路有n个电压源（可以是电池、电源、信号发生器等），则该回路的KVL公式可以表示为：

$$\sum_{i=1}^n V_i = 0$$

其中，Vi表示第i个电压源的电压，单位为伏特（V）。

例如，在一个电路中，一个回路有3个电压源，分别有5V、10V和15V的电压，则根据KVL可得：

$$5V + 10V + 15V = 0$$

这显然不符合守恒定律，因此说明KVL公式应该是写成：

$$\sum_{i=1}^n V_i = \sum_{i=1}^n IR_i = 0$$

其中，Ri表示第i个电阻器的电阻值，I表示回路中的电流。



基尔霍夫定律在电路分析和设计中应用广泛，可以用来计算电路中电流和电压的分布情况、验证电路设计的正确性等。

### (9)欧姆定律:

欧姆定律是电学基本定律之一，用来描述电路中电流、电压和电阻之间的关系，它的数学表达式为：

V = IR

其中，V表示电压（单位为伏特，简写为V），I表示电流（单位为安培，简写为A），R表示电阻（单位为欧姆，简写为Ω）。

欧姆定律的基本思想是，电路中通过某一电阻的电流大小，正比于该电阻两端的电压大小，而与电阻自身的值无关。这个关系可以用上述公式表示。

欧姆定律适用于大部分的电路，无论是直流电路还是交流电路，无论是简单电路还是复杂电路，都可以用欧姆定律来描述其中的电流、电压和电阻之间的关系。

欧姆定律的应用范围非常广泛，是电学中最基本、最基础的定律之一，为电路分析和设计提供了重要的理论基础。

### (10)三极管

三极管（Transistor）是一种半导体元件，通常用来放大和控制电流。它由两个PN结构组成，其中一个被称为发射极（Emitter），另一个被称为集电极（Collector），中间是控制极（Base）。三极管有两种类型：NPN和PNP，分别由两个不同类型的半导体材料组成。

在工作时，三极管需要加上正向偏压或反向偏压，通过控制极对集电极的电流进行控制。NPN型三极管在控制极加上正向电压时，会增加它与发射极之间的电子浓度，使得发射极向集电极注入更多的电子，从而放大电流。PNP型三极管则是通过控制极加上负向电压来控制集电极到发射极之间的电子流，同样也可以用来放大电流。

三极管广泛应用于各种电子电路中，例如放大器、开关、振荡器、稳压器、逆变器等。在放大器中，三极管通常被用作电流放大器、电压放大器和功率放大器。在开关电路中，三极管可以用作开关，根据控制电压的变化，可以实现开关的开闭。在振荡器中，三极管可以通过反馈回路产生振荡信号。



### (11)MOS管

MOS管，即金属氧化物半导体场效应管（Metal-Oxide-Semiconductor Field-Effect Transistor，简称MOSFET），是一种常用的半导体器件。它主要由四个部分组成：金属门极（Gate）、氧化物绝缘层（Oxide）、半导体材料（Semiconductor）、源极（Source）和漏极（Drain）。

MOS管主要有两种类型：N沟道型MOS（NMOS）和P沟道型MOS（PMOS），其中N沟道型MOS的工作原理是利用负偏压控制N型半导体通道的电阻，从而控制漏极和源极之间的电流，而P沟道型MOS则是利用正偏压控制P型半导体通道的电阻。在这两种MOS管中，NMOS的使用更为广泛。

MOS管的主要特点是控制电压低、输入电阻高、输出电阻低、耗功率低、速度快等优点，常用于数字电路、模拟电路和功率电子领域。在数字电路中，MOS管通常用于构成逻辑门、触发器、计数器等组合逻辑和时序逻辑电路；在模拟电路中，MOS管则用于构成放大器、滤波器、振荡器等模拟电路；在功率电子领域中，MOS管则被广泛应用于交流调速、直流调速、逆变器、开关电源等领域。

需要注意的是，MOS管在使用时需要注意其最大额定电压、最大功率、开启延迟时间、关闭延迟时间等参数。此外，在实际应用中，由于MOS管存在漏电流等问题，通常需要采用保护电路来提高其稳定性和可靠性。



### (12)触发器

触发器是一种基本的数字电路元件，用于在数字电路中存储和控制二进制信号。它是由若干个门电路组成的电路，常见的有SR触发器、D触发器、JK触发器等。

SR触发器是由两个输入端S和R、一个输出端Q以及一个时钟信号CK组成的电路。当CK的电平发生变化时，根据S和R的输入情况，输出端Q的状态会发生相应的变化。

D触发器是由一个数据输入端D、一个时钟信号CK、一个输出端Q和一个异步清零端CLR组成的电路。当CK信号的电平发生变化时，D触发器会将D输入的二进制信号存储到输出端Q中。

JK触发器是由两个输入端J和K、一个时钟信号CK、一个输出端Q以及一个异步清零端CLR组成的电路。JK触发器的工作原理比较复杂，但是在数字电路中应用较为广泛。JK触发器的名称来源于它的J和K输入。J和K分别代表"Jump"和"Kill"的缩写，即"跳跃"和"清零"。在JK触发器中，当J和K同时为高电平时，输出将翻转，当J和K都为低电平时，输出不变，当J和K中只有一个为高电平时，输出将保持上一个状态。

在STM32的GPIO中，常见的触发器应用是通过配置输入输出模式中的外部中断模式来实现。当GPIO引脚检测到信号变化时，会触发外部中断，并执行相应的中断服务程序。

此外，STM32还支持通过DMA方式实现GPIO数据的传输。在这种情况下，DMA控制器可以通过触发器实现数据的高速传输，从而提高数据传输效率。



### (13)RAM 和 FLASH

RAM和Flash都是计算机中的存储器件，但它们有一些不同之处。

RAM在单片机中被用作暂存器，即它被用于存储正在进行的程序和数据。这些数据可以快速读写，并且在单片机关闭或断电时会被清除，因此不适合用于长期存储。在单片机中，RAM的容量通常较小，通常只有几KB或几十KB。

Flash在单片机中通常用于存储程序代码和其他持久性数据，例如配置信息或其他不需要频繁修改的数据。 Flash容量通常比RAM大得多，可以达到几MB或更高。 Flash的读取速度相对较快，但写入速度较慢，因此在单片机中进行Flash编程需要特殊的算法和技术。

在单片机系统中，RAM和Flash的使用通常需要特别的设计和优化，以充分利用它们的优点并避免瓶颈和问题。例如，为了减少RAM的使用量，可以使用常量表格、状态机和其他数据结构来优化程序代码。为了最大化Flash的寿命，可以采用特殊的编程算法和技术，如擦写均衡和错误检测和纠正。

总之，RAM和Flash在单片机系统中扮演不同的角色，需要特别的设计和优化以最大限度地利用它们的优点。在单片机编程中，了解它们之间的差异和使用场景非常重要，以确保程序的正确性和性能。

| 区别/种类 | RAM（Random Access Memory）                   | FLASH                                                       |
| --------- | --------------------------------------------- | ----------------------------------------------------------- |
| 掉电丢失  | 是                                            | 否                                                          |
| 应用场景  | RAM主要用于临时存储计算机正在执行的程序和数据 | Flash主要用于存储操作系统、应用程序、文件和其他持久性数据。 |
| 读写速度  | 极快（us级别）                                | 写入速度慢，读写速度快（ms级别）                            |
| 容量      | 小                                            | 大                                                          |
| 寿命      | 比FLASH短                                     | 稍长                                                        |
| 工作原理  | DRAM（电容器和晶体管）、SRAM（几个晶体管）    | 许多可编程存储单元组成，一个单元（电容器和浮栅晶体管）      |
|           |                                               |                                                             |

RAM（Random Access Memory）和Flash是两种不同的存储器件，它们的工作原理也有所不同。

RAM的工作原理：RAM是一种随机访问存储器，它由一组动态随机存储器单元（DRAM）或静态随机存储器单元（SRAM）组成。DRAM的存储单元是一个电容器和一个晶体管组成的，当晶体管通电时，电容器中的电荷被存储，并且可以被读取。SRAM的存储单元是由几个晶体管组成的，其中一个晶体管用于控制读写操作，另外两个晶体管用于存储一个比特的数据。RAM的存储单元可以快速读取和写入数据，但需要电源持续供电以保持存储数据。

Flash的工作原理：Flash是一种非易失性存储器，它由许多可编程存储单元（Flash单元）组成。Flash单元是由一个电容器和一个浮栅晶体管组成的。当写入数据时，一个高电压被施加到晶体管的栅极上，将电荷注入电容器中，这改变了晶体管的电导性，从而存储了一个比特的数据。当需要读取数据时，Flash单元中的电荷被检测到，并被转换成数字数据。Flash的工作原理类似于EPROM（可编程只读存储器），但Flash可以通过多次编程和擦除来改变存储的数据，而EPROM只能被编程一次。

总之，RAM和Flash的工作原理是不同的。RAM是一种易失性存储器，需要电源持续供电以保持存储的数据；而Flash是一种非易失性存储器，可以长期存储数据即使没有电源供应。RAM的存储单元可以快速读取和写入数据，而Flash的存储单元读写速度相对较慢，但可以多次编程和擦除以改变存储的数据。



### (14)RAM 和 ROM

| 区别/类别 | RAM（Random Access Memory）            | ROM（Read-Only Memory）             |
| --------- | -------------------------------------- | ----------------------------------- |
| 掉电丢失  | 是                                     | 否                                  |
| 分类      | DRAM动态随机存储器、SRAM静态随机存储器 | 只读存储器ROM、可编程只读存储器PROM |
| 访问速度  | 快速读取                               | 读写较慢                            |
| 应用场景  | 临时存储程序和数据，以便CPU快速访问    | 存储固定的数据                      |
|           |                                        |                                     |
|           |                                        |                                     |
|           |                                        |                                     |

RAM（Random Access Memory）和ROM（Read-Only Memory）是计算机中常见的两种存储器件，它们的区别主要在以下几个方面：

可读写性：RAM是一种可读写的存储器，可以在需要时读取或写入其中的数据；而ROM是一种只读存储器，通常在出厂时就已经存储了固定的数据，无法被更改。

存储方式：RAM存储器通常是动态随机存储器（DRAM）或静态随机存储器（SRAM），数据存储在存储单元中，需要电源持续供电以保持存储的数据。而ROM存储器通常是只读存储器（ROM）或可编程只读存储器（PROM），数据存储在存储单元中，可以长期保存，无需电源供应。

数据访问速度：RAM的存储单元可以快速读取和写入数据，但需要电源持续供电以保持存储数据；而ROM的存储单元读写速度相对较慢，但可以长期保存数据，无需电源供应。

应用场景：由于RAM可以读写数据，因此通常用于临时存储程序和数据，以便CPU快速访问；而ROM通常用于存储固定的数据，例如BIOS（基本输入/输出系统）、操作系统、引导程序等，这些数据在启动计算机时被加载到RAM中，并用于控制计算机的各种操作。

总之，RAM和ROM的最大区别在于其可读写性和存储方式。RAM是一种可读写的存储器，需要电源持续供电以保持存储数据，用于临时存储程序和数据；而ROM是一种只读存储器，数据无法更改，用于存储固定的数据，例如BIOS、操作系统、引导程序等。



RAM（Random Access Memory）和ROM（Read-Only Memory）的工作原理有所不同：

RAM的工作原理：
RAM是一种随机存取存储器，它可以读取和写入数据。RAM通常是由DRAM（Dynamic RAM）或SRAM（Static RAM）组成的。DRAM的存储单元由一个电容和一个晶体管组成，它们共同组成一个位线，位线上的每个存储单元对应一个比特（0或1）。当需要读取RAM中的数据时，CPU向RAM发送一个地址信号，RAM根据地址信号选择相应的存储单元，并将其存储的数据发送回CPU。当需要向RAM中写入数据时，CPU向RAM发送一个地址信号和数据信号，RAM根据地址信号选择相应的存储单元，并将数据写入其中。

SRAM的存储单元由一个触发器和几个逻辑门组成。SRAM与DRAM相比，其速度更快，但价格更高。

ROM的工作原理：
ROM是一种只读存储器，数据是在制造时就被写入到其中，无法更改。ROM的存储单元通常由一个电路和一个晶体管组成，它们共同组成一个位线，位线上的每个存储单元对应一个比特（0或1）。ROM中的数据可以通过芯片上的电路直接读取，CPU无法向ROM中写入数据。

有些ROM具有可编程的特性，例如EPROM（Erasable Programmable ROM）、EEPROM（Electrically Erasable Programmable ROM）和Flash存储器。这些ROM在制造时没有写入数据，而是可以通过特定的程序进行编程，将数据写入其中。EPROM和EEPROM需要特殊的擦除器进行擦除和重新编程，而Flash存储器可以通过特定的程序进行擦除和重新编程。

## 5.通信协议：

### (1)iic

当面试官问到 I2C 协议时，你可以考虑以下几个方面进行回答：

#### ①I2C 协议的工作原理是什么？

I2C（Inter-Integrated Circuit）是一种串行通信协议，用于连接微控制器和外部设备，如传感器、存储器、转换器等。它使用两根线（SDA和SCL）进行通信，其中SDA线传输数据，SCL线传输时钟信号。I2C协议采用主从结构，主设备通过发送地址来选择通信对象，并控制总线上的时序。从设备只能在主设备的控制下发送和接收数据。

iic全称：（$Inter-Integrated-Circuit$）是内部整合电路的称呼，是一种串行通讯总线，多用主从架构，1980年飞利浦公司研发。

iic有两条线，一条是串行数据（SDA）和串行时钟（SCL），每个器件都有一个唯一的地址识别；

半双工；串行总线；主从结构；



I2C协议的通信过程如下：

主设备发送起始信号（Start）：主设备将SDA线从高电平拉低，接着将SCL线从高电平拉低，以发出起始信号。在起始信号之前，主设备必须获得总线的控制权。

主设备发送从设备地址：主设备在SCL线为低电平时，发送8位地址，最高位指示读写方向（0表示写，1表示读），剩余7位表示从设备的地址。

从设备发送应答信号（ACK）：被选择的从设备收到地址后，将SDA线从高电平拉低，以发出应答信号。如果SDA线保持高电平，则表示从设备不存在或无法响应。

主设备发送数据或命令：主设备在SCL线为低电平时，将8位数据或命令发送给从设备。

从设备发送应答信号：从设备接收到数据或命令后，将SDA线从高电平拉低，以发出应答信号。如果SDA线保持高电平，则表示从设备无法响应。

主设备发送停止信号（Stop）：主设备将SCL线保持为高电平，接着将SDA线从低电平拉到高电平，以发出停止信号。在停止信号之后，主设备释放总线的控制权。

以上就是I2C协议的基本工作原理。

#### ②I2C 协议的主从设备是什么？如何区分主从设备？

在I2C协议中，主设备是发起通信的设备，从设备是被动响应通信请求的设备。I2C总线上只有一个主设备，但可以有多个从设备。

在I2C协议中，主从设备的区分是通过设备地址实现的。主设备发送一个设备地址，从设备通过识别这个地址来确认是否需要响应通信请求。因此，每个从设备都有一个唯一的设备地址，而主设备通过发送对应的设备地址来和从设备进行通信。在传输数据时，主设备控制总线并向从设备发送数据，从设备则在主设备的控制下响应数据。



#### ③I2C 协议中的起始信号和停止信号是什么？有什么作用？

I2C协议中的起始信号和停止信号是两种特殊的数据信号，用于指示数据传输的开始和结束。

起始信号是由主设备发出的，在数据传输之前发送。它告诉从设备数据传输即将开始，从设备需要做好准备。起始信号由SCL线拉低后，SDA线从高电平跳变到低电平构成。

停止信号是由主设备发出的，在数据传输之后发送。它告诉从设备数据传输已经结束。停止信号由SCL线保持高电平时，SDA线从低电平跳变到高电平构成。

起始信号和停止信号的作用是标识数据传输的开始和结束，使得主设备和从设备都能够准确地识别传输数据的开始和结束，从而避免数据传输的错误。



==STM32开发时要设置为开漏输出！！！！==

[![p9loaz6.png](https://s1.ax1x.com/2023/04/28/p9loaz6.png)](https://imgse.com/i/p9loaz6)



**起始信号：SCL为高，SDA由高向低跳变；** SDA在高电平至少4.7us，然后拉低至少4us；

```c
void iic_start(){
	SDA_OUT();//SDA设置为输出模式；
	SCL_HIGH;
	SDA_HIGH;
	delay();
	SDA_LOW;
	delay();
}
```

**结束信号：SCL为高，SDA由低向高跳变；**SCL先拉高至少4us，SDA再拉高4.7us；

```c
void IIC_Stop(void)
{
	SDA_OUT();//SDA设置为输出模式；
	SCL_LOW;
	delay();
	SDA_LOW;
	delay();
	SCL_HIGH;
	delay();
	SDA_HIGH;
	delay();
}
```

**应答信号：接收完数据后，发送低电平脉冲；应答信号都是SCL从低到高至少4us，然后SDA发送相应的数据；**

[![p9loyod.png](https://s1.ax1x.com/2023/04/28/p9loyod.png)](https://imgse.com/i/p9loyod)



#### ④I2C 协议的数据传输方式是什么？如何控制数据传输速率？

I2C协议的数据传输方式是基于帧的，一个完整的数据传输帧包括7个位，其中第一个位是起始位（Start Bit），表示数据传输的开始，最后一个位是停止位（Stop Bit），表示数据传输的结束，中间的5个位则是数据位（Data Bits），用于实际的数据传输。

在I2C协议中，主设备通过控制SCL时钟线的上升沿和下降沿来控制数据传输的速率。在传输数据之前，主设备发送一个时钟脉冲序列，使得从设备的SDA线保持稳定的电平状态，然后主设备发送起始信号（Start Bit），接着发送从设备的地址和读写位，最后从设备返回应答信号（ACK Bit）。在数据传输期间，主设备控制SCL时钟线的脉冲频率，从设备在每个时钟脉冲之后将数据位发送到SDA线上，主设备接收数据并返回应答信号（ACK Bit），以确保数据传输的正确性。在传输完所有数据之后，主设备发送停止信号（Stop Bit）来结束本次数据传输。

控制数据传输速率的方法是通过控制SCL时钟线的频率来实现。在I2C协议中，可以定义不同的标准时钟频率，包括标准模式下的100Kbps和快速模式下的400Kbps。此外，还可以使用高速模式和超高速模式来实现更快的数据传输速率。主设备和从设备需要在同一个时钟频率下进行数据传输。

[![p9loOS0.png](https://s1.ax1x.com/2023/04/28/p9loOS0.png)](https://imgse.com/i/p9loOS0)





I2C 协议中的 ACK/NACK 是什么？有什么作用？

#### ⑤I2C 协议中的地址格式是什么？有哪些类型？

I2C协议中的地址格式分为7位和10位两种类型，其中7位地址是标准模式，可以用于大多数应用，10位地址则是扩展模式，可以使用更多的设备地址。每个I2C设备都有一个唯一的7位或10位地址，用于识别该设备并与之通信。

在7位地址模式下，地址由7个比特位组成，其中前6个位用于设备地址，最后一个位用于选择读或写模式。在10位地址模式下，地址由10个比特位组成，其中前4个位被设置为固定值，接下来是一个可变的设备地址，最后两个位用于选择读或写模式。需要注意的是，10位地址模式的设备数量较少，而且设备的地址分配也比较复杂，因此在实际应用中较少使用。



7位寻址，第八位为读写位，其中0为写write，1为读read；最低位（LSB） 是第8 位；

8位地址，厂商将最后一位包含而已；

10位地址：需要在初始化的时候配置为10bit地址模式（由第一个字节设置，固定前缀**1111 0xxx xxxx xxx_** 其中十位x就是十位地址，_为读写位；



#### ⑥I2C 协议中的重复起始信号是什么？有什么作用？

I2C协议中的重复起始信号（Repeated Start）是在一次完整的数据传输过程中，在主设备和从设备之间进行连续传输时，主设备在不断地发送数据时不需要先发送停止信号再发送起始信号，而是直接发送重复起始信号。

重复起始信号的作用是可以在一个数据传输过程中，连续地访问同一个从设备。在一些需要读取多个寄存器的应用中，使用重复起始信号可以避免每次读取都需要重新定位从设备的地址，从而提高数据传输的效率。



#### ⑦I2C 协议中的时钟同步是什么？如何实现？

I2C协议中的时钟同步是指主设备通过时钟线向从设备传输时钟信号，以确保数据传输的同步性和准确性。I2C协议中的时钟信号由主设备产生和控制，从设备只能跟随主设备的时钟信号进行数据传输。

I2C协议的时钟同步通过两根信号线来实现，即SCL和SDA线。在数据传输之前，主设备首先向SCL线上发送一个时钟脉冲，然后向SDA线发送起始信号。之后，在数据传输的过程中，主设备每发送一位数据，就会向SCL线发送一个时钟脉冲，以通知从设备数据的传输状态。在数据传输完成后，主设备会向SDA线发送停止信号，以结束整个数据传输过程。

通过时钟同步，主设备和从设备可以实现数据的同步传输，并且可以保证数据传输的准确性和可靠性。



#### ⑧iic的特点？

一般有上拉电阻，一般为4.7k~10k之间，默认拉高；

多主机会产生总线裁决问题。当多个主机同时想要占用总线时，企图启动总线传输数据，就叫做总线竞争；

#### ⑨软件iic和硬件iic有什么区别？

==IIC实现分为硬件IIC和软件IIC两种；==

软件IIC是使用程序控制SCL，SDA两线输出高低电平，可以适用任何管脚，来模拟IIC协议的时序，较为灵活；

硬件IIC，只需要调用写好的硬件IIC的控制函数，而不用去模拟电平，而且是固定管脚，不能灵活应用，胜在速度快，效率高，可以使用DMA

#### ⑩iic能有多少个从机？

7位地址算，LSB为读写位，就是2^7=128，但是地址0x00是保留地址，故有127个地址，理论上可以挂127个从机设备；
但是规定了总线电容不超过400pF，所以实际就是不超过8个左右从机设备；

#### ⑩①线与的作用？

参与主线多主机的仲裁机制；

仲裁原则：当多个主器件同时想占用总线时，如果某个主器件发送高电平，而另一个主器件发送低电平，则发送电平与此时SDA总线电平不符的那个器件将自动关闭其输出级。

如果主设备A拉高SDA时, 已经有其他主设备将SDA拉低了. 由于 **1 & 0 = 0** 那么主设备A在检查SDA电平时, 会发现不是高电平, 而是低电平. **说明其他主设备抢占总线的时间比它早**, 主设备A只能放弃占用总线. 如果是高电平, 则可以占用.



#### ⑩②为什么要用开漏输出？

IIC协议支持多个主设备与多个从设备在一条总线上, 如果不用开漏输出, 而用推挽输出, 会出现主设备之间短路的情况. 至于为什么需要上拉电阻, 那是因为IIC通信需要输出高电平的能力.

开漏输出还能实现 **线与** (自行百度), 减少一个与门, 简化电路.



#### ⑩③推挽输出和开漏输出的区别？

推挽输出：输出逻辑0，则N-MOS激活；输出逻辑1，则P-MOS激活；

开漏输出：

在不接上拉电阻时，输出逻辑0，则N-MOS激活；输出逻辑1，P-MOS不会激活，不会输出高电平；

在接上拉电阻时，输出逻辑0，则N-MOS激活；输出逻辑1，P-MOS激活，可以输出高电平；

总结：

开漏输出如果不接上拉电阻，没有输出高电平的能力；



#### ⑩④如何确定iic的通信方向

在IIC协议中，传输方向是由主设备（Master）通过控制总线上的时钟信号来确定的。具体来说，在IIC总线上，主设备负责发出时钟信号和控制信号，从设备（Slave）则根据主设备的控制信号来确定数据的传输方向。

在IIC总线上，数据传输是双向的，也就是说主设备可以向从设备发送数据，也可以从从设备接收数据。

为了实现数据的双向传输，IIC总线上使用了一个叫做“时分复用”（Time Division Multiplexing，TDM）的技术。具体来说，在每一个传输周期中，主设备通过控制信号来确定传输方向，然后从设备在对应的时间段内向总线上发送数据或接收数据。

由于总线上只有一个主设备和多个从设备，因此在同一时间内只会有一个设备在进行数据传输，从而避免了数据冲突和错误的发生。

需要注意的是，在实际使用IIC总线进行数据传输时，还需要注意数据传输的时序和协议。具体来说，主设备需要在发送数据前先向从设备发送一个地址码，以确定数据传输的目标设备；而从设备在接收到主设备发送的地址码后，需要向主设备发送应答信号，以确认数据传输的目标设备已经被正确识别。此外，还需要考虑数据的传输速率、数据的格式等因素。

在IIC总线中，主设备通过控制总线上的时钟信号来确定数据的传输方向。具体来说，主设备向总线上发送时钟信号，每个时钟周期称为一个“时钟周期”（Clock Cycle）。在每个时钟周期内，主设备根据需要向总线上发送或接收数据。

IIC总线上的时钟信号是由主设备控制的，主设备通过控制SCL（时钟线）信号的电平变化来控制时钟信号。当SCL信号处于高电平时，IIC总线处于空闲状态，此时主设备可以向总线上发送起始信号（Start Condition）；当SCL信号从高电平变为低电平时，表示一个时钟周期的开始，此时主设备可以向总线上发送数据或读取从设备的数据；当SCL信号从低电平变为高电平时，表示一个时钟周期的结束，此时主设备需要等待从设备的应答信号。

根据时钟信号的变化，主设备可以控制数据的传输方向。在发送数据时，主设备将数据按照一定的格式（例如，帧格式、字节格式等）写入数据寄存器，并向总线上发送起始信号和从设备的地址码，然后将数据依次发送到总线上。在接收数据时，主设备需要向总线上发送读取命令，并等待从设备的应答信号，然后从总线上读取数据。

### (2)MQTT

#### ①什么是MQTT协议？它有哪些特点？

MQTT（Message Queuing Telemetry Transport）协议是一种轻量级的、基于发布/订阅模式的通信协议，主要用于物联网设备间的通信。它是一种面向消息的协议，支持异步的、松耦合的消息通信。

MQTT协议的特点包括：

轻量级：MQTT协议设计简洁，通信开销小，适合在网络带宽有限的环境中使用，如物联网等场景。

基于发布/订阅模式：MQTT协议采用发布/订阅模式，消息的发送方（Publisher）将消息发布到特定的主题（Topic），消息的接收方（Subscriber）订阅相应的主题，实现消息的异步传输，各个设备之间没有直接的通信关系。

可靠性：MQTT协议支持QoS（Quality of Service）机制，可以确保消息的可靠传输，同时也支持消息的离线缓存，确保订阅者可以接收到离线时期发布的消息。

灵活性：MQTT协议支持多种消息类型，可以发送文本、二进制、JSON、XML等各种类型的消息，同时也支持各种认证、加密和压缩方式，可以满足不同的安全性和效率要求。

易于实现：MQTT协议的实现比较简单，很容易在各种设备和编程语言中实现，同时也有丰富的客户端库和工具支持。

开放标准：MQTT协议是一个开放标准，已经被ISO和OASIS组织正式认可，具有广泛的应用和支持。

总之，MQTT协议是一种轻量级、灵活、可靠的通信协议，适用于各种物联网设备间的消息通信。

#### ②MQTT协议的组成部分是什么？它们各自的作用是什么？

MQTT协议主要由以下四个部分组成：

客户端(Client): 作为消息发布者或订阅者，使用MQTT协议连接到消息代理服务器并进行消息的发布或订阅操作。

代理服务器(Broker): MQTT的中心组件，接收来自客户端的消息并路由到订阅了相关主题的客户端。代理服务器也会存储遗嘱消息和保留消息。

主题(Topic): 用于标识消息的主题，由多个层级构成，层级之间使用斜线(/)分隔。例如，sensor/temperature 表示温度传感器的主题。

消息(QoS): MQTT支持三个不同的QoS级别，用于确保消息传输的可靠性和一致性。QoS 0表示最多一次的传输，QoS 1表示至少一次的传输，QoS 2表示恰好一次的传输。

这些组成部分共同构成了MQTT协议的基本框架，使得客户端可以通过连接到代理服务器来进行消息的发布和订阅操作。

#### ③MQTT协议中的发布/订阅模式是什么意思？与请求/响应模式有什么区别？

MQTT协议中的发布/订阅模式是指消息的发布者（Publisher）将消息发布到特定的主题（Topic），而订阅者（Subscriber）可以通过订阅相应的主题来接收消息。发布者和订阅者之间不存在直接的通信关系，而是通过MQTT服务器来实现消息的转发。

与发布/订阅模式不同的是请求/响应模式（Request/Response），它是一种同步的通信模式，需要请求方发送请求消息，等待响应方返回响应消息，才能继续下一步操作。在请求/响应模式中，请求方和响应方之间必须建立直接的通信连接，而在发布/订阅模式中，发布者和订阅者之间并不需要直接的通信连接。

MQTT的发布/订阅模式适用于一对多的场景，可以实现消息的广播和订阅者的动态加入或退出。例如，设备上传传感器数据时，可以将数据发布到特定的主题中，各个订阅者可以订阅这个主题来接收数据。而请求/响应模式适用于一对一的场景，需要请求方和响应方之间直接的通信连接，例如HTTP协议中的请求/响应模式，客户端发送请求给服务器，服务器返回响应给客户端。

总的来说，发布/订阅模式和请求/响应模式都有各自的优势和适用场景，需要根据实际的需求进行选择。

#### ④MQTT协议中的客户端是什么？服务端是什么？它们之间如何通信？

在MQTT协议中，客户端（Client）是指使用MQTT协议连接到MQTT代理服务器（Broker）的设备或应用程序。客户端可以是消息发布者（Publisher），也可以是消息订阅者（Subscriber），它们通过MQTT协议与代理服务器进行通信。

MQTT代理服务器（Broker）是MQTT协议的中心组件，接收来自客户端的消息，并将这些消息路由到订阅了相关主题的客户端。代理服务器还可以存储遗嘱消息和保留消息。

客户端和代理服务器之间的通信是基于发布/订阅模式（Publish/Subscribe），即客户端发布消息到指定的主题（Topic），代理服务器将这些消息路由到订阅了该主题的客户端。客户端通过TCP/IP协议与代理服务器进行连接，连接成功后，客户端可以发布消息或订阅主题。当代理服务器接收到发布的消息时，会将消息发送给所有订阅了该主题的客户端。客户端还可以发送PINGREQ消息以保持与代理服务器的连接，代理服务器在接收到PINGREQ消息后，会回复PINGRESP消息表示连接正常。

总之，MQTT协议中的客户端和代理服务器之间的通信基于发布/订阅模式，通过TCP/IP协议进行连接和消息传输。客户端可以发布消息或订阅主题，代理服务器接收并路由消息，同时也可以存储遗嘱消息和保留消息。

#### ⑤MQTT协议中的消息格式是什么样的？包含哪些信息？

MQTT协议中的消息格式如下：

消息类型	报文类型	标志位	保留	剩余长度	可变报头	消息体
						

- 消息类型：MQTT协议中的消息分为连接消息、发布消息、订阅消息、退订消息、断开连接消息、PING请求和响应消息等不同类型。
- 报文类型：每个消息都有一个对应的报文类型，例如CONNECT、PUBLISH、SUBSCRIBE等等。
- 标志位：不同消息类型的标志位不同，例如CONNECT消息的标志位包括Clean Session、Will、Will QoS、Will Retain、Username、Password等。
- 保留：保留字段，用于后续协议版本扩展使用。
- 剩余长度：指整个消息的长度，不包括固定报头的长度，可变报头和消息体的长度是可变的，所以需要使用剩余长度字段来表示整个消息的长度。
- 可变报头：不同消息类型的可变报头不同，例如CONNECT消息的可变报头包括Protocol Name、Protocol Version、Connect Flags、Keep Alive等。
- 消息体：不同消息类型的消息体不同，例如PUBLISH消息的消息体就是要发布的消息内容。

在MQTT协议中，客户端和服务端之间通过传输不同类型的消息来进行通信。客户端向服务端发送连接消息进行连接，然后可以发布消息或订阅主题等操作。服务端会根据客户端的请求来进行相应的处理，并向客户端发送响应消息。

#### ⑥MQTT协议中的消息质量等级（QoS）是什么？有哪些等级？它们之间有什么区别？

MQTT协议中的消息质量等级（Quality of Service，QoS）用于控制消息传递的可靠性和确认机制。它共分为三个等级：QoS0、QoS1和QoS2，它们之间的区别如下：

QoS0：最多一次传输。消息发布者发送消息时只传输一次，没有确认机制，可能会有消息丢失或重复的情况发生。

QoS1：至少一次传输。消息发布者发送消息时，会收到来自代理服务器（Broker）的确认消息（PUBACK），如果未收到确认消息，则会尝试重新发送消息，可能会有消息重复的情况发生。

QoS2：恰好一次传输。消息发布者发送消息时，会收到来自代理服务器的确认消息（PUBREC），然后再发送确认确认消息（PUBREL），最后收到来自代理服务器的最终确认消息（PUBCOMP）。这种等级保证消息传递的可靠性，但会增加消息传输的时间和开销。

总之，QoS等级越高，消息传递的可靠性越高，但是传输时间和开销也会增加。开发者在实际应用中需要根据实际情况来选择适合的QoS等级。

#### ⑦MQTT协议中的遗嘱（will）机制是什么？它有什么作用？

MQTT协议中的遗嘱（will）机制是指在客户端异常断开连接后，服务器自动向其他客户端发送一条遗嘱消息。遗嘱机制的作用是确保消息的可靠性，避免消息因客户端异常断开连接而丢失。

遗嘱机制需要在客户端连接服务器时指定遗嘱主题和遗嘱消息。当客户端异常断开连接时，服务器会自动发布该客户端指定的遗嘱消息到指定的遗嘱主题。其他客户端可以订阅该遗嘱主题，以获取遗嘱消息。

遗嘱消息可以指定QoS级别，以确保消息的可靠传输。当客户端重新连接服务器时，服务器会清除该客户端之前发布的消息，以避免重复消息的出现。

遗嘱机制可以用于监控客户端连接状态，及时发现异常情况并采取相应的措施。例如，当一个传感器节点失去连接时，可以通过发布遗嘱消息告知其他节点，以便其他节点及时发现并处理异常情况。同时，遗嘱机制还可以用于实现心跳检测等功能。

#### ⑧MQTT协议中的保留消息（retain message）是什么？它有什么作用？

MQTT协议中的保留消息（Retained Message）是指发送到MQTT服务器上的一个消息，它会被持久化保存并保留在服务器中，直到被更新或者被删除。保留消息和非保留消息不同，当客户端订阅一个主题时，如果存在该主题的保留消息，则会将该保留消息发送给订阅的客户端。

保留消息的作用在于：在某些场景下，需要发送一些与当前状态相关的信息，但是消息的发布者无法确定是否有订阅者在线或者当前订阅者是否已经接收到这个消息。例如，设备上线时可以发布一条保留消息，表示设备已经上线；当设备离线时，可以发布一条保留消息表示设备已经下线。这些消息会一直被保留在服务器中，当客户端重新连接时，可以收到相应的消息，以便及时处理设备状态的变化。

同时，保留消息还可以用于历史消息的查看。当客户端订阅一个主题时，如果存在该主题的保留消息，则会将该保留消息发送给订阅的客户端，这样客户端就可以获取到历史消息。

需要注意的是，保留消息的使用需要谨慎。如果保留消息的更新频率过高，可能会导致服务器存储空间的快速耗尽。因此，建议在合适的时机更新或删除保留消息，以避免服务器资源的浪费。

#### ⑨MQTT协议支持的安全机制有哪些？例如，TLS/SSL等。

MQTT协议支持的安全机制有：

TLS/SSL：Transport Layer Security/Secure Sockets Layer是一种加密通信协议，可在客户端和服务器之间提供端到端的数据传输加密和身份验证。

SASL：Simple Authentication and Security Layer是一种身份验证协议，可提供安全的身份验证机制，包括PLAIN，DIGEST-MD5，CRAM-MD5等。

IPsec：Internet Protocol Security是一种网络层协议，可提供网络层加密和身份验证，可保护IP数据报的完整性、机密性和身份验证。

这些安全机制可用于保护MQTT通信中传输的数据和身份验证。使用这些机制，可以有效地防止未经授权的访问和数据泄露，确保MQTT通信的机密性、完整性和可用性。

#### ⑩MQTT协议应用场景有哪些？例如，物联网、移动通信等。

MQTT协议作为一种轻量级、灵活的通信协议，适用于以下应用场景：

物联网（IoT）：MQTT协议被广泛应用于物联网中，可以用于传感器、设备之间的通信，以及与云端的连接和通信。

移动通信：MQTT协议可用于移动设备之间的通信，例如，应用程序可以使用MQTT协议进行即时通信和数据同步。

实时监测和控制系统：MQTT协议的快速响应和可靠性使其成为监测和控制系统的理想选择，例如，家庭自动化、智能城市等。

消息队列：MQTT协议支持发布/订阅模式，因此可以用于构建可靠的消息队列系统，例如，电子邮件、即时消息等。

大规模传感器网络：MQTT协议支持低功耗设备，因此可以用于大规模传感器网络，例如，环境监测、交通监测等。

资源受限的设备：MQTT协议的轻量级和简单性使其适用于资源受限的设备，例如，嵌入式设备、传感器等。





### (3)UART

#### ①UART协议是什么，它的作用是什么？

UART（Universal Asynchronous Receiver/Transmitter）协议是一种异步串行通信协议，它是通过两根线（TX和RX）实现数据的双向传输。UART协议常用于芯片与芯片、芯片与外设之间的通信，例如单片机与电脑、蓝牙模块、GPS模块等。

UART协议的作用是实现异步串行数据传输，即在没有时钟同步信号的情况下，通过双方约定好的波特率进行数据传输。UART协议通常用于传输少量数据，如传输控制信息、传感器数据等。与SPI和I2C等其他通信协议相比，UART协议具有简单、易用、成本低等优点。

#### ②UART协议的数据传输原理是什么？

UART（通用异步收发传输器）协议采用异步串行传输方式，将数据按照一定的时间间隔逐位传输。UART协议传输时采用“帧”的概念，每个帧由起始位、数据位、校验位和停止位组成，常用的数据位有7位和8位，校验位可选，一般为奇偶校验和无校验两种形式，停止位一般为1位。

在UART通信过程中，数据以二进制位的形式进行传输。发送端在每个数据帧的开始位置发送起始位，接收端接收到起始位后，开始按照数据位的个数读取数据，如果需要校验，则接收端会在数据位的末尾读取校验位。当接收端读取完数据后，会等待一个停止位的时间，告诉发送端一个数据帧已经传输完毕。发送端在发送完数据后，也需要等待一个停止位的时间，以便接收端准确的读取下一个数据帧。

因为UART协议采用异步传输方式，数据没有时钟信号同步，所以在传输过程中，发送端和接收端的波特率必须一致，否则会导致数据传输错误。

#### ③UART协议中的波特率是什么，如何计算波特率？

UART协议中的波特率（Baud Rate）是指每秒钟传输的比特数，也就是数据传输速率。在UART通信中，波特率是指两个设备之间传输数据的速度，它决定了UART的数据传输速率和传输距离。波特率的单位是bps（bits per second），即每秒传输的比特数。

波特率的计算公式如下：

波特率 = 时钟频率 / (分频系数 × (16 + 分频器值))

其中，时钟频率指的是UART时钟的工作频率，分频系数用于分频，可以设置为1、8、64、256或1024，分频器值是一个整数，通常在0到255之间。

例如，如果时钟频率为12MHz，分频系数为8，分频器值为51，则波特率计算公式为：

波特率 = 12MHz / (8 × (16 + 51)) ≈ 9600bps

因此，此时的波特率为9600bps。

#### ④UART协议中的数据位、停止位和校验位分别是什么，它们的作用是什么？

在UART协议中，数据位、停止位和校验位是数据帧的三个组成部分。它们的含义和作用如下：

数据位：指每个数据字节中包含的二进制位数。常见的有7位、8位等，一般情况下采用8位数据位。数据位的数量决定了每次传输的最大数据量。

停止位：指每个数据帧最后一个数据位之后的一段时间内的电平状态。常见的有1个停止位、1.5个停止位和2个停止位，一般情况下采用1个停止位。停止位的作用是告诉接收端数据帧已经结束。

校验位：用于检验数据传输过程中是否出错。常见的有奇偶校验、偶偶校验和无校验等方式。校验位的作用是在数据传输过程中检验数据的正确性，以保证传输的可靠性。

在UART协议中，数据帧由数据位、停止位和校验位组成，每个数据帧的开始和结束由起始位和停止位控制。数据位、停止位和校验位的选择取决于具体应用的要求和设备的性能。

#### ⑤UART协议的数据传输有哪些常见的错误，如何检测和纠正这些错误？

UART协议的数据传输中，常见的错误包括以下几种：

奇偶校验错误：如果设置了奇偶校验位，接收端会根据数据位和奇偶校验位的状态来检查数据是否有误，如果检测到奇偶校验错误，则说明数据传输出错。
帧错误：当传输的数据帧中，起始位、数据位、奇偶校验位、停止位有任何一个不正确时，就会出现帧错误。
噪声：当传输的信号中存在噪声时，会干扰信号的正确接收和解码，从而导致数据出错。
数据丢失：当数据传输速率过快时，接收端可能无法及时处理和接收数据，导致数据丢失。

为了检测和纠正这些错误，通常需要在UART协议的接收端进行数据校验和纠错，常见的方法包括：

奇偶校验：通过奇偶校验位来检查数据的正确性，如果校验结果不正确，说明数据传输出错。
校验和：对数据进行加和计算，得到一个校验和，接收端通过计算校验和来检查数据的正确性。
CRC校验：通过循环冗余校验（CRC）算法来计算数据的校验值，接收端通过比对校验值来检查数据的正确性。
重传机制：当发现数据传输出错时，通常会要求发送端重新发送数据，以确保数据的正确传输。

在UART协议的实现中，通常需要根据具体的应用场景和数据传输要求，选择合适的校验和纠错方式来保证数据传输的正确性和可靠性。

#### ⑥UART协议在实际应用中需要注意哪些问题，如数据丢失、传输错误等？

在实际应用中，使用UART协议进行通信时需要注意以下问题：

数据丢失：UART通信可能会出现数据丢失的情况，通常可以通过增加接收缓冲区的大小、提高接收中断的优先级等方式来避免。

噪声干扰：UART通信可能会受到来自外界的噪声干扰，通常可以通过加强电路的屏蔽、增加抗干扰电容等方式来提高抗干扰能力。

数据错误：UART通信可能会出现数据传输错误的情况，通常可以通过添加校验位、加强校验算法等方式来保证数据传输的正确性。

传输速率不一致：在实际应用中，可能会出现通信双方的传输速率不一致的情况，通常可以通过使用更高的波特率来提高传输速率，或者通过调整系统时钟频率等方式来协调通信双方的传输速率。

数据长度不一致：在实际应用中，可能会出现通信双方的数据长度不一致的情况，通常可以通过使用固定长度的数据帧或者使用起始和结束标记来解决。

数据格式不一致：在实际应用中，可能会出现通信双方的数据格式不一致的情况，通常可以通过使用协议规定的数据格式或者协商统一的数据格式来解决。

传输距离限制：UART通信的传输距离一般较短，通常在几米以内，如果需要传输距离较远的数据，需要使用信号转换器或者其他更适合的通信协议。

#### ⑦UART协议与其他串行通信协议（如SPI、I2C）的区别是什么？

UART、SPI和I2C都是常用的串行通信协议，它们有以下区别：

总线类型：UART是一种点对点通信协议，SPI和I2C是多点通信协议。

硬件连接：UART只需要两根线（TX和RX），SPI需要4根线（MOSI、MISO、SCLK、SS），I2C需要2根线（SDA、SCL）。

数据传输方式：UART是异步传输，SPI和I2C是同步传输。

传输速度：UART的最高传输速率比SPI和I2C都要快。

硬件成本：UART比SPI和I2C更为简单，成本更低。

应用场景：UART常用于长距离的点对点通信，SPI常用于短距离、高速率的点对点通信，I2C常用于低速率的多点通信。

当选择串行通信协议时，需要根据具体的应用场景和需求来选择最适合的协议。

#### ⑧在嵌入式系统中，UART协议如何应用于与PC机进行通信？

在嵌入式系统中，UART协议可以通过串口与PC机进行通信。常见的应用场景包括调试和数据传输等。以下是一些通信的步骤：

确定双方的串口参数，包括波特率、数据位、校验位和停止位等。

在嵌入式系统中使用相应的串口库函数进行初始化，设置串口参数并打开串口。

在PC机上使用串口调试工具，设置相同的串口参数，并打开相应的串口。

在嵌入式系统中使用串口库函数发送数据，可以是字符或二进制数据。

在PC机上使用串口调试工具接收数据，并进行相应的处理。

在嵌入式系统中使用串口库函数接收数据，并进行相应的处理。

在使用UART协议进行通信时，需要注意数据的完整性和正确性。在数据传输过程中，可能会出现数据丢失或错误的情况，需要采取相应的措施进行纠正。

#### ⑨UART协议在嵌入式系统中如何实现中断处理，有哪些需要注意的问题？

UART协议在嵌入式系统中的中断处理可以通过以下步骤实现：

开启UART中断并设置优先级：在初始化UART时，需要设置中断使能，并设置中断优先级。不同的MCU有不同的中断控制器，需要查阅相应的文档。

实现中断服务程序：当UART接收到数据后，会触发相应的中断。中断服务程序会被调用，可以在中断服务程序中读取数据、处理数据等操作。

处理接收数据：在中断服务程序中，需要注意接收数据的处理。由于UART是一个异步通信协议，数据的接收时序不确定，因此需要采用一些特殊的算法来处理接收到的数据，例如循环缓冲区。

处理发送数据：在中断服务程序中，可以通过发送数据的方式来与PC机进行通信。在发送数据时，需要注意发送缓冲区的处理，以免发送数据丢失或覆盖之前发送的数据。

在实现UART中断处理时，需要注意以下几个问题：

中断优先级的设置：在不同的MCU中，中断优先级的设置方法可能不同，需要仔细查阅相应的文档，并根据实际情况进行设置。

中断服务程序的实现：中断服务程序需要尽可能的简洁和高效，以保证数据的及时处理。过长的中断服务程序可能会导致数据的丢失或延迟。

数据的处理和存储：在处理接收数据时，需要注意数据的存储方式和处理方式，以免出现数据覆盖或错误的处理。

缓冲区的大小：缓冲区的大小需要根据实际应用情况进行设置，以保证数据的及时处理和传输。如果缓冲区过小，可能会导致数据的丢失或延迟；如果缓冲区过大，可能会导致内存浪费。

数据的校验：在UART通信中，可以通过校验位来检测数据的正确性。在实现中断处理时，需要注意校验位的处理，以保证数据的正确性和完整性。

#### ⑩UART协议在嵌入式系统中如何进行数据的缓存和处理，如何处理高速数据传输等问题？

在嵌入式系统中，UART协议的数据缓存和处理可以采用多种方式实现。其中，常见的方式有中断缓存和DMA缓存两种。

对于中断缓存，可以设置一个缓存区，在串口接收到数据后触发中断，将接收到的数据存放到缓存区中。然后，在主程序中可以定时或者根据需要读取缓存区中的数据进行处理。

对于DMA缓存，可以利用DMA控制器进行数据传输。在UART接收到数据后，DMA控制器会自动将数据存放到指定的内存区域中。可以设置循环缓存，实现高速数据传输。

在处理高速数据传输时，需要考虑数据传输的稳定性和速度。为了提高数据传输的稳定性，可以采用硬件流控制，例如CTS/RTS流控制，控制数据传输的速率。同时，为了提高数据传输的速度，可以采用DMA方式进行数据传输，提高传输效率。



### (4)SPI

#### ①你是否使用过SPI协议？请谈谈你在使用SPI协议方面的经验。

我使用过SPI协议，我曾经使用过SPI接口连接微控制器和传感器，并编写相应的代码来进行数据收发和处理。

#### ②SPI、I2C、UART三者对比？

SPI、I2C和UART是嵌入式系统中常见的串行通信协议。下面是这三种协议的对比表格：

| 协议名称       | SPI                                                          | IIC                                                          | UART                           |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------ |
| 传输方式       | 全双工与半双工两种模式                                       | 半双工                                                       | 单工                           |
| 传输模式       | 4种模式                                                      | 1种模式                                                      | 无                             |
| 通信线路数     | 4线制，从机最多4根线，SCK、MOSI、MISO、SS/CS                 | 2线制，SDA、SCL两根线                                        | 2线制，TXD、RXD两根线          |
| 通信方式       | 同步                                                         | 同步                                                         | 异步                           |
| 传输速率       | 高速                                                         | 中等                                                         | 较慢                           |
| 设备地址       | 无                                                           | 有，且唯一                                                   | 无                             |
| 支持设备数量   | 少，一主多从                                                 | 多                                                           | 一对一                         |
| 主设备控制方式 | 主设备负责数据传输顺序和时序                                 | 主设备负责时序，从设备响应主设备指令                         | 主设备发送数据，从设备接收数据 |
| 从设备响应方式 | 从设备被动响应主设备请求                                     | 从设备被动响应主设备指令                                     | 从设备无法主动响应主设备请求   |
| 时序           | 时钟极性、时钟相位                                           | SCL时序                                                      | 无                             |
| 硬件成本       | 中等                                                         | 低                                                           | 低                             |
| 软件开发难度   | 中等                                                         | 低                                                           | 低                             |
| 应用场景       | 高速、短距离，常用于芯片间通信<br />SPI是一种事实标准，由Motorola开发，并没有一个官方标准。已知的有的器件SPI已达到50Mbps。 | 低中速、中短距离，常用于模拟器件间通信<br />I2C协议v2.1规定了100K，400K和3.4M三种速率(bps) | 短距离、低速，常用于串口通信   |



**三者协议的GPIO口配置模式：**

SPI端口配置：

| 端口名称  | 功能       | 推荐配置           |
| --------- | ---------- | ------------------ |
| SCK、SCLK | 时钟       | 推挽输出，速度较快 |
| MOSI      | 主设备输出 | 推挽输出，速度较快 |
| MISO      | 主设备输入 | 上拉输入           |
| SS/CS     | 从设备片选 | 推挽输出，速度较快 |


I2C端口配置：

| 端口名称 | 功能   | 推荐配置           |
| -------- | ------ | ------------------ |
| SCL      | 时钟   | 开漏输出，上拉电阻 |
| SDA      | 数据线 | 开漏输出，上拉电阻 |

UART端口配置：

| 端口名称 | 功能     | 推荐配置           |
| -------- | -------- | ------------------ |
| TXD      | 发送数据 | 推挽输出，速度较快 |
| RXD      | 接收数据 | 上拉输入           |



**下面是各协议的优缺点简述：**

| 协议     | 优点                                 | 缺点                                 |
| -------- | ------------------------------------ | ------------------------------------ |
| SPI协议  | 高速数据传输、少量通信线路、易于实现 | 受限于通信距离、不提供校验和纠错机制 |
| IIC协议  | 支持多个设备、数据线路少、硬件成本低 | 速率较低、传输距离短                 |
| UART协议 | 简单易用、成本低、应用广泛           | 单向通信、传输速率低                 |



#### ③请解释一下SPI协议中的“主设备”和“从设备”的概念，并说明它们之间的通信方式。

SPI（Serial Peripheral Interface）是一种同步串行通信协议，它支持单主设备与一个或多个从设备之间的全双工通信。在SPI通信中，主设备和从设备之间通过一条时钟线和多条数据线进行通信。

主设备是SPI通信中的主导者，它控制着通信的时序和数据流。主设备通过片选信号选择特定的从设备进行通信，并向从设备发送数据，从设备接收数据后进行响应或返回数据。主设备也负责将数据从一个从设备传输到另一个从设备。

从设备是SPI通信中的被动者，它在收到主设备的片选信号后才开始响应主设备的请求。从设备只能响应主设备发来的请求，无法主动发起通信。从设备通过数据线接收主设备发送的数据，同时也会向主设备发送数据或响应。

SPI通信中，主设备和从设备的通信方式是全双工的，即主设备和从设备可以同时进行发送和接收操作。主设备通过时钟信号控制数据的传输时序，每一个时钟周期都会传输一个数据位。主设备和从设备之间的通信是基于时钟极性和时钟相位的，通过这两个参数的配置，可以确定通信时序和数据采样时机。

#### ④在SPI协议中，时钟极性和时钟相位分别是什么意思？为什么需要它们？

时钟极性定义了时钟信号在空闲状态下的电平，时钟相位定义了时钟信号的边沿。

在SPI协议中，时钟极性和时钟相位是用于定义时钟信号的两个参数。时钟信号是用来同步主设备和从设备的数据传输的。

时钟极性定义了在一个传输周期内时钟信号的起始电平，可以是低电平（CPOL=0）或高电平（CPOL=1）。

时钟相位定义了在一个传输周期内数据采样的时间点，可以是时钟信号的上升沿（CPHA=0）或下降沿（CPHA=1）。

时钟极性和时钟相位的不同组合可以定义出四种SPI模式：模式0、模式1、模式2和模式3。

- 在模式0中，时钟极性为0，时钟相位为1；

- 在模式1中，时钟极性为0，时钟相位为0；

- 在模式2中，时钟极性为1，时钟相位为1；

- 在模式3中，时钟极性为1，时钟相位为0。

选择适当的时钟极性和时钟相位组合可以使得SPI通信更加稳定和可靠，避免出现数据传输错误。

#### ⑤如何配置SPI协议的时钟速率？在哪些情况下需要更改时钟速率？

回答：SPI协议的时钟速率可以通过设置时钟分频系数来实现。需要更改时钟速率的情况包括：需要提高数据传输速率时、传输距离较长时、或者需要降低功耗时。

#### ⑥在使用SPI协议进行通信时，如何处理多个从设备？请解释“片选线”在SPI协议中的作用。

在SPI协议中，可以通过片选信号（Chip Select，CS）来选择要与之通信的从设备。SPI总线上可以有多个从设备，每个从设备都有自己的片选信号。当主设备需要与某个从设备进行通信时，它会拉低对应的片选信号，让该从设备处于通信模式。在通信完成后，主设备会将片选信号拉高，让该从设备进入待机模式，等待下一次通信。

片选信号的作用是将SPI总线上的多个从设备区分开来，从而避免多个从设备同时响应主设备的请求，导致数据冲突和混乱。当主设备需要与某个从设备通信时，只有该从设备的片选信号被拉低，其他从设备的片选信号都应该保持高电平，以确保通信数据只传输给所选择的从设备。

在使用多个从设备的情况下，为了避免片选信号的冲突，可以使用串行编码器或者分配器来对片选信号进行处理。串行编码器可以将多个片选信号编码成一个串行信号输出，而分配器则可以将一个片选信号分配给多个从设备，通过将其余从设备的片选信号保持高电平的方式，来避免冲突。

#### ⑦在SPI协议中，如何保证通信的可靠性和完整性？是否需要进行校验和纠错？

SPI协议本身不提供数据校验和纠错机制，因此需要在应用层进行必要的校验和纠错。可采用CRC校验、重传机制等方式来保证通信的可靠性和完整性。

#### ⑧在使用SPI协议进行通信时，主设备和从设备的时序要求是什么？有哪些常见的SPI模式？

主设备和从设备需要按照一定的时序进行数据传输和接收。

常见的SPI模式有四种：模式0、模式1、模式2和模式3。其中，时钟极性和时钟相位的不同组合定义了不同的SPI模式。

#### ⑨在使用SPI协议进行通信时，主设备和从设备之间有哪些可能的错误情况？如何进行错误处理？

主设备和从设备之间可能出现的错误情况包括：数据传输错误、通信超时、设备忙等。可以采用超时机制、重传机制等方式来进行错误处理。

#### ⑩请谈谈你对SPI协议的应用场景和优缺点的理解。

SPI协议通常用于微控制器和外部设备之间的短距离高速数据传输，如传感器、显示器、存储器等。

SPI协议具有高速数据传输、少量通信线路、易于实现等优点，但是受限于通信距离、不提供校验和纠错机制等缺点。

SPI（Serial Peripheral Interface）协议是一种高速、全双工、同步的串行通信协议，主要用于在微处理器和外围设备之间进行通信。**它的应用场景非常广泛**，例如：

- 存储器控制：SPI协议可用于控制各种类型的存储器设备，如EEPROM、Flash存储器、SRAM等。

- 传感器控制：SPI协议可用于连接各种类型的传感器，如加速度计、陀螺仪、磁力计等。

- 显示屏控制：SPI协议可用于控制各种类型的显示屏设备，如OLED屏幕、LCD屏幕等。

- 通信接口：SPI协议可用于实现微处理器之间的通信接口，例如连接多个微处理器进行数据传输和通信。

**SPI协议的优点主要包括：**

- 传输速度快：SPI协议采用全双工模式和同步传输，数据传输速度可以达到几十MHz甚至上百MHz。

- 传输距离远：SPI协议使用差分信号传输，具有抗干扰能力强、传输距离远的特点。

- 通信灵活：SPI协议支持多主从设备，通过片选信号可以选择不同的从设备进行通信。

- 实现简单：SPI协议通信方式简单，硬件和软件的实现都相对简单。

**SPI协议的缺点主要包括：**

- 使用的线路多：SPI协议需要使用多根线路进行通信，占用了较多的引脚资源。

- 信号缺乏标识：SPI协议中没有标识信息的概念，因此需要使用其他手段进行设备识别和通信协议的协商。

- 不支持多主并行通信：SPI协议只支持单主多从或多主单从的通信方式，不支持多主并行通信。



## 6.FreeRTOS：

### (1)内存管理：

堆：heap，就是一块空闲的内存，需要提供管理函数；

- malloc：从堆里划出一块空间给程序使用；
- free：用完后，再把它标记为"空闲"的，可以再次使用；

栈：stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中

从堆中分配一块空间用作栈；



FreeRTOS中内存管理的接口函数为：`pvPortMalloc`、`vPortFree` 

| 文件     | 优点                           | 缺点                                         |
| -------- | ------------------------------ | -------------------------------------------- |
| heap_1.c | 分配简单，时间确定             | 无法删除内核空间，也就是说没办法使用动态内存 |
| heap_2.c | 动态分配、最佳匹配             | best fit 导致内存碎片化问题                  |
| heap_3.c | 调用标准库函数，安全           | 效率不高                                     |
| heap_4.c | 相邻空闲内存可合并             |                                              |
| heap_5.c | 在heap_4基础上支持分隔的内存块 |                                              |

**Heap_1.c**

只实现了`pvPortMalloc`，没有实现`vPortFree`

如果程序不需要删除内核对象，那么可以使用heap_1：

- 实现简单
- 没有碎片问题
- 在某些不允许使用动态内存的系统里，可以使用heap_1

定义一个大数组：

```c
/* Allocate the memory for the heap. */
#if ( configAPPLICATION_ALLOCATED_HEAP == 1 )

/* The application writer has already defined the array used for the RTOS
* heap - probably so it can be placed in a special segment or address. */
    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#else
    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
#endif /* configAPPLICATION_ALLOCATED_HEAP */
```



`pvPortMalloc`调用时，从数组分配空间

FreeRTOS在创建任务时，需要两个内核对象：`TCB（task control block）`、`stack`

![image-20210728154645642](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/02_heap_1.png)

**Heap_2.c**

新设计中不再推荐使用Heap_2，而是推荐使用Heap_4.c来代替Heap_2.c。更加高效。

Heap_2.c也是在数组上分配内存，但是跟Heap_1.c不同的是：

- Heap_2.c使用最佳匹配算法（best fit）来分配内存；
- 它支持vPortFree

但是Heap_2.c会导致严重的碎片化问题：



最佳匹配算法：

- 假设heap有3块空闲内存：5字节、25字节、100字节
- pvPortMalloc想申请20字节
- 找出最小的、能满足pvPortMalloc的内存：25字节
- 把它划分为20字节、5字节
  - 返回这20字节的地址
  - 剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用



Heap_2.c的效率远高于malloc、free

![image-20210728161556536](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/03_heap_2.png)

**Heap_3.c**

Heap_3使用标准C库里的malloc、free函数，所以堆大小由链接器的配置决定，配置项configTOTAL_HEAP_SIZE不再起作用。

C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。

**Heap_4.c**

和Heap_1.c与Heap_2.c一样，使用大数组来分配内存。

Heap_4.c使用首次适应算法（first fit）来分配内存，还会将相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片空间。

适用于频繁地分配、释放不同大小的内存

Heap_4.c执行的时间是不确定的，但是效率高于标准库的malloc、free。

首次适应算法：

- 假设堆中有3块空闲内存：5字节、200字节、100字节
- pvPortMalloc想申请20字节
- 找出第1个能满足pvPortMalloc的内存：200字节
- 把它划分为20字节、180字节
  - 返回这20字节的地址
  - 剩下的180字节仍然是空闲状态，留给后续的pvPortMalloc使用



![image-20210728180440125](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/04_heap_4.png)

**Heap_5.c**

Heap_5.c在分配内存、释放内存的算法跟Heap_4是一样的。

但是Heap_5.c并不局限于管理一个大数组：它可以管理多块、分隔开的内存

嵌入式系统中，内存的地址可能并不连续，这种场景下就可以使用Heap_5.c

既然内存是分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：

- 在使用pvPortMalloc之前，必须先指定内存块的信息
- 使用vPortDefineHeapRegions来指定这些信息

怎么指定一块内存？使用如下结构体：

```
typedef struct HeapRegion
{
    uint8_t * pucStartAddress; // 起始地址
    size_t xSizeInBytes;       // 大小
} HeapRegion_t;
```

怎么指定多块内存？使用一个HeapRegion_t数组，在这个数组中，低地址在前、高地址在后。

比如：

```
HeapRegion_t xHeapRegions[] =
{
  { ( uint8_t * ) 0x80000000UL, 0x10000 }, // 起始地址0x80000000，大小0x10000
  { ( uint8_t * ) 0x90000000UL, 0xa0000 }, // 起始地址0x90000000，大小0xa0000
  { NULL, 0 } // 表示数组结束
 };
```

vPortDefineHeapRegions函数原型如下：

```
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );
```

把xHeapRegions数组传给vPortDefineHeapRegions函数，即可初始化Heap_5。



**Heap相关函数：**

`pvPortMalloc/vPortFree`

```c
void * pvPortMalloc( size_t xWantedSize );	// 分配内存，如果分配内存不成功，则返回值为NULL。
void vPortFree( void * pv );	// 释放内存
```

`xPortGetFreeHeapSize`

```c
size_t xPortGetFreeHeapSize( void );
```

当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。

Heap_3.c中无法使用。

`xPortGetMinimumEverFreeHeapSize`

```c
size_t xPortGetMinimumEverFreeHeapSize( void );
```

返回：程序运行过程中，空闲内存容量的最小值。

注意：只有heap_4、heap_5支持此函数。



==malloc失败的钩子函数==

在pvPortMalloc函数内部：

```
void * pvPortMalloc( size_t xWantedSize )
{
    ......
    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
            }
        }
    #endif
    
    return pvReturn;        
}
```

所以，如果想使用这个钩子函数：

- 在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1
- 提供vApplicationMallocFailedHook函数
- pvPortMalloc失败时，才会调用此函数

### (2)任务管理：

任务也可称作为线程

task——thread

任务就是函数，此函数不能返回，并且可以被多个任务运行，不同任务的局部变量有自己的副本

**创建任务：**

```c
BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数
                        const char * const pcName, // 任务的名字
                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节
                        void * const pvParameters, // 调用任务函数时传入的参数
                        UBaseType_t uxPriority,    // 优先级
                        TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务
```





| 参数          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| pvTaskCode    | 函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用"vTaskDelete(NULL)" |
| pcName        | 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN |
| usStackDepth  | 每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。 |
| pvParameters  | 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)       |
| uxPriority    | 优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1) |
| pxCreatedTask | 用来保存xTaskCreate的输出结果：task handle。 以后如果想操作这个任务，比如修改它的优先级，就需要这个handle。 如果不想使用该handle，可以传入NULL。 |
| 返回值        | 成功：pdPASS； 失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足) 注意：文档里都说失败时返回值是pdFAIL，这不对。 pdFAIL是0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY是-1。 |

**删除任务：**

```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

参数说明：

| 参数       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| pvTaskCode | 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。 |

怎么删除任务？举个不好的例子：

- 自杀：`vTaskDelete(NULL)`
- 被杀：别的任务执行`vTaskDelete(pvTaskCode)`，pvTaskCode是自己的句柄
- 杀人：执行`vTaskDelete(pvTaskCode)`，pvTaskCode是别的任务的句柄

**任务优先级：**

优先级的取值范围是：0~（configMAX_PRIORITIES -1），数值越大优先级越高。

FreeRTOS的调度器有两种方法来快速找出优先级最高、可以运行的任务。并且不同的方法，configMAX_PRIORITIES的取值有所不同。

- 通用方法 使用C函数实现，对所有的架构都是同样的代码。对configMAX_PRIORITIES的取值没有限制。但是configMAX_PRIORITIES的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为0、或者未定义时，使用此方法。
- 架构相关的优化的方法 架构相关的汇编指令，可以从一个32位的数里快速地找出为1的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。 使用这种方法时，configMAX_PRIORITIES的取值不能超过32。 configUSE_PORT_OPTIMISED_TASK_SELECTION被定义为1时，使用此方法。



使用uxTaskPriorityGet来获得任务的优先级：

```c
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );
```

使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。

使用vTaskPrioritySet 来设置任务的优先级：

```c
void vTaskPrioritySet( TaskHandle_t xTask,
                       UBaseType_t uxNewPriority );
```

使用参数xTask来指定任务，设置为NULL表示设置自己的优先级； 参数uxNewPriority表示新的优先级，取值范围是0~(configMAX_PRIORITIES – 1)。



**Tick：**

两次时钟中断之间的时间被称为时间片（time slice、tick period），由参数`configTICK_RATE_HZ`决定，假设`configTICK_RATE_HZ`为100，那么时间片长度就是10ms。就是100Hz，就是10ms

基于Tick实现的延时并不精确，如`vTaskDelay(2)`本意是延迟2个Tick周期，有可能经过1个Tick多一点就返回了。

**任务状态：**

- 阻塞状态（Blocked）
- 暂停状态（Suspended）
- 就绪状态（Ready）

**阻塞状态（Blocked）**

在阻塞状态下的任务，可以等待两种类型的事件：

- 时间相关的事件；
- 同步事件

**暂停状态（Suspended）**

FreeRTOS中的任务也可以进入暂停状态，唯一的方法是通过vTaskSuspend函数。函数原型如下：

```
void vTaskSuspend( TaskHandle_t xTaskToSuspend );
```

参数xTaskToSuspend表示要暂停的任务，如果为NULL，表示暂停自己。

要退出暂停状态，只能由**别人**来操作：

- 别的任务调用：vTaskResume
- 中断程序调用：xTaskResumeFromISR

实际开发中，暂停状态用得不多。

**就绪状态（Ready）**

![image-20210731155223985](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/13_full_task_state_machine.png)



**Delay函数：**

- `vTaskDelay`：至少等待指定个数的Tick Interrupt才能变为就绪状态；
- `vTaskDelayUntil`：等待到指定的绝对时刻，才能变为就绪态；
- `osKernelGetTickCount`:获取当前准确的Tick计时

```c
void vTaskDelay( const TickType_t xTicksToDelay ); /* xTicksToDelay: 等待多少给Tick */
//void vTaskDelay(xDelay5ms);

BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                            const TickType_t xTimeIncrement );
/* pxPreviousWakeTime: 上一次被唤醒的时间
 * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)
 * 单位都是Tick Count
 */
```

![image-20210731233309265](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/16_delay_time.png)

**任务调度算法：**

通过配置文件`FreeRTOSConfig.h`的两个配置项来配置调度算法：`configUSE_PREEMPTION`、`configUSE_TIME_SLICING`。

还有第三个配置项：`configUSE_TICKLESS_IDLE`，它是一个高级选项，用于关闭Tick中断来实现省电。

`configUSE_PREEMPTION`：

是否可以抢占？高优先级的任务是否优先执行？

- 可以：被称作"可抢占调度"(Pre-emptive)，高优先级的就绪任务马上执行，下面再细化。
- 不可以：不能抢就只能协商了，被称作"合作调度模式"(Co-operative Scheduling)
  - 当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出CPU资源。
  - 其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点



`configUSE_TIME_SLICING`：

在可抢占的前提下，同优先级的任务是否轮流执行？

- 轮流执行：被称为"时间片轮转"(Time Slicing)，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片
- 不轮流执行：英文为"without Time Slicing"，当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占



`configIDLE_SHOULD_YIELD`：

在可抢占+时间片轮转的前提下，空闲任务是否让步于用户任务？

- 空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务
- 空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊



|         配置项          |  A   |   B    |   C    |   D    |    E     |
| :---------------------: | :--: | :----: | :----: | :----: | :------: |
|  configUSE_PREEMPTION   |  1   |   1    |   1    |   1    |    0     |
| configUSE_TIME_SLICING  |  1   |   1    |   0    |   0    |    x     |
| configIDLE_SHOULD_YIELD |  1   |   0    |   1    |   0    |    x     |
|          说明           | 常用 | 很少用 | 很少用 | 很少用 | 几乎不用 |

注：

- A：可抢占+时间片轮转+空闲任务让步
- B：可抢占+时间片轮转+空闲任务不让步
- C：可抢占+非时间片轮转+空闲任务让步
- D：可抢占+非时间片轮转+空闲任务不让步
- E：合作调度



### (3)同步互斥与通信：

"用同步实现互斥"

能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphore)、互斥量(mutex)。

| 内核对象 |  生产者   | 消费者 |                          数据/状态                           |                             说明                             |
| :------: | :-------: | :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   队列   |    ALL    |  ALL   | 数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据 | 用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者 |
|  事件组  |    ALL    |  ALL   | 多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位 | 用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播 |
|  信号量  |    ALL    |  ALL   |     数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量      | 用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者 |
| 任务通知 |    ALL    | 只有我 |    数据、状态都可以传输， 使用任务通知时， 必须指定接受者    |       N对1的关系： 发送者无限制， 接收者只能是这个任务       |
|  互斥量  | 只能A开锁 | A上锁  |        位：0、1 我上锁：1变为0， 只能由我开锁：0变为1        |        就像一个空厕所， 谁使用谁上锁， 也只能由他开锁        |





![image-20210802182212569](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_compare_sync_objects.png)



### (4)队列：

队列的简化操如入下图所示，从此图可知：

- 队列可以包含若干个数据：队列中有若干项，这被称为"长度"(length)
- 每个数据大小固定
- 创建队列时就要指定长度、数据大小
- 数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读
- 也可以强制写队列头部：覆盖头部数据



### (5)信号量：

传递状态，更节省内存，信号量（semaphore）

- 当"量"没有限制时，它就是"计数型信号量"(Counting Semaphores)
- 当"量"只有0、1两个取值时，它就是"二进制信号量"(Binary Semaphores)

互斥量是信号量初值取0时的二进制信号量

|                             队列                             |                            信号量                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间 | 只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体 |
|              生产者：没有空间存入数据时可以阻塞              |       生产者：用于不阻塞，计数值已经达到最大时返回失败       |
|                  消费者：没有数据时可以阻塞                  |                  消费者：没有资源时可以阻塞                  |









### (6)互斥量：

互斥量（mutex）



谁上锁，就由谁开锁。

**优先级翻转：**

假设任务A、B都想使用串口，A优先级比较低：

- 任务A获得了串口的互斥量
- 任务B也想使用串口，它将会阻塞、等待A释放互斥量
- 高优先级的任务，被低优先级的任务延迟，这被称为"优先级反转"(priority inversion)

互斥量可以通过"优先级继承"，可以很大程度解决"优先级反转"的问题。

**优先级继承：**



**递归锁：**

递归锁（Recursive Mutexes）

- 任务A获得递归锁M后，它还可以多次去获得这个锁
- "take"了N次，要"give"N次，这个锁才会被释放

|      | 递归锁                         | 一般互斥量            |
| ---- | ------------------------------ | --------------------- |
| 创建 | xSemaphoreCreateRecursiveMutex | xSemaphoreCreateMutex |
| 获得 | xSemaphoreTakeRecursive        | xSemaphoreTake        |
| 释放 | xSemaphoreGiveRecursive        | xSemaphoreGive        |





### (7)事件组：

事件组可以简单地认为就是一个整数：

- 每一位表示一个事件；
- 每一位的事件的含义由程序员决定；
- 1表示事件发生了，0表示没有发生；
- 可以等待一位或者多位；

事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？

- 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件
- 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件
- configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑
  - 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位
  - 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位



**创建：**

使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。

动态分配内存、静态分配内存

```c
/* 创建一个事件组，返回它的句柄。
 * 此函数内部会分配事件组结构体 
 * 返回值: 返回句柄，非NULL表示成功
 */
EventGroupHandle_t xEventGroupCreate( void );

/* 创建一个事件组，返回它的句柄。
 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针
 * 返回值: 返回句柄，非NULL表示成功
 */
EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );
```



**删除：**

对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。

删除事件组：

```c
/*
 * xEventGroup: 事件组句柄，你要删除哪个事件组
 */
void vEventGroupDelete( EventGroupHandle_t xEventGroup )
```



**设置事件：**

可以设置事件组的某个位、某些位：

- 在任务中使用`xEventGroupSetBits()`
- 在ISR中使用`xEventGroupSetBitsFromISR()`

```c
/* 设置事件组中的位
 * xEventGroup: 哪个事件组
 * uxBitsToSet: 设置哪些位? 
 *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)
 */
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                    const EventBits_t uxBitsToSet );


/* 设置事件组中的位
 * xEventGroup: 哪个事件组
 * uxBitsToSet: 设置哪些位? 
 *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
 *               可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有
 * 返回值: pdPASS-成功, pdFALSE-失败
 */
BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
									  const EventBits_t uxBitsToSet,
									  BaseType_t * pxHigherPriorityTaskWoken );
```



**等待事件：**

使用`xEventGroupWaitBits`来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。

函数原型如下：

```c
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait );
```

先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫"unblock condition"，非阻塞条件，或称为"非阻塞条件成立"；当"非阻塞条件成立"后，该任务就可以变为就绪态。

函数参数说明列表如下：

| 参数            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| xEventGroup     | 等待哪个事件组？                                             |
| uxBitsToWaitFor | 等待哪些位？哪些位要被测试？                                 |
| xWaitForAllBits | 怎么测试？是"AND"还是"OR"？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 |
| xClearOnExit    | 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 |
| xTicksToWait    | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用`pdMS_TO_TICKS()`把ms转换为Tick Count |
| 返回值          | 返回的是事件值， 如果期待的事件发生了，返回的是"非阻塞条件成立"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |









### (8)任务通知：

任务通知的优点与缺点：

优点：

- 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势；
- 更节省内存：使用其他方法都要先创建对应的结构体，使用任务通知时无需额外创建结构体；

缺点：

- 不能发送数据给ISR：ISR没有任务结构体，所以无法使用任务通知的功能给ISR发送数据；但是ISR却可以使用任务通知的功能发数据给任务；
- 数据只能给该任务独享，使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。
- 无法缓冲数据。使用队列时，假设队列深度为N，那么它可以保持N个数据。使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。
- 无法广播给多个任务。使用事件组可以同时给多个任务发送事件。使用任务通知，只能发一个任务。
- 发送受阻，会导致发送方无法进入阻塞状态等待。只能立刻返回错误。

**通知状态和通知值：**

每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：

- 一个是uint8_t类型，用来表示通知状态
- 一个是uint32_t类型，用来表示通知值

```c
typedef struct tskTaskControlBlock
{
    ......
    /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */
    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
    ......
} tskTCB;
```

通知状态有3种取值：

- taskNOT_WAITING_NOTIFICATION：任务没有在等待通知
- taskWAITING_NOTIFICATION：任务在等待通知
- taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)

```c
#define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  /* 也是初始状态 */
#define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
#define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
```

通知值可以有很多种类型：

- 计数值
- 位(类似事件组)
- 任意数值





### (9)软件定时器：



### (10)中断管理：

中断管理（Interrupt Management）

中断发生时，执行代码：

- 保存现场：保存各寄存器的值；
- 分辨中断：调用处理函数（这个函数就被称为ISR，interrupt service routine）
- 恢复现场：继续运行原任务，或者运行更高优先级的任务；

==ISR是系统内核中调用的==

FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名后缀为`FromISR`

好处如下：

- 使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，使得函数更长、更复杂、更难以测试；
- 在任务、ISR调用时所需要的参数不一样；
- 在一些处理器架构中没有办法分辨当前是处在任务中还是处在ISR中，这就需要额外添加更多、更复杂的代码；

**延迟处理：**

ISR要尽量快，否则：

- 其他低优先级的中断无法被处理：实时性无法保证
- 用户任务无法被执行：系统显得很卡顿
- 如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套

如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：

- ISR：尽快做些清理、记录工作，然后触发某个任务
- 任务：更复杂的事情放在任务中处理

这种处理方式叫"中断的延迟处理"(Deferring interrupt processing)，处理流程如下图所示：

- t1：任务1运行，任务2阻塞
- t2：发生中断，
  - 该中断的ISR函数被执行，任务1被打断
  - ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2
- t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为"deferred processing task"，中断的延迟处理任务。
- t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行

![image-20210810092418499](http://rtos.100ask.net/freeRTOS%E6%95%99%E7%A8%8B/_images/01_defer_interrupt.png)

### (11)资源管理：

**屏蔽中断**

屏蔽中断有两套宏：任务中使用、ISR中使用：

- 任务中使用：`taskENTER_CRITICA()/taskEXIT_CRITICAL()`
- ISR中使用：`taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()`

**在任务中屏蔽中断**

在任务中屏蔽中断的示例代码如下：

```
/* 在任务中，当前时刻中断是使能的
 * 执行这句代码后，屏蔽中断
 */
taskENTER_CRITICAL();

/* 访问临界资源 */

/* 重新使能中断 */
taskEXIT_CRITICAL();
```

在`taskENTER_CRITICA()/taskEXIT_CRITICAL()`之间：

- 低优先级的中断被屏蔽了：优先级低于、等于`configMAX_SYSCALL_INTERRUPT_PRIORITY`
- 高优先级的中断可以产生：优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`
  - 但是，这些中断ISR里，不允许使用FreeRTOS的API函数
- 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生

这套`taskENTER_CRITICA()/taskEXIT_CRITICAL()`宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用`taskEXIT_CRITICAL()`才会重新使能中断。

使用`taskENTER_CRITICA()/taskEXIT_CRITICAL()`来访问临界资源是很粗鲁的方法：

- 中断无法正常运行
- 任务调度无法进行
- 所以，之间的代码要尽可能快速地执行

**在ISR中屏蔽中断**

要使用含有"FROM_ISR"后缀的宏，示例代码如下：

```
void vAnInterruptServiceRoutine( void )
{
    /* 用来记录当前中断是否使能 */
    UBaseType_t uxSavedInterruptStatus;
    
    /* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的
     * 所以要记录当前状态, 后面要恢复为原先的状态
     * 执行这句代码后，屏蔽中断
     */
    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
    
    /* 访问临界资源 */

    /* 恢复中断状态 */
    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
    /* 现在，当前ISR可以被更高优先级的中断打断了 */
}
```

在`taskENTER_CRITICA_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()`之间：

- 低优先级的中断被屏蔽了：优先级低于、等于`configMAX_SYSCALL_INTERRUPT_PRIORITY`
- 高优先级的中断可以产生：优先级高于`configMAX_SYSCALL_INTERRUPT_PRIORITY`
  - 但是，这些中断ISR里，不允许使用FreeRTOS的API函数
- 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生

**暂停调度器**

如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。

如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。

使用这2个函数来暂停、恢复调度器：

```
/* 暂停调度器 */
void vTaskSuspendAll( void );

/* 恢复调度器
 * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了
 *        可以不理会这个返回值
 */
BaseType_t xTaskResumeAll( void );
```

示例代码如下：

```
vTaskSuspendScheduler();

/* 访问临界资源 */

xTaskResumeScheduler();
```

这套`vTaskSuspendScheduler()/xTaskResumeScheduler()`宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用`taskEXIT_CRITICAL()`才会重新使能中断。



- Freertos支持的任务调度方式，详细说下每种方式 
- 任务（线程）间通信方法 
- 进程和线程的区别 
- 互斥量和信号量的区别 
- 优先级翻转，如何避免优先级翻转 
- STM32任务切换为什么用PendSV 
- FreeRTOS的内存管理怎么实现的？为什么这么做？ 
- 对于临界区[数据]()的处理，使用互斥锁和自己通过条件来判断，哪样更好，为什么？ 



### (12)笔试题目：



栈溢出检测功能和：

- 该钩子函数原型是void vApplicationStackOverflowHook(TaskHandle_t xTask, signed char *pcTaskName )，且函数名称和传递的参数都不能改变；
- 如果configCHECK_FOR_STACK_OVERFLOW不为0，需要用户提供一个钩子函数，函数原型如下：void vApplicationStackOverflowHook( TaskHandle_t xTask,char * pcTaskName );
- configCHECK_FOR_STACK_OVERFLOW配置为1或2时，可以选择不同的栈溢出检测功能，其他均不能使能；
- configCHECK_FOR_STACK_OVERFLOW==1，使用堆栈溢出检测方法 1。上下文切换的时候需要保存现场，现场是保存在堆栈中的，这个时候任务堆栈使用率很可能达到最大值，方法一就是不断的检测任务堆栈指针是否指向有效空间，如果指向了无效空间的话就会调用钩子函数。 方法一的优点就是快！但是缺点就是不能检测所有的堆栈溢出。
- configCHECK_FOR_STACK_OVERFLOW==2，使用堆栈溢出检测方法 2。使用方法二的话在创建任务的时候会向任务堆栈填充一个已知的标记值，方法二会一直检测堆栈后面的几个 bytes(标记值)是否被改写，如果被改写的话就会调用堆栈溢出钩子函数，方法二也会使用方法一中的机制！方法二比方法一要慢一些，但是对用户而言还是很快的！方法二能检测到几乎所有的堆栈溢出， 但是也有一些情况检测不到，比如溢出值和标记值相同的时候。
- 增加对栈的检测机制，会增加上下文切换开销，每一次进行上下文切换都要对栈空间进行判断来确认是否发生溢出；



一些配置使用：

- configUSE_RECURSIVE_MUTEXES设置成1表示使用递归互斥量，设置成0表示不使用。

- configUSE_COUNTING_SEMAPHORES设置成1表示使用计数信号量，设置成0表示不使用。

- configUSE_MUTEXES仅仅用来配置互斥量，设置为1表示使用互斥量，设置成0表示忽略互斥量

- configUSE_TIMERS设置成1使用软件定时器，为0不使用。硬件定时器并不受控制；



- 二值信号量通常用于互斥访问或同步；

- 二值信号量没有优先级继承，而互斥信号量有优先级继承机制；
- 二进制信号量API允许设置一个阻塞时间，阻塞时间是当任务获取信号量的时候由于信号量无效从而导致任务进入阻塞态的最大时钟节拍数；
- 二值信号量本质就是只有一个队列项的队列，这个特殊队列要么是满的，要么是空的；







任务运行：

- 使用FreeRTOS时，一个实时应用可以作为一个独立的任务，每个任务都有自己的运行环境，不依赖其他任务或者RTOS调度器；
- 任何一个时间点都只能有一个任务运行，运行哪个任务由RTOS调度器决定；
- 任务不需要了解RTOS调度器的具体行为，RTOS调度器的职责是确保当一个任务开始执行的时候其上下文环境（寄存器值，堆栈内容）和任务上一次退出的时候相同；
- 每一个任务都有独立的堆栈空间；



 FreeRTOS任务切换过程是在PendSV中断服务函数完成的：

- 将最新的栈顶指针写入到当前任务的任务控制块第一个字段；
- 调用函数vTaskSwitchContext()；
- 获取新的要运行的任务的任务堆栈栈顶
- ==任务切换不会删除任务==



FreeRTOS任务特性：

- 简单；
- 没有使用限制；
- 支持抢占；
- 支持优先级；
- 每个任务都拥有堆栈导致了RAM使用量增大；
- 如果使用抢占的话的必须仔细的考虑重入的问题；











系统时钟硬件初始化函数xPortStartScheduler主要工作：

- 设置PendSV（可悬起异常）的中断优先级，为最低优先级；
- 设置滴答定时器的中断优先级，为最低优先级；
- 调用函数vPortSetupTimerInterrupt()来设置滴答定时器的定时周期，并且使能滴答定时器的中断；
- 初始化临界区嵌套计数器；
- 调用函数prvStartFirstTask()开启第一个任务；



任务调度器开启函数vTaskStartScheduler()主要工作：

- 创建空闲任务，如果使用静态内存的话使用函数xTaskCreateStatic()来创建任务，优先级为tskIDLE_PRIORITY，宏tskIDLE_PRIORITY为0，也就是说空闲任务优先级最低；
- 如果使用软件定时器的话还需要通过函数下TimerCreateTimerTask()中会打开中断；
- 关闭中断，在SVC中断服务函数vPortSVCHandler()中会打开中断；
- 变量xSchedulerRunning设置为pdTRUE，表示调度器开始运行；
- 调用函数xPortStartScheduler()来初始化跟调度器启动有关的硬件，如PendSV，滴答定时器等；



挂起任务使用函数vTaskSuspend()需要做的工作包括：

- 将任务从任务就绪列表延时列表中删除；
- 查看任务是否正在等待某个事件（如信号量、队列等），如果任务还在等待某个事件的话就将其从相应的事件列表中删除；
- 将任务添加到挂起任务列表尾，挂起任务列表为xSuspendedTaskList，所有被挂起的任务都会被放到这个列表中；
- 重新计算一下还要多长时间执行下一个任务，防止有任务的解锁时间参考了刚刚被挂起的那个任务；
- 如果刚刚挂起的任务是正在运行的任务，并且任务调度器运行正常，那么这里就需要调用portYIELD_WITHIN_API()强制进行一次任务切换；
- 挂起任务并不会删除任务，因此不需要释放内存；



FreeRTOS中，vTaskDelete删除任务函数主要工作：

- 将任务从任务就绪列表中删除；
- 释放任务的TCB和任务堆栈所占用的内存；
- 调用任务删除钩子函数；
- 强制进行一次任务切换；
- 如果是删除本身，会添加到删除列表，等待空闲任务去做后续的清理工作；
- 如果是调用来删除其他任务，则会进行直接清理，释放内存



SVC中断服务函数为xPortPendSVHandler，该函数主要工作：

- 获取pxCurrentTCB指针的存储地址；
- 获取当前任务的任务控制块的存储地址；
- 获取任务堆栈的栈顶指针；
- 打开中断；



vTaskResume()和xTaskResumeFromISR()恢复任务函数主要工作：

- 根据参数获取要恢复的任务的任务控制块；
- 调用函数taskENTER_CRITICAL()进入临界段；
- 调用函数prvTasklsTaskSuspended()判断要恢复的任务之前是否已经被挂起了，恢复的肯定是被挂起的任务，没有挂起就不用恢复；
- 将要恢复的任务从原来的列表中删除，任务被挂起之后都会放在任务挂起列表xSuspendedTaskList中；
- 将要恢复的任务添加到就绪任务列表中。



调用任务级入队函数，入队方式有：

- queueSEND_TO_BACK： 后向入队
- queueSEND_TO_FRONT： 前向入队
- queueOVERWRITE： 覆写入队。



消息队列数据读写：

- 可用FIFO或LIFO存储缓冲机制；
- 数据发送到队列中会导致数据拷贝；
- 队列不属于特定任务，任何任务都可以向队列中发送消息或者提取消息；
- 当任务尝试从一个队列中读取消息的时候可能会导致任务阻塞，从而引起任务切换。



软件定时器配置：

- \#define configUSE_TIMERS                           1                     //为1时启用软件定时器
- \#define configTIMER_TASK_PRIORITY           (configMAX_PRIORITIES-1)       //软件定时器优先级
- \#define configTIMER_QUEUE_LENGTH                 5                      //软件定时器队列长度
- \#define configTIMER_TASK_STACK_DEPTH      (configMINIMAL_STACK_SIZE*2)  //软件定时器任务堆栈大小
- \#define configGENERATE_RUN_TIME_STATS            0                      //为1时启用运行时间统计功能==（这一项不属于软件定时器配置）==



Inter-Process Communication进程间通信，简称IPC。任务访问IPC对象的等待机制：

IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。

- 直接返回结果
- 阻塞等待返回结果
- 时限等待返回结果



任务优先级配置：

- 优先级设置不包括configMAX_PRIORITIES，就是从0~（configMAX_PRIORITIES-1）

- configUSE_PORT_OPTIMISED_TASK_SELECTION 设 置 为 了 1 ， 那 么 宏configMAX_PRIORITIES 不能超过 32
- 当宏 configUSE_TIME_SLICING 定义为 1 的时候多个任务可以共用一个优先级，数量不限。
- 空闲任务的优先级为0



FreeRTOS数据结构讲解：

- Queue是任务间通信的最基础形式，也是最灵活的方式。操作系统中队列是以项item为基本单元；
- StreamBuffer允许将字节流从中断服务例程传递到任务，或从一个任务传递到另一个任务。字节流可以是任意长度，可一次写入任意数量的字节，并且也可以一次读取任意数量的字节；
- MessageBUffer每一条消息的写入增加了一个字节用来表示该条消息的长度。读取时需要一次性读出至少一条消息；



## 7.Linux

Linux驱动开发思维：

Linux启动流程

[<img src="https://s1.ax1x.com/2023/04/22/p9Ve1XR.png" alt="p9Ve1XR.png" style="zoom: 25%;" />](https://imgse.com/i/p9Ve1XR)



Linux下驱动开发直接操作寄存器不现实，一般使用各种驱动框架进行开发；驱动最终表现就是/dev/xxx文件，打开关闭读写。Linux下一切皆文件；

==设备树，一个.dts文件，此文件描述了板子的设备信息；==

分类：

- 字符设备驱动，最多的。
- 块设备驱动，sd卡，硬盘、U盘等存储相关的。
- 网络设备驱动，网卡等。



一个设备可能含有多种类型的驱动分类；

驱动就是获取外设，或者传感器数据、控制外设、数据会提交给应用程序；

Linux操作系统内核和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）；

Linux下驱动和应用是完全分开的；安全、高内聚低耦合；

==应用程序想要访问内核资源：系统调用、异常（中断）和陷入；==





Linux 中的库分为静态库和动态库两种类型，它们在编译和链接时有所不同。

静态库：

- 编译生成 .a 文件，包含了一组目标文件的归档文件（archived file）。
- 链接时将静态库中的目标文件链接到可执行文件中，生成可执行文件。
- 静态库被链接到可执行文件中，成为可执行文件的一部分，程序运行时不需要依赖静态库文件。
- 如果静态库发生了变化，需要重新编译和链接程序。

静态库的生成：

```bash
#生成静态库 libhello.a
gcc -c hello.c
ar rcs libhello.a hello.o
```


静态库的使用：



```bash
#静态库链接到可执行文件中
gcc -o hello main.c -L. -lhello
```



动态库：

- 编译生成 .so 文件，包含了一组共享目标文件（shared object）。
- 链接时将动态库的名称和程序的目标文件建立动态链接关系，生成可执行文件。
- 动态库被链接到可执行文件中，成为可执行文件的一部分，程序运行时需要动态加载动态库。
- 动态库可以被多个程序共享，如果动态库发生了变化，只需要重新编译和链接动态库，不需要重新编译和链接程序。

动态库的生成：

```bash
#生成动态库 libhello.so
gcc -shared -fPIC hello.c -o libhello.so
```




动态库的使用：



```bash
#动态库链接到可执行文件中
gcc -o hello main.c -L. -lhello
```

```bash
#运行程序
LD_LIBRARY_PATH=. ./hello
```

需要注意的是，在 Linux 系统中，动态库的文件名通常以 .so 结尾，静态库的文件名通常以 .a 结尾。在编译和链接时需要使用正确的库文件。



**ELF：**

`ELF`是一类文件类型，而不是特指某一后缀的文件。`ELF`（Executable and Linkable Format，可执行与可链接格式）文件格式，在`Linux`下主要有如下三种文件：

- **可执行文件（.out）**：`Executable File`，包含代码和数据，是可以直接运行的程序。其代码和数据都有固定的地址 （或相对于基地址的偏移 ），系统可根据这些地址信息把程序加载到内存执行。

- **可重定位文件（.o文件）**：`Relocatable File`，包含基础代码和数据，但它的代码及数据都没有指定绝对地址，因此它适合于与其他目标文件链接来创建可执行文件或者共享目标文件。

- **共享目标文件（.so）**：`Shared Object File`，也称动态库文件，包含了代码和数据，这些数据是在链接时被链接器（`ld`）和运行时动态链接器（`ld.so.l、libc.so.l、ld-linux.so.l`）使用的。

ELF文件由4部分组成，分别是ELF头（`ELF header`）、程序头表（`Program header table`）、节（`Section`）和节头表（`Section header table`）。





make dtbs 编译设备树

make modules

sync强制复制到flash去，而不是在内存

insmod xxxx.ko

装载编译好的驱动程序



==lsmod 查看驱动程序==

cat /proc/device 查看驱动程序

也可以直接 ls /dev/xxxx

==file 查看一个文件的文件格式及相关内容==

==cp拷贝文件== 

img就是系统镜像，可以烧写emmc和sd卡，不过需要改名为emmc.img或sdcard.img





## 8.Linux驱动开发

驱动流程：



- 字符驱动流程：
  - 查看原理图，数据手册，了解设备的操作方法；
  - 在内核中找到相近的驱动程序，作为模板来开发，有时要从零开始；比如iic设备，有模板就用模板。
  - 实现驱动程序的初始化，比如将内核注册这个驱动程序，
  - 设计所要实现的操作：比如open、close、read、writ等函数；
  - 实现中断服务，并不是每个设备驱动都必须的；
  - 编译驱动到内核，或作为模块动态加载，inmod操作
  - 测试驱动



**字符设备就是一个一个字节，按照字节流进行读写操作的设备**

最常见的点灯、按键、IIC、SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动



简单说一下关于你这个项目的驱动开发：

我这个项目专注于应用层面的开发，所以驱动开发是移植别人的驱动模板进行修改，所以就来讲一下驱动这一块吧。

例如iic设备的驱动，这个项目需要读取MPU6050的数据。linux下一切皆文件嘛，所以驱动程序应该要做到用户层open，cloas，read可以调用库函数来系统调用进入内核，使用sys_open()来进行具体硬件设备的读取。





好的，下面是一个在S3C2440上，使用ARM Linux环境开发iic驱动，读取MPU6050数据的大致流程：

确定需求：了解MPU6050的规格书和数据手册，确定需要使用I2C或SPI协议进行通讯，以及需要读取哪些寄存器的数据。

确定开发环境：选择适合的ARM Linux开发板和交叉编译工具链，并安装相应的驱动程序和库文件。

设计iic驱动程序的接口：根据MPU6050的通讯协议和寄存器映射，设计iic驱动程序与硬件系统之间的接口，包括初始化函数、读取函数和写入函数等。

编写iic驱动程序代码：根据iic驱动程序接口的定义，编写相应的iic驱动程序代码，包括I2C总线初始化、设备地址配置、读写数据等操作。

测试iic驱动程序：将iic驱动程序与硬件系统进行集成测试，并对驱动程序的功能进行测试和验证。可以通过i2cdetect工具检查MPU6050是否被正确识别。

设计应用程序的结构和接口：根据MPU6050数据的需求，设计应用程序的结构和接口。

编写应用程序代码：根据应用程序的结构和接口，编写应用程序的代码，包括调用iic驱动程序读取MPU6050的数据并对其进行处理和显示等操作。

测试应用程序：对应用程序进行功能测试和性能测试，并进行调试。

集成：将应用程序集成到整个系统中，并进行集成测试。

发布和维护：发布应用程序，并持续进行维护和更新，以保证应用程序的稳定性和可靠性。

需要注意的是，以上流程只是一个大致的参考，具体的实现细节和开发流程还需要根据具体的需求和环境来进行调整和优化。同时，也需要遵循良好的软件工程实践，例如模块化设计、代码重用、文档化等。



好的，下面是在S3C2440平台上，设计iic驱动程序的接口，实现读取MPU6050数据的具体步骤：

确定MPU6050的通讯协议：MPU6050的通讯协议是I2C协议。

设计iic驱动程序的接口：根据MPU6050的通讯协议和寄存器映射，设计iic驱动程序与硬件系统之间的接口。

（1）初始化函数：iic_init()函数，用于初始化I2C控制器，并设置通讯速率和从设备地址等参数。

（2）写入函数：iic_write()函数，用于向MPU6050寄存器写入数据。函数包含以下参数：


 a. 从设备地址：MPU6050的从设备地址是0x68。

 b. 寄存器地址：指向MPU6050寄存器地址的指针。

 c. 数据：要写入寄存器的数据。


（3）读取函数：iic_read()函数，用于从MPU6050寄存器读取数据。函数包含以下参数：


 a. 从设备地址：MPU6050的从设备地址是0x68。

 b. 寄存器地址：指向MPU6050寄存器地址的指针。

 c. 数据：读取到的数据存放的指针。


编写iic驱动程序代码：根据iic驱动程序接口的定义，编写iic驱动程序代码，包括初始化函数、读写函数等操作。

调试iic驱动程序：将iic驱动程序与硬件系统进行集成测试，并对驱动程序的功能进行测试和验证。

调用iic驱动程序读取MPU6050数据：调用iic驱动程序提供的读取函数，读取MPU6050数据。

以上是在S3C2440平台上，设计iic驱动程序的接口，实现读取MPU6050数据的流程和步骤。需要注意的是，具体的实现细节和步骤可能会因为硬件平台和操作系统的不同而有所不同，这里只提供了一个基本的流程和思路。



设备树（Device Tree）是一种描述硬件设备和其资源的数据结构，用于在Linux内核启动时向内核传递硬件信息，从而让内核能够正确地识别和管理硬件资源。在嵌入式开发中，设备树通常用于描述各种硬件资源，包括但不限于处理器、内存、外设等。

在实现iic驱动程序的时候，设备树也发挥了重要作用。具体来说，设备树的作用包括：

描述硬件资源：设备树可以描述系统中的各种硬件资源，包括CPU、内存、外设等，以及它们之间的连接方式和属性信息。

定义设备节点：设备树中的每个节点都可以表示一个硬件设备或者一个硬件资源，通过定义设备节点的方式，驱动程序可以在设备树中查找硬件资源，并使用相应的驱动程序进行管理。

管理设备资源：设备树可以让驱动程序更加方便地管理硬件资源，通过设备节点的信息，驱动程序可以直接访问硬件资源的属性和寄存器，从而实现对硬件的控制和管理。

在iic驱动程序中，设备树可以定义iic控制器和iic设备的节点，以及它们之间的连接关系和属性信息。驱动程序可以在设备树中查找相应的节点，并使用相应的驱动程序进行初始化和管理，从而实现对iic控制器和iic设备的访问和控制。



驱动开发基本流程：

LED驱动程序

| 驱动源代码所在目录              | **/opt/FriendlyARM/mini2440/linux-2.6.32.2/drivers/char** |
| ------------------------------- | --------------------------------------------------------- |
| 驱动程序名称                    | mini2440_leds.c                                           |
| 设备类型                        | misc                                                      |
| 设备名                          | /dev/leds                                                 |
| 测试程序源代码目录              | **/opt/FriendlyARM/mini2440/examples/leds**               |
| 测试程序名称                    | led.c                                                     |
| 测试程序可执行文件名称          | led                                                       |
| led驱动已经被编译到了缺省内核中 | 不需要再使用`insmod`                                      |



```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
    int on;
    int led_no;
    int fd;
    /* 检查 led 控制的两个参数，如果没有参数输入则退出。*/
    if (argc != 3 || sscanf(argv[1], "%d", &led_no) != 1 || sscanf(argv[2],"%d", &on) != 1 ||on < 0 || on > 1 || led_no < 0 || led_no > 3) {
    	fprintf(stderr, "Usage: leds led_no 0|1\n");
    	exit(1);
    }
    /*打开/dev/leds 设备文件*/
    fd = open("/dev/leds0", 0);
    if (fd < 0) {
    	fd = open("/dev/leds", 0);
    }
    if (fd < 0) {
    	perror("open device leds");
    	exit(1);
    }
    /*通过系统调用 ioctl 和输入的参数控制 led*/
    ioctl(fd, on, led_no);
    /*关闭设备句柄*/
    close(fd);
    return 0;
}
```



互斥量

```c
#include<stddef.h>
#include<stdio.h>
#include<unistd.h>
#include "pthread.h"
void reader_function(void);
void writer_function(void);
char buffer;
int buffer_has_item=0;
pthread_mutex_t mutex;
int main()
{
     pthread_t reader;
     pthread_mutex_init(&mutex,NULL);
     pthread_create(&reader,NULL,(void*)&reader_function,NULL);
     writer_function();
}
void writer_function(void)
{
     while(1)
     {
         pthread_mutex_lock(&mutex);
         if(buffer_has_item==0)
         {
             buffer='a';
             printf("make a new item\n");
             buffer_has_item=1;
         }
         pthread_mutex_unlock(&mutex);
     }
}

void reader_function(void)
{
     while(1)
     {
         pthread_mutex_lock(&mutex);
         if(buffer_has_item==1)
         {
             buffer='\0';
             printf("consume item\n");
             buffer_has_item=0;
         }
         pthread_mutex_unlock(&mutex);
 	}
}

```



经典的Hello world驱动开发模板

```c
#include <linux/kernel.h>
#include <linux/module.h>
static int __init mini2440_hello_module_init(void)
{
     printk("Hello, Mini2440 module is installed !\n");
     return 0;
}
static void __exit mini2440_hello_module_cleanup(void)
{
	 printk("Good-bye, Mini2440 module was removed!\n");
}

module_init(mini2440_hello_module_init);
module_exit(mini2440_hello_module_cleanup);
MODULE_LICENSE("GPL");
```



### LED万能驱动开发模板

| LED  | 对应的 IO 寄存器名称 | 对应的 CPU 引脚 |
| ---- | -------------------- | --------------- |
| LED1 | GPB5                 | K2              |
| LED2 | GPB6                 | L5              |
| LED3 | GPB7                 | K7              |
| LED4 | GPB8                 | K5              |



```c
#include <linux/miscdevice.h>
#include <linux/delay.h>
#include <asm/irq.h>
#include <mach/regs-gpio.h>
#include <mach/hardware.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/mm.h>
#include <linux/fs.h>
#include <linux/types.h>
#include <linux/delay.h>
#include <linux/moduleparam.h>
#include <linux/slab.h>
#include <linux/errno.h>
#include <linux/ioctl.h>
#include <linux/cdev.h>
#include <linux/string.h>
#include <linux/list.h>
#include <linux/pci.h>
#include <asm/uaccess.h>
#include <asm/atomic.h>
#include <asm/unistd.h>
#define DEVICE_NAME "leds"

static unsigned long led_table [] = {
    S3C2410_GPB5,
    S3C2410_GPB6,
    S3C2410_GPB7,
    S3C2410_GPB8,
};

static unsigned int led_cfg_table [] = {
    S3C2410_GPB5_OUTP,
    S3C2410_GPB6_OUTP,
    S3C2410_GPB7_OUTP,
    S3C2410_GPB8_OUTP,
};

static int sbc2440_leds_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg){
    switch(cmd) {
        case 0:
        case 1:
            if (arg > 4)return -EINVAL;
            s3c2410_gpio_setpin(led_table[arg], !cmd);
            return 0;
        default:return -EINVAL;
	}
}

static struct file_operations dev_fops = {
    .owner = THIS_MODULE,
    .ioctl = sbc2440_leds_ioctl,
};

static struct miscdevice misc = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = DEVICE_NAME,
    .fops = &dev_fops,
};

static int __init dev_init(void){
    int ret;
    int i;
    for (i = 0; i < 4; i++) {
        s3c2410_gpio_cfgpin(led_table[i], led_cfg_table[i]);
        s3c2410_gpio_setpin(led_table[i], 0);
	}
    ret = misc_register(&misc);
    printk (DEVICE_NAME"\tinitialized\n");
	return ret;
}

static void __exit dev_exit(void){
	misc_deregister(&misc);
}

module_init(dev_init);
module_exit(dev_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("FriendlyARM Inc.");
```



### ==Linux驱动开发基本流程（必背）==

系统整体工作原理：

- 应用层 --> API --> 设备驱动 --> 硬件
- API : open、read、write、close等
- 驱动源码中提供真正的open、read、write、close等函数实体；

**file_operations结构体（**用来挂接实体函数地址）

- 元素主要是函数指针，用来挂接实体函数地址
- 每个设备驱动都需要一个该结构体类型的变量
- 设备驱动向内核注册时提供该结构体类型的变量



注册字符设备驱动

驱动向内核注册函数 `register_chrdev()` 

在 `#include <linux/fs.h>` 中

原型函数：

```c
static inline int register_chrdev(unsigned int major,const char *name,const struct file_operations *fops){
    return _register_chrdev(major,0,256,name,fops);
}
```



#### 驱动程序编写

##### ①定义 `file_operations` 结构体变量

**（用来挂接实体函数地址）**

![img](https://img-blog.csdnimg.cn/20200528132110493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTQ0MjIz,size_16,color_FFFFFF,t_70#pic_center)

##### ②`open` 和 `close` 函数原型确定、内容填充

##### ③模块安装，注册驱动

##### ④模块卸载

##### ⑤驱动模块编写



```c
#include <linux/module.h>		// module_init  module_exit
#include <linux/init.h>			// __init   __exit
#include <linux/fs.h>
 
#define MYMAJOR		200
#define MYNAME		"testchar"
int mymajor;
 
static int test_chrdev_open(struct inode *inode, struct file *file)
{
	// 这个函数中真正应该放置的是打开这个设备的硬件操作代码部分
	// 但是现在暂时我们写不了这么多，所以用一个printk打印个信息来做代表。
	printk(KERN_INFO "test_chrdev_open\n");
	
	return 0;
}
 
static int test_chrdev_release(struct inode *inode, struct file *file)
{
	printk(KERN_INFO "test_chrdev_release\n");
	
	return 0;
}
 
// 自定义一个file_operations结构体变量，并且去填充
static const struct file_operations test_fops = {
	.owner		= THIS_MODULE,				// 惯例，直接写即可
	
	.open		= test_chrdev_open,			// 将来应用open打开这个设备时实际调用的
	.release	= test_chrdev_release,		// 就是这个.open对应的函数
};
 
 
// 模块安装函数
static int __init chrdev_init(void)
{	
	printk(KERN_INFO "chrdev_init helloworld init\n");
 
	// 在module_init宏调用的函数中去注册字符设备驱动
	// major传0进去表示要让内核帮我们自动分配一个合适的空白的没被使用的主设备号
	// 内核如果成功分配就会返回分配的主设备好；如果分配失败会返回负数
	mymajor = register_chrdev(0, MYNAME, &test_fops);
	if (mymajor < 0)
	{
		printk(KERN_ERR "register_chrdev fail\n");
		return -EINVAL;
	}
	printk(KERN_INFO "register_chrdev success... mymajor = %d.\n", mymajor);
 
	return 0;
}
 
// 模块卸载函数
static void __exit chrdev_exit(void)
{
	printk(KERN_INFO "chrdev_exit helloworld exit\n");
	
	// 在module_exit宏调用的函数中去注销字符设备驱动
	unregister_chrdev(mymajor, MYNAME);
	
}
 
module_init(chrdev_init);
module_exit(chrdev_exit);
 
// MODULE_xxx这种宏作用是用来添加模块描述信息
MODULE_LICENSE("GPL");				// 描述模块的许可证
MODULE_AUTHOR("aston");				// 描述模块的作者
MODULE_DESCRIPTION("module test");	// 描述模块的介绍信息
MODULE_ALIAS("alias xxx");			// 描述模块的别名信息
```

##### ⑥驱动程序的编译

```bash
$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- modules SUBDIRS=/path/to/kernel/drivers/
$ make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- modules SUBDIRS=/path/to/kernel/drivers/
```

要把文件放在如下地方：也就是修改 `SUBDIRS` 地址

创建一个新的文件夹

```bash
sudo mkdir hello
```

可能权限不够，拷贝需要加 `sudo`



```bash
sudo cp hello_drv.c /lib/modules/5.3.0-28-generic/kernel/drivers/hello
```



```bash
/lib/modules/5.3.0-28-generic/kernel/drivers
```



modules 需要修改为相应的.c文件的名字：



找不到头文件，怎么办？

```bash
-I /usr/local/include/
```



最终：

```bash
$ make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu- hello_drv SUBDIRS=/lib/modules/5.3.0-28-generic/kernel/drivers/hello
```





## 9.编译原理

1.你简单说一说编译原理？

好，遇到这个，我会把它分为四个部分，为什么？是什么？怎么做？好处？

- 首先为什么？现在编程的高级语言计算机本身是读不懂的，所以要将这些高级程序设计语言转换成计算机硬件能识别的机器语言，再本质一点就是0101的代码。

- 是什么？

由上得：编译原理是介绍如何将高级程序设计语言转换成计算机硬件能识别的机器语言，以便计算机进行处理

- 怎么做？就是流程而言：

解释性语言python等除外，这里主要是C/C++

预处理器进行预处理：将宏替换和包含文件聚合在一起；

编译：编译器会通过一系列复杂的词法语法语义分析将预处理的东西转换为汇编代码

汇编：将汇编代码转换为可以重定位的机器代码

链接：将多个可以重定位的机器代码连接在一起，解决外部内存地址问题

- 好处：好处当然是程序员不用再像以前那样写机器码或者汇编代码，可以用更高级的语言处理一些更为复杂逻辑的情况等，加快了生产效率。



**复杂指令集计算机（CISC）与精简指令集计算机（RISC）**

CISC：Complex Instruction Set Computer：

x86架构就是CISC

CISC中程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按照顺序串行执行的。

优点，控制简单，但是计算机的各部分利用率不高，但是处理特殊任务效率高。

操作指令多，操作直接。

汇编相对简单

在一条执行执行结束后响应中断

功能强，CPU面积大，功耗大



RISC：Reduced Instruction Set Computer

每个指令类型都要比CISC更多的额外的晶体管的电路元件。删减某些不常用的指令，并且对一些特殊功能采用组合指令的形式来完成，所以效率可能会低。

对存储器操作有限制，使控制简单化。

汇编相对复杂，尤其是特殊功能的实现。

在机器的一条指令执行的适当地方可以响应中断。

CPU面积小，功耗低

ARM就是RISC

## 10.存储器



**CPU-->寄存器-->Cache高速缓存-->内存-->外存**



----------------



首先，CPU是计算机的核心，负责执行各种指令，它通过寄存器来完成数据的读取和处理。



寄存器是一种高速缓存，位于CPU内部，其速度比其他存储器更快。



CPU使用寄存器来存储计算过程中的中间结果，以及一些必要的数据，这样可以大大提高计算速度。



接下来，我们来讲高速缓存Cache。



高速缓存是位于CPU和内存之间的一种存储器，其作用是**缓存经常被访问的数据**，以便快速访问。



高速缓存的速度比内存快得多，它可以极大地提高计算机的性能。



目前，计算机中广泛使用的高速缓存有L1、L2和L3三级，它们的速度和容量逐级递减。





然后是内存，内存是计算机中常用的一种存储器，它用来存储程序和数据。



分为RAM和ROM。随着计算机的发展，内存的容量和速度也得到了极大的提高。



内存主要分为DRAM和SRAM两种类型，DRAM是一种动态存储器，它的速度比SRAM慢，但容量更大，价格更便宜。



SRAM是一种静态存储器，速度比DRAM快，但容量更小，价格更昂贵。



接下来是外存，外存是指位于计算机外部的存储器，如硬盘、光盘、闪存等。



外存的容量很大，但速度相对较慢。



目前，计算机中使用最广泛的外存是硬盘和闪存。



光盘就是利用激光原理去读写数据的，我们暂且先不去了解，先来看看硬盘。



---------------

### 硬盘SSD&HDD

硬盘又分为固态硬盘（SSD）和机械硬盘（HDD），其中固态硬盘SSD内部就是由闪存实现的。





让我们简单的对比一下二者：

| 区别/分类 | SSD固态硬盘                                    | HDD机械硬盘                                                  |
| --------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 工作器件  | 闪存存储器                                     | 盘片、磁头和机械臂                                           |
| 工作原理  | 在二极管和晶体管之间的介质中存储电荷来存储数据 | 将数据通过磁头读写到盘片上，在磁性表面上留下磁场以存储数据。 |
| 读写速度  | 更快                                           | 较慢                                                         |
| 容量      | 较小，但是不断更加                             | 更大                                                         |
| 寿命      | 较HDD短                                        | 较长                                                         |
| 价格      | 闪存成本高                                     | 较低                                                         |
| 应用场景  | 更快速度和性能需求的场合                       | 更大容量和低成本的场合，数据存储备份                         |
| 噪音      | 小                                             | 大                                                           |



-----------------

### 闪存Flash

看完硬盘，我们再看看闪存这玩意：



在1984年，日本东芝公司首先推出了一种新型存储器芯片，称为“闪存”（Flash）

闪存——非易失性存储设备，断电数据不丢失

它能做成什么？——USB闪存驱动器，SD卡，还有我们上面提到的SSD固态硬盘；

工作原理——存储电荷，在二极管和晶体管之间的介质中存储电荷

工作原理——擦除是整块都擦除，即整个块区都设置为逻辑1；编程就是电荷被存储，设置逻辑0；

特点——掉电不丢失，较快读取速度，可靠性高，低功耗



其中Flash主要分为NAND Flash和NOR Flash。



- NAND Flash 是 “NOT AND Flash”的意思，内部大量串联非门电路，所以存储密度高，读写速度快。闪存卡，SSD一般采用这种；最初是为了解决闪存卡容量问题而提出的。（页式管理）

- NOR Flash 是“NOT OR Flash”的意思，内部大量并联非门电路，所以可以实现较快速的读写，嵌入式系统常用以及DSP等；最初是替代EPROM和EEPROM问题提出的。



下面是二者更具体的区别：



需要提一嘴：

XIP是=="eXecute-In-Place"==的缩写，意思是在存储器中直接执行程序，而不需要将程序先加载到RAM中。XIP技术可以使系统在启动时加快启动速度，减少对RAM的占用，提高存储器的利用效率。

| 区别/分类 | NOR FLASH                                  | NAND FLASH           |
| --------- | ------------------------------------------ | -------------------- |
| 读        | 快，像SRAM一样随机访问，比NAND FLASH的要快 | 快，由严格时序要求   |
| 写        | 慢，写之前需要擦除                         | 快，写之前需要擦除   |
| 擦除      | 慢（5s）                                   | 快（3ms）            |
| XIP       | 可以                                       | 不能                 |
| 可靠性    | 比较高                                     | 比较低，位反转较常见 |
| 接口      | 与RAM相同                                  | I/O接口              |
| 容量      | 小                                         | 大                   |
| 价格      | 高                                         | 低                   |

此表摘自 “仲一大佬的嵌入式软件开发笔试面试指南硬件基础部分”





-----------

### RAM



接下来，Flash的前身是什么？更准确的来说NOT OR Flash的前身是什么？是EEPROM！也就是ROM。



但讲到ROM就得一起提到RAM了！



我们先看看RAM（Random Access Memory，随机存取存储器）：



RAM是一种随机访问存储器，它可以随时读写数据。



RAM可以分为静态RAM（SRAM）和动态RAM（DRAM）。



SRAM使用触发器作为存储单元，速度非常快，但价格较高。



DRAM使用电容作为存储单元，速度相对较慢，但价格更便宜，容量更大。



分类也就是发展顺序：

- 磁芯存储器（Magnetic Core Memory）：磁芯存储器是早期计算机使用的一种存储器，它由许多细小的磁铁芯组成，每个芯代表一个二进制数。由于其结构简单、易于制造和可靠性高，因此在20世纪50年代到60年代被广泛使用，但容量相对较小，速度也不够快。

- 芯片DRAM（Dynamic RAM）：芯片DRAM是20世纪70年代中期开始出现的一种新型RAM，它使用MOS技术制造，具有容量大、体积小、速度快等特点。DRAM通过电容存储数据，因此需要定期刷新以避免数据丢失，这也是其名字中“动态”的由来。DRAM在计算机存储器中得到广泛应用，也是目前主流计算机存储器的主要组成部分。（==栅极电容==）

- 静态RAM（SRAM）：静态RAM是一种比DRAM更快、更稳定的存储器，它不需要定期刷新数据，因此速度更快，同时也比DRAM更耗费功率。SRAM使用了更复杂的电路设计和更多的晶体管，因此容量相对较小，价格也较高，主要用于需要高速缓存的场合。（==双稳态触发器==）（Cache高速缓存）

- 高速DRAM（SDRAM）：高速DRAM是在DRAM基础上发展出的一种新型DRAM，具有更高的速度和更低的功耗，主要用于桌面计算机和服务器等高性能计算场合。（==同步时钟来控制数据读写的DRAM==）

- DDR SDRAM（==Double== Data Rate Synchronous Dynamic Random Access Memory）：DDR SDRAM是一种双倍速的SDRAM，可以在每个时钟周期内（==时钟信号的上升沿和下降沿==）进行两次数据传输，因此速度比SDRAM更快。DDR SDRAM经过多次升级，发展到DDR4和DDR5等版本，已成为目前主流计算机存储器的主要形式。



-----------

### ROM

讲完RAM，现在讲ROM：



ROM（Read-Only Memory）是一种只读存储器，其中的数据一旦被写入，就无法更改。



看这个名字，就可以看出来，其实ROM最初设计是只能读，写要一出场就初始化的并且不能更改的！



但是后面发展就变味了hh，科技树点歪了。



- ROM（==Read-Only Memory==）（只读存储器）：ROM最早出现在20世纪60年代。在这个时期，ROM主要被用于存储程序和数据，用于计算机、电视游戏机等电子产品中。ROM可以固化存储器的内容，因此在安全性和稳定性方面具有优势。但ROM的容量较小，且不可修改，因此只适用于存储少量固定数据。

- PROM（==Programmable Read-Only Memory==）（可编程只读存储器）：PROM出现在20世纪70年代。PROM与ROM类似，都是在制造时写入数据，但是PROM在使用时可以被编程修改。用户可以通过特殊的编程设备将数据写入PROM中，但一旦编程之后，数据就不可更改。

- EPROM（==Erasable Programmable Read-Only Memory==）（可擦除可编程只读存储器）：EPROM出现在20世纪80年代。EPROM和PROM的区别在于EPROM可以被擦除和重新编程，而PROM只能被编程一次。EPROM的擦除是通过使用==紫外线照射EPROM芯片的晶体管==来实现的，因此擦除需要将EPROM芯片从设备中取出。EPROM的容量比PROM大，但擦除和重新编程需要一定的成本和时间。

- EEPROM（==Electrically Erasable Programmable Read-Only Memory==）（电可擦除可编程只读存储器）：EEPROM出现在20世纪90年代（==Intel公司==）推出。EEPROM与EPROM的区别在于擦除时不需要使用紫外线，而是通过电压来实现（==电擦除==），因此可以在设备中进行擦除和重新编程。EEPROM可以反复擦除和编程，也可以单独擦除或编程，而不必像EPROM一样将整个芯片擦除。EEPROM的容量比EPROM小，但是具有更高的可编程性和可擦除性。

- Flash存储器：Flash上面讲了，这里就不赘述了。





好了，基本到现在，存储器大概方向讲完了，现在来看几道经典题目：

1. ==RAM和ROM的区别？==

   | 特点/分类 | RAM            | ROM                                            |
   | --------- | -------------- | ---------------------------------------------- |
   | 定义      | 随机存取存储器 | 只读存储器                                     |
   | 存储数据  | 临时存储数据   | 永久性存储数据                                 |
   | 读写速度  | 非常快         | 相对较慢                                       |
   | 掉电丢失  | 是             | 否                                             |
   | 具体分类  | SRAM和DRAM     | PROM，EPROM，EEPROM，Flash                     |
   | 重写次数  | 可以重复读写   | 开始设计为只能写入一次，但是现在也可以重复读写 |
   | 容量      | 小             | 大                                             |
   | 应用场景  | 频繁读写       | 程序代码和数据                                 |

   。。。

   

2. ==FLASH和RAM的区别？==

- 存储方式：FLASH是非易失性存储器，即断电后仍能保持存储数据，而RAM是易失性存储器，需要连续供电才能保持数据。这意味着，当计算机关闭时，RAM存储的数据将被清除，而FLASH中存储的数据将被保留下来。
- 读写速度：RAM通常比FLASH速度更快，因为RAM可以随时读写存储的数据，而FLASH的读写速度相对较慢。
- 容量：FLASH的存储容量通常比RAM大，因此它更适合于存储大量的数据，例如操作系统、应用程序等。RAM的容量相对较小，因此它更适合于存储短期的临时数据，例如程序的变量和运行时状态等。
- 成本：FLASH的成本通常比RAM高，因为它需要更多的电路和技术支持来实现非易失性存储。相比之下，RAM的成本较低，因为它只需要支持易失性存储即可。

​	。。。



3. ==EEPROM和FLASH的区别？==

- 擦除方式：EEPROM使用电场擦除，FLASH使用高电压擦除。EEPROM的擦除速度较慢，但是可以精确擦除单个字节或单个字，而FLASH的擦除速度较快，但是只能擦除一整个块（==扇区sector==）（通常为4KB或64KB）。
- 编程方式：EEPROM可以通过写入电荷或电压来编程单个字节或单个字，而FLASH则必须在块的基础上编程，因此编程速度比EEPROM慢。
- 容量：FLASH的容量通常比EEPROM大。
- 使用场景：由于EEPROM的编程速度较快，因此适用于小容量数据的存储和应用，如嵌入式系统中的配置数据和参数；而FLASH则更适合于需要大容量数据存储和较快读写速度的应用，如固态硬盘、闪存卡、数字相机等。
- 使用寿命：EEPROM的读写寿命相对于Flash更长，因为EEPROM可以进行单独的擦除和编程，而不需要整个扇区的操作。

​      。。。



4. ==NAND Flash和NOR Flash的区别？==

​		回看即可。





然后再看看最开始的这个流程：

**CPU-->寄存器-->Cache高速缓存-->内存-->外存**

对里面的存储器应该有了个初步的了解



## 11.C++

### C++ 11有什么新特性？

- 提供 long long 长整型，占8个字节
- 提供统一的初始化语法，使用花括号{}初始化变量
- 提供空指针 `nullptr` 代替 `NULL`
- 提供 constexpr 修饰函数、结构体，由编译器检查变量值是否为常量表达式
- 提供 using 来进行别名声明
- 提供 auto 进行自动变量类型推断， decltype 从表达式类型推断要定义的变量类型
- 提供范围for语句，例如 `for(auto x: range)`
- 提供 cbegin() 和 cend() 函数，返回const迭代器
- 除法规则，商一律向0取整
- 提供 initializer_list 模板类型，元素永远为常量值，无法修改
- 提供尾置返回类型
- 可以使用 =default 要求编译器生成构造函数
- 提供 lambda 表达式，`[capture] (parameters) -> return value { body }`
- 提供无序关联容器：unordered_set，unordered_multiset，unordered_map，unordered_multimap
- 提供 default、delete 关键字
- 提供右值引用
- 提供 final、override 关键字



### C++基础知识：

C++程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。

- 对象：对象具有状态和行为；
- 类：类可以定义为描述对象行为/状态的模板，对象是类的实例；
- 方法：从基本上说，一种方法表示一种行为。一个类可以包含多个方法；
- 即时变量：每个对象都有其独特的即时变量；

```cpp
#include <iostream>
//头文件<iostream>
using namespace std;
//告诉编译器使用std命名空间

// main() 是程序开始执行的地方
int main()
{
   cout << "Hello World" << endl; 
    // 输出 Hello World
   return 0;
}
```



**命名空间：**

命名空间用来区分不同库中相同名称的函数、类、变量等；

本质上，命名空间就是定义了一个范围。

```cpp
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
int main ()
{
   // 调用第一个命名空间中的函数
   first_space::func();
   // 调用第二个命名空间中的函数
   second_space::func(); 
   return 0;
}
```



\#define 预处理指令用于创建符号常量。**该符号常量通常称为宏**



有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。

条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：

```cpp
#ifndef NULL
   #define NULL 0
#endif
```

例如，要实现只在调试时进行编译，可以使用一个宏来实现，如下所示：

```cpp
#ifdef DEBUG
   cerr <<"Variable x = " << x << endl;
#endif
```

使用 #if 0 语句可以注释掉程序的一部分，如下所示：

```cpp
#if 0
   不进行编译的代码
#endif
```



### **相关面试题Ⅰ：**

Q：C++和C的区别？

A：在设计思想上，C++是面向对象的语言，而C是面向过程的结构化编程语言；在语法上：C++具有封装、继承、多态三种特性；C++相比C，增加许多类型安全的功能；C++支持范式编程；



Q：为什么C++支持函数重载而C语言不支持呢？

A：在链接阶段，C语言是通过函数本名去寻找函数的实体的，所以当两个函数同名时是无法识别的；而C++会将函数名和函数带的参数转换成编译特征和固有特征，这个时候编译器就可以分辨出两个同名不同参数的函数。



Q：include头文件双引号`""`和尖括号`< >`的区别？

A：编译器预处理阶段查找头文件的路径不一样：对于使用双引号`""`包含的头文件，编译器会从用户的工作路径开始搜索；对于使用尖括号`< >`包含的头文件，编译器从标准库路径开始搜索。



Q：头文件的作用？

A：通过头文件来调用库功能；头文件能加强类型安全检查；



Q：在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义？

A：这样可以提高编译效率，因为分开的话，这个类只需要编译一次生成对应的目标文件，以后在其他地方用到这个类时，编译器查找到了头文件和目标文件，就不会再次编译这个类，从而大大提高效率。



Q：C++源文件从文本到可执行文件经历的过程？

A：四个过程：1. **预编译阶段**：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件；2. **编译阶段**：将经过预处理后的预编译文件转换为特定汇编文件，生成汇编代码文件；3. **汇编阶段**：将编译阶段生成的汇编文件转换成机器码，生成可重定位目标文件；4. **链接阶段**：将多个目标文件及所需要的库链接成最终的可执行目标文件；



Q：静态链接与动态链接？

A：静态链接是在编译期间完成的。1. 静态链接浪费空间，这是由于多进程情况下，每个进程都要保存静态链接函数的副本；2. 更新困难，当链接的众多目标文件中有一个改变后，整个程序都要重新链接才能使用新的版本； 3. 静态链接运行效率高；动态链接是在程序执行时链接的。1. 动态链接当系统多次使用同一个目标文件时，只需要加载一次即可，节省内存空间；2. 程序升级变得容易，当升级某个共享模块时，只需要简单的将旧目标文件替换掉，程序下次运行时，新版目标文件就会被自动装载到内存并链接起来，即完成升级。



Q：C++11有什么新特性？

A：**auto关键字**：编译器可以根据初始值自动推导出类型，但是不能用于函数传参以及数组类型的推导；**nullptr关键字**：nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型，而NULL一般被宏定义为0，在遇到重载时可能会出现问题；**智能指针**：C++11新增了std::shared_ptr 、std::weak_ptr等类型的智能指针，用于解决内存管理问题；**初始化列表**：使用初始化列表来对类进行初始化；**右值引用**：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；**atomic原子操作**用于多线程资源互斥操作；**新增STL容器array以及tuple**。



Q：assert( )是什么？

A：断言是宏，而非函数。assert宏的原型定义在`<assert.h>` ( C )、`<cassert>`  ( C++) 中其作用是如果它的条件返回错误，则终止程序执行。可以通过定义NDEBUG来关闭assert，但是需要在源代码的开头，include <assert.h>之前。

```c
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>
assert( p != NULL );    // assert 不可用
```



Q：C++是不是类型安全的？

A：不是，因为两个不同类型的指针可以强制类型转换（reinterpret cast）。



Q：系统会自动打开和关闭的3个标准文件是什么？

A：1.标准输入---键盘---stdin 。 2. 标准输出---显示器---stdout  。  3. 标准出错输出---显示器---stder





### C++数据操作

C++有7种基本的数据类型：

|   类型   | 关键字  |
| :------: | :-----: |
|  布尔型  |  bool   |
|  字符型  |  char   |
|   整型   |   int   |
|  浮点型  |  float  |
| 双浮点型 | double  |
|  无类型  |  void   |
| 宽字符型 | wchar_t |



可以使用`signed` `unsigned` `short` `long` 去修饰这些基本类型：

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDU5MzE3LTg2MDEwOWRlMDQwYmQ5YTkucG5n?x-oss-process=image/format,png" alt="img" style="zoom:150%;" />



- 局部变量：在函数或一个代码块内部声明的变量；
- 形式参数：在函数参数的定义中声明的变量；
- 全局变量：在所有函数外部声明的变量；



局部变量被定义，必须进行初始化，否则变量值未知；全局变量，系统会自动初始化：

| 数据类型 | 初始化默认值 |
| :------: | :----------: |
|   int    |      0       |
|   char   |     '\0'     |
|  float   |      0       |
|  double  |      0       |
| pointer  |     NULL     |



常量是固定值，在程序执行期间不会改变。这些固定值，又叫做字面量。

**define预处理器**

下面是使用 #define 预处理器定义常量的形式：

```cpp
#define LENGTH 10   
#define WIDTH  5
#define NEWLINE '\n'
```



**const关键字**

可以使用 const 前缀声明指定类型的常量，const类型的对象在程序执行期间不能被修改。如下所示：

```cpp
const int  LENGTH = 10;
const int  WIDTH  = 5;
const char NEWLINE = '\n';
```



**volatile关键字**

volatile用来修饰变量，声明某个变量的值可能会随时被外部改变，因此使用volatile告诉编译器不应对这样的对象进行优化（没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值；而被volatile修饰的变量，它不能被缓存到寄存器，每次访问需要到内存中重新读取）



**restrict关键字**

restrict修饰的指针是唯一一种访问它所指向的对象的方式；



**auto关键字**

auto关键字用于两种情况：

- 声明变量时根据初始化表达式自动推断该变量的类型；
- 声明函数时函数返回值的占位符；



**static关键字**

static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁；

- 使用static修饰局部变量可以在函数调用之间保持局部变量的值；
- 当static修饰全局变量时，会使变量的作用域限制在声明它的文件内；
- 在C++中，当static用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享；



**extern存储类**

extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。通常用于当有两个或多个文件共享相同的全局变量或函数的时候。



### 相关面试题Ⅱ：



Q：`const的作用`？

A：1. 修饰变量，说明该变量不可以被修改； 2. 修饰指针，即常量指针和指针常量；3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值得修改；4. 修饰类的成员函数，说明该成员函数内不能修改成员变量。



Q：说明define和const在语法和含义上有什么不同？

A：1. #define是C语法中定义符号变量的方法，符号变量只是用来表达一个值，在编译阶段符号就被值替换了，它没有类型；2. const是C++语法中定义常变量的方法，常变量具有变量特性，它具有类型，内存中存在以它命名的存储单元，可以用sizeof测出长度；



Q：`static`关键字的作用？

A：静态变量在程序执行之前就被创建，在程序执行的整个周期都存在。1. **局部静态变量**：作用域仅在定义它的函数体或语句块内，该变量的内存只被分配一次，因此其值在下次函数被调用时仍维持上次的值；2. **全局静态变量**：作用域仅在定义它的文件内，该变量也被分配在静态存储区内，整个程序运行期间一直存在；3. **静态函数**：在函数返回类型前加static，函数就定义为静态函数。静态函数只是在声明它的文件中可见，不能被其他文件所用；4. **类的静态成员**：在类中，静态成员属于整个类所拥有，对类的所有对象只有一份拷贝，因此可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，既保证了安全性；5. **类的静态函数**：在类中，静态成员函数不接受this指针，因此只能访问类的static成员变量，如果静态成员函数中要引用非静态成员时，可通过对象来引用。



Q：C++里面怎么定义常量？常量存放在内存的哪个位置？

A：常量在C++里使用const关键字定义，常量定义必须初始化。对于局部对象，常量存放在栈区；对于全局对象，编译器一般不分配内存，放在符号表中以提高访问效率；对于字面值常量，存放在常量存储区；



Q：`sizeof( )`和`strlen( )`

A：sizeof是运算符，能获得保证能容纳实现所建立的最大对象的字节大小：sizeof对数组，得到整个数组所占空间大小；sizeof对指针，得到指针本身所占空间大小（4个字节）；当一个类A中没有声明任何成员变量与成员函数，这时sizeof（A）的值是1。strlen（）是函数，可以计算字符串的长度，直到遇到结束符NULL才结束，返回长度大小不包含NULL；



Q：C++内存对齐？

A：

1. 内存对齐：**数据项只能存储在地址是数据项大小的整数倍的内存位置上。**实际访问内存是在访问特定类型变量的时候经常在特定的内存地址访问，需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐；
2. 使用原因：**平台原因**：不同硬件平台对存储空间的处理上存在很大的不同，某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放；**性能原因**：为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问；如果不按照平台要求对存放数据进行对齐，会发生内存的二次访问，带来效率上的损失。
3. 内存对齐规则：**数据成员对齐规则**：结构（struct）或联合（union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行；**结构（或联合）的整体对齐规则**：在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行；**结构体作为成员**：如果一个结构里有些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。
4. **位域**：相邻的多个同类型的数（带符号与不带符号的，只要基本类型相同，也为相同的数）。如果他们所占用的位数不超过基本类型的大小，那么他们可以作为一个整体来看待。不同类型的数要遵循各自的对齐方式。



Q：强制类型转换运算符？

A：

| 类型             | 特点                       | 应用场合                                                     |
| ---------------- | -------------------------- | ------------------------------------------------------------ |
| static_cast      | 静态转换，编译时执行       | 主要用于C++中内置的基本数据类型之间的转换，同一个继承体系中类型的转换，任意类型与空指针类型void*之间的转换，但是没有运行时类型检查（RTTI）来保证转换的安全性 |
| const_cast       | 去常转换，编译时执行       | const_cast可以用于修改类型的const或volatile属性，去除指向常熟对象的指针或引用的常量性 |
| reinterpret_cast | 重解释类型转换，编译时执行 | 可以用于任意类型的指针之间的转换，对转换的结果不做任何保证   |
| dynamic_cast     | 动态类型转换，运行时执行   | 只能用于存在虚函数的父子关系的强制类型转换，只能转指针或引用。对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常 |





Q：什么是RTTI ？

A：RTTi（Run Time Type Identification）即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型；**RTTI机制产生原因**：C++是一种静态类型语言，其数据类型是在编译器就确定的，不能在运行时更改。然而由于面对对象程序设计中多态性的要求，C++中的指针或引用本身的类型，可能与它实际代表（指向或引用）的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。
C++中有两个函数用于运行时类型识别，分别是`dynamic_cast` 和`typeid` ，具体如下：1. typeid函数返回一个对type_info类对象的引用，可以通过该类的成员函数获得指针和引用所指的实际类型；2. dynamic_cast操作符，将基类型的指针或引用安全对地转换为其派生类类型的指针或引用；



Q：explicit （显式）关键字？

A：explicit修饰构造函数时，可以防止隐式转换和复制初始化，必须显式初始化； explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

```cpp
struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};
 
int main()
{
    B b1(1);        // OK：直接初始化
    B b2 = 1;       // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3{ 1 };      // OK：直接列表初始化
    B b4 = { 1 };       // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1;        // OK：允许 static_cast 的显式转换
    doB(1);         // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b7 = b1;       // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化
 
    return 0;
}
```



Q：::范围解析运算符？

A：该运算符可以分为如下三类：1. 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间；2. 类作用域（class::name）：用于表示指定类型的作用域范围是具体某个类的 ； 3. 命名空间作用域符（namespace::name）：用于表示指定类型的作用域范围是具体某个命名空间的。



### C++指针和引用：

指针是一个变量，它的值为另一个变量的内存地址。

所有指针的值的实际数据类型都是一样的，都是一个代表内存地址的长的十六进制数。

```cpp
#include <iostream>
 
using namespace std;
 
int main ()
{
   int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明
 
   ip = &var;       // 在指针变量中存储 var 的地址
 
   cout << "Value of var variable: ";
   cout << var << endl;
 
   // 输出在指针变量中存储的地址
   cout << "Address stored in ip variable: ";
   cout << ip << endl;
 
   // 访问指针中地址的值
   cout << "Value of *ip variable: ";
   cout << *ip << endl;
 
   return 0;
}
```



**引用**：

引用变量是一个别名，它是某个已存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

引用不存在空引用，必须连接到一块合法的内存；

一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。

引用必须在创建时被初始化，指针可以在任何事件被初始化。

```cpp
// 声明简单的变量
int i;
double d;
 
// 声明引用变量
int& r = i;
double& s = d;
```

### 相关面试题Ⅲ：



Q：C/C++中指针和引用的区别？

A：

	1. 指针有自己的一块空间，而引用只是一个别名；
	1. 指针可以被初始化为NULL，而引用必须被初始化；
	1. 指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变；
	1. 指针可以有多级指针（**p），而引用只有一级；





Q：指针函数和函数指针？

A：**指针函数**本质上是一个函数，函数的返回值是一个指针；**函数指针**本质上是一个指针，C++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址，有了函数指针后，就可以用指针变量调用函数。

```cpp
char * fun(char * p)  {…}       //  指针函数fun
char * (*pf)(char * p);             //  函数指针pf
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        // 通过函数指针pf调用函数fun
```



Q：在什么时候需要使用“常引用”？

A：如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用；



Q：C++中的四个智能指针：`shared_ptr` `unique_ptr` `weak_ptr` `auto_ptr` 

A：智能指针出现的原因：智能指针的作用就是用来管理一个指针，将普通的指针封装成一个栈对象，当栈对象的生命周期结束之后，会自动调用析构函数释放掉申请的内存空间，从而防止内存泄露；

1. shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在最后一个引用被销毁时被释放；
2. unique_ptr实现独占式拥有概念，保证同一时间内只有一个智能指针可以指向该对象；
3. weak_ptr是一种共享但不拥有对象的智能指针，它指向一个shared_ptr管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr，weak_ptr只是提供了对管理对象的一个访问手段，它的构造和析构不会引起引用计数的增加或减少。weak_ptr设计的目的是为协助shared_ptr工作的，用来解决shared_ptr相互引用时的死锁问题。避免共享指针（`shared_ptr`）的循环引用
4. auto_ptr采用所有权模式，C++中已经抛弃；

例子如下：

一个使用weak_ptr的典型例子就是避免共享指针（shared_ptr）的循环引用问题。

==如下面的代码：==

```c++
#include <iostream>
#include <memory>

class B; // 前置声明

class A {
public:
    std::shared_ptr<B> b_ptr; // A类持有B类的shared_ptr
    void do_something() {
        std::cout << "A::do_something()" << std::endl;
    }
};

class B {
public:
    std::shared_ptr<A> a_ptr; // B类持有A类的shared_ptr
    void do_something() {
        std::cout << "B::do_something()" << std::endl;
    }
};

int main() {
    std::shared_ptr<A> a_ptr = std::make_shared<A>();
    std::shared_ptr<B> b_ptr = std::make_shared<B>();
    a_ptr->b_ptr = b_ptr;
    b_ptr->a_ptr = a_ptr;
    return 0;
}
```

==在上述代码中，A类和B类相互引用对方的shared_ptr，这就导致了一个循环引用的问题。如果只是使用shared_ptr，那么当a_ptr和b_ptr都超出作用域，但它们相互持有的内存却无法被释放，会导致内存泄漏。==

解决这个问题的方法是，A类和B类之间使用weak_ptr来相互引用，如下所示：

```c++
#include <iostream>
#include <memory>

class B; // 前置声明

class A {
public:
    std::weak_ptr<B> b_ptr; // A类持有B类的weak_ptr
    void do_something() {
        std::cout << "A::do_something()" << std::endl;
    }
};

class B {
public:
    std::weak_ptr<A> a_ptr; // B类持有A类的weak_ptr
    void do_something() {
        std::cout << "B::do_something()" << std::endl;
    }
};

int main() {
    std::shared_ptr<A> a_ptr = std::make_shared<A>();
    std::shared_ptr<B> b_ptr = std::make_shared<B>();
    a_ptr->b_ptr = b_ptr;
    b_ptr->a_ptr = a_ptr;
    return 0;
}
```


在这个示例中，A类和B类之间使用weak_ptr来相互引用，这样就避免了循环引用问题，同时也避免了内存泄漏的问题。



Q：shared_ptr的底层实现？

A：

```cpp
template <typename T>
class smart_ptrs {
public:
    smart_ptrs(T*); //用普通指针初始化智能指针
    smart_ptrs(smart_ptrs&); // 拷贝构造
    T* operator->(); //自定义指针运算符
    T& operator*(); //自定义解引用运算符
    smart_ptrs& operator=(smart_ptrs&); //自定义赋值运算符
    ~smart_ptrs(); //自定义析构函数
private:
    int *count; //引用计数
    T *p; //智能指针底层保管的指针
};
 
//构造函数
template <typename T>
smart_ptrs<T>::smart_ptrs(T *p): count(new int(1)), p(p) {}
 
//对普通指针进行拷贝，同时引用计数器加1，因为需要对参数进行修改，所以没有将参数声明为const
template <typename T>
smart_ptrs<T>::smart_ptrs(smart_ptrs &sp): count(&(++*sp.count)), p(sp.p)  {}
 
//指针运算符
template <typename T>
T* smart_ptrs<T>::operator->() {return p;}
 
//定义解引用运算符
template <typename T>
T& smart_ptrs<T>::operator*() {return *p;}
 
//定义赋值运算符，左边的指针计数减1，右边指针计数加1，当左边指针计数为0时，释放内存：
template <typename T>
smart_ptrs<T>& smart_ptrs<T>::operator=(smart_ptrs& sp) {
    ++*sp.count;
    if (--*count == 0) { //自我赋值同样能保持正确
        delete count;
        delete p;
    }
    this->p = sp.p;
    this->count = sp.count;
    return *this;
}
 
// 定义析构函数：
template <typename T>
smart_ptrs<T>::~smart_ptrs() {
    if (--*count == 0) {
        delete count;
        delete p;
    }
}
```



Q：unique_ptr

A：当我们独占资源的所有权时，可以使用unique_ptr对资源进行管理，这样离开unique_ptr对象的作用域时可以自动释放资源，基本的RAII思想。

```c++
unique_ptr<int> uptr = make_unique<int>(200);
```

自动管理内存，等同于new+delete

unique_ptr是move-only的。

unique_ptr可以指向一个数组，如下：

```c++
{
    std::unique_ptr<int[]> uptr = std::make_unique<int[]>(10);
    for (int i = 0; i < 10; i++) {
        uptr[i] = i * i;
    }   
    for (int i = 0; i < 10; i++) {
        std::cout << uptr[i] << std::endl;
    }   
}
```



Q：shared_ptr

A：对资源做引用计数，当引用计数为0时，自动释放资源。

其使用方法和unique_ptr类似：

```c++
{
    std::shared_ptr<int> sptr = std::make_shared<int>(200);
    assert(sptr.use_count() == 1);  // 此时引用计数为 1
    {   
        std::shared_ptr<int> sptr1 = sptr;
        assert(sptr.get() == sptr1.get());
        assert(sptr.use_count() == 2);   // sptr 和 sptr1 共享资源，引用计数为 2
    }   
    assert(sptr.use_count() == 1);   // sptr1 已经释放
}
// use_count 为 0 时自动释放内存
```

shared_ptr需要维护的信息有两部分：1.指向共享资源的指针；2.引用计数等共享资源的控制信息，实际上是维护一个指向控制信息的指针。





Q：weak_ptr

A：weak_ptr和shared_ptr一起使用，一个weak_ptr对象看作是shared_ptr对象管理的资源的观察者，不影响共享资源的生命周期。

如果需要使用weak_ptr正在观察的资源，可以将weak_ptr提升为shared_ptr；

当shared_ptr管理的资源被释放时，weak_ptr会自动变成nullptr；







Q：野指针是什么？

A：野指针就是指向一个已销毁或者访问受限内存区域的指针。产生野指针通常是因为：1. 指针变量未被初始化； 2. 指针释放后未置空； 3. 指针操作超越变量作用域（例如变量被释放了，指针还是指向它）



Q：段错误？

A：段错误通常发生在访问非法内存地址的时候，如下：1. 使用了野指针； 2. 试图修改字符串常量的内容； 3. 数组越界导致栈溢出；



Q：什么是右值引用，跟左值又有什么区别？

A：左值：能对表达式取地址的具名对象/变量等。一般指表达式结束后依然存在的持久对象。左值：不能对表达式取地址的字面量、函数返回值、匿名函数或匿名对象。一般指表达式结束就不再存在的临时对象。

右值引用和左值引用的区别在于：

- 通过&获得左值引用，左值引用只能绑定左值；
- 通过&&获得右值引用，右值引用只能绑定右值，基于右值引用可以实现移动语义和完美转发，右值引用的好处是减少右值作为参数传递时的复制开销，提高效率；





Q：什么是std::move()以及什么时候使用它？

A：std::move()是C++标准库中用于转换为右值引用的函数。当需要在其他地方“传输”对象的内容时使用std::move()，对象可以在不进行复制的情况下获取临时对象的内容，避免不必要的深拷贝；





Q：C++类的内部可以定义引用数据成员吗？

A：可以，必须通过成员函数初始化列表初始化

```cpp
class MyClass
{
public:
    MyClass(int &i):  a(1),   b(i){         //  构造函数初始化列表中是初始化工作
        //   在这里做的是赋值而非初始化工作
    }
private:
    const int a;
    int &b;  // 引用数据成员b,必须通过列表初始化！
};
```



### C++编程模块

函数传参：1. 传值调用； 2. 指针调用； 3. 引用调用；



**内联函数**：引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。所以内联函数一般都是10行以下的小函数，如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。

==类中定义的成员函数全部默认为内联函数，在类中声明，但在类外定义的为普通函数；==



**重载函数**：C++ 允许在同一个作用域内声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。**不能仅通过返回类型的不同来重载函数。**

选择最合适的重载函数或重载运算符的过程，称为重载决策。

**重载的运算符是带有特殊名称的函数**，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。



**模板**：

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。



### 相关面试题Ⅳ



Q：C语言是怎么进行函数调用的？

A：每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈；



Q：函数参数压栈方式为什么是从右到左的？

A：因为C++支持可变函数参数。C程序栈底为高地址，栈顶为低地址，函数最左边确定的参数在栈上的位置必须是确定的，否则以为着已经确定的参数是不能定位和找到的，这样是无法保证函数正确执行的。



Q：C++如何处理返回值？

A：生成一个临时变脸存入内存单元，调用程序访问该内存单元，获得返回值；



Q：fork ， wait， exec 函数的作用？

A：

- fork函数可以创建一个和当前映像一样的子进程，这个函数会返回两个值：从子进程返回0，从父进程返回子进程的PID；
- 调用了wait函数的父进程会发生阻塞，直到有子进程状态改变（执行成功返回0，错误返回-1）；
- exec函数可以让子进程执行与父进程不同的程序，即让子进程执行另一个程序（exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1）



Q：inline内联函数是什么？

A：当一个函数被声明为内联函数之后，在编译阶段，编译器会用内联函数的函数体替换程序中出现的内联函数调用表达式，而其他的函数都是在运行时才被替换，这就是空间换时间，提高了函数调用的效率。同时，内联函数具有几个特点：

1. 内联函数中不可以出现循环、递归或开关操作；
2. 内联函数的定义必须出现在内联函数的第一次调用前；
3. 类的成员函数（除了虚函数）会自动隐式的当成内联函数；

举例：

```c++
#include <iostream>

inline int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int x = 10, y = 20;
    std::cout << "max is " << max(x, y) << std::endl;
    return 0;
}
```

Q：内联函数的优缺点？

A：优点：

- 内联函数在被调用处进行代码展开，省去了参数压栈、堆帧开辟与回收，结果返回等操作，从而提高程序运行速度；
- 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换，而宏定义则不会；
- 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义不能；
- 内联函数在运行时可以调试，而宏定义不可以；

缺点：

- 代码膨胀，消耗了更多的内存空间；
- inline函数无法随着函数库升级而升级，inline函数的改变需要重新编译，不像non-inline可以直接链接；
- 内联函数不可控，它只是对编译器的建议，是否对函数内联，决定权在于编译器；



Q：虚函数可以是内联函数吗？

A：虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联；



Q：函数重载、重写、隐藏和模板？

A：

- 重载：在同一作用域中，两个函数名相同，但是参数列表不同（个数、类型、顺序），返回值的类型没有要求；
- 重写：子类继承父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写；
- 隐藏：派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，此时基类的函数会被隐藏；
- 模板：模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表，只适用于参数个数相同而类型不同的函数；



Q：构造函数和析构函数能不能被重载？

A：构造函数可以被重载，析构函数不能被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数；

 

Q：拷贝构造函数和赋值运算符重载的区别？

A：

- 拷贝构造函数是函数，赋值运算符是运算符的重载；
- 拷贝构造函数会生成新的类对象，赋值运算符不会；
- 拷贝构造函数是用一个已存在的对象去构造一个不存在的对象；而赋值运算符重载函数是用一个存在的对象去给另一个已存在并初始化过的对象进行赋值；



Q：类模板是什么？

A：类模板是对一批仅数据成员类型不同的类的抽象，用于解决多个功能相同、数据类型不同的类需要重复定义的问题。在建立类时候使用 `template` 及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。



Q：select、poll和epoll的区别、原理、性能、限制？

A：select、poll、epoll都是I/O多路复用技术的具体实现。I/O多路复用就是在单个线程中，通过记录并跟踪每个I/O流的状态，来同时管理多个I/O流，一旦某个I/O流已经就绪，就能够通知程序进行相应的读写操作，以此提高服务器的吞吐能力。这种机制的优势不是在于对单个连接能处理得更快，而是在于能处理更多的连接，也就是多路网络连接复用一个I/O线程。

**select：** select是第一个实现I/O复用概念的函数。它用一个结构体fd_set让内核监听多个文件描述符。fd_set（文件描述符集合）本质上就是一个数组，当调用select函数后，就会去里面轮询查找看select函数主要存在三个问题：

1. 内置数组的形式使得select支持的最大文件描述符受限FD_SIZE；
2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态；
3. 每次调用select后都要去轮询排查所有文件描述符，这在文件描述符个数很多的时候，效率很低；

**poll：**

poll可以理解为一个加强版的select，它通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体pollfd，这个结构体保存了描述符的信息，每增加一个文件描述符就向数组中加入一个结构体。同时，结构体只需要拷贝一次到内核态，解决了select重复初始化的问题。但是它仍然存在轮询排查效率低的问题。

**epoll：**

轮询排查所有文件描述符的效率不高，使服务器并发能力受限。因此epoll采用只返回状态发生变化的文件描述符，便解决了轮询的瓶颈。



### C++结构体、类与对象

struct语句定义了一个包含多个成员的新的数据类型：

```cpp
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

这里声明一个结构体类型Books，变量为book



**访问结构成员使用成员访问运算符（.）**



**指向结构的指针**

定义指向结构的指针，方式与定义指向其他类型变量的指针相似。为了使用指向该结构的指针访问结构的成员，必须使用 -> 运算符，如下所示：

```cpp
struct Books *struct_pointer;
struct_pointer = &Book1;
struct_pointer->title;
```



**类和对象**

```cpp
class Box
{
   public:
      double length;   // 盒子的长度
      double breadth;  // 盒子的宽度
      double height;   // 盒子的高度
      double getVolume(void);// 返回体积
};
```

**类的声明**

```cpp
Box box1;
Box box2 = Box(parameters);
Box box3(parameters);
Box* box4 = new Box(parameters);
```

**访问类的成员**

```cpp
box1.length = 5.0;
cout << box1.length << endl;
```

**类成员函数**

成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 :: 来定义**。

```cpp
class Box
{
   public:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
   
      double getVolume(void)
      {
         return length * breadth * height;
      }
};
//您也可以在类的外部使用范围解析运算符 :: 定义该函数
double Box::getVolume(void)
{
    return length * breadth * height;
}
 
//调用成员函数同样是在对象上使用点运算符（.）
Box myBox;          // 创建一个对象
myBox.getVolume();  // 调用该对象的成员函数
```

**类访问修饰符**

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记`public` `private` `protected` 来指定的。关键字`public` `private` `protected` 称为访问修饰符。

```cpp
class Base {
 
   public:
   // 公有成员
 
   protected:
   // 受保护成员
 
   private:
   // 私有成员
};
```

- 公有成员在程序中类的外部是可访问的；
- 私有成员变量或函数在类的外部是不可访问的，甚至不可查看。只有类和友元函数可以访问私有成员。在类中，如果没有使用任何访问修饰符，类的成员将被假定为私有成员；
- 保护成员函数变量或函数与私有成员十分相似，但是保护成员在派生类（子类）中是可以访问的；

**类的特殊函数**

**构造函数：**

类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回void。

**析构函数：**

类的析构函数是类的一种特殊成员函数，它会在每次删除对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了一个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序前释放资源。

```cpp
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();  // 这是构造函数
      Line(double len);  // 这是带参数的构造函数
      ~Line();  // 这是析构函数声明
 
   private:
      double length;
};
 
// 成员函数定义，包括构造函数
Line::Line(void)
{
    cout << "Object is being created" << endl;
}
 
Line::Line( double len)
{
    cout << "Object is being created, length = " << len << endl;
    length = len;
}
 
Line::~Line(void)
{
    cout << "Object is being deleted" << endl;
    delete ptr;
}
```

**拷贝构造函数**

拷贝构造函数是一种特殊的构造函数，通常用于：通过使用另一个同类型的对象来初始化新创建的对象。

```cpp
class Line
{
   public:
      int getLength( void );
      Line( int len );             // 简单的构造函数
      Line( const Line &obj);      // 拷贝构造函数
      ~Line();                     // 析构函数
 
   private:
      int *ptr;
};
 
Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}
```

**友元函数：**

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是**友元函数不是成员函数**。

```cpp
class Box
{
   double width;
public:
   friend void printWidth( Box box );
   void setWidth( double wid );
};
 
// 请注意：printWidth() 不是任何类的成员函数
void printWidth( Box box )
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
```

**this指针：**

在C++中，每个对象都能通过this指针来访问自己的地址。this指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

```cpp
class Box{
    public:
        Box(){;}
        ~Box(){;}
        Box* get_address()   //得到this的地址
        {
            return this;
        }
        double Volume()
        {
            return length * breadth * height;
        }
        int compare(Box box)
        {
            //指针通过->访问类成员，对象通过.访问类成员
            return this->Volume() > box.Volume();
        }
};
```

友元函数没有this指针，因为友元不是类的成员。只有成员函数才有this指针。



**指向类的指针：**

```cpp
int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // Declare box1
   Box Box2(8.5, 6.0, 2.0);    // Declare box2
   Box *ptrBox;                // Declare pointer to a class.    
                               // 其中ptrBox为地址，*表示从其地址取值
 
   // 保存第一个对象的地址
   ptrBox = &Box1;
 
   // 现在尝试使用成员访问运算符来访问成员
   cout << "Volume of Box1: " << ptrBox->Volume() << endl;
 
   // 保存第二个对象的地址
   ptrBox = &Box2;
 
   // 现在尝试使用成员访问运算符来访问成员
   cout << "Volume of Box2: " << ptrBox->Volume() << endl;
  
   return 0;
}
```

**类的静态成员：**

使用static关键字来把类成员定义为静态的。静态成员在类的所有对象中是共享的，当我们声明类的成员为静态，这意味着无论创建多少个类的对象，静态成员都只有一个副本；

在创建第一个对象时，所有的静态数据都会初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符::来重新声明静态变量从而对它进行初始化。

```cpp
class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"Constructor called." << endl;
         length = l;
         breadth = b;
         height = h;
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};
 
// 初始化类 Box 的静态成员
int Box::objectCount = 1;
```

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。



**数据抽象与封装：**

数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制，是一种依赖于接口实现分离的设计技术。

数据封装是一种把数据和操作数据的函数捆绑在一起的机制。

```cpp
#include <iostream>
using namespace std;
 
class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};
int main( )
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);
 
   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
```

**数据抽象的好处**

- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
- 类实现可能随着时间的推移而发生变化，数据抽象可以更好的去应对不断变化的需求。



接口描述了类的行为和功能，而不需要完成类的特定实现。**如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。**

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
      
      // pure virtual function
      virtual int area() = 0;
};
```

设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。可用于实例化对象的类被称为具体类。

**继承**

一个类可以派生多个类，它可以从多个基类继承数据和函数

```cpp
class derived-class: access-specifier base-class
 
//例如
#include <iostream>
 
using namespace std;
 
// 基类 Shape
class Shape 
{
   public:
      void setWidth(int w)
      {
         width = w;
      }
      void setHeight(int h)
      {
         height = h;
      }
   protected:
      int width;
      int height;
};
 
// 基类 PaintCost
class PaintCost 
{
   public:
      int getCost(int area)
      {
         return area * 70;
      }
};
 
// 派生类
class Rectangle: public Shape, public PaintCost
{
   public:
      int getArea()
      { 
         return (width * height); 
      }
};
 
int main(void)
{
   Rectangle Rect;
   int area;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
 
   area = Rect.getArea();
   
   // 输出对象的面积
   cout << "Total area: " << Rect.getArea() << endl;
 
   // 输出总花费
   cout << "Total paint cost: $" << Rect.getCost(area) << endl;
 
   return 0;
}
```

派生类可以访问基类中的所有非私有成员，同时一个派生类继承了所有的基类方法，但是下列情况除外：

- 基类的构造函数、析构函数、拷贝构造函数；
- 基类的重载运算符；
- 基类的友元函数；



**多态**

**虚函数**

虚函数是在基类中使用关键字`virtual` 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，而是动态链接或者后期绑定。

C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；

```cpp
#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
 
   // 存储矩形的地址
   shape = &rec;
   // 调用矩形的求面积函数 area
   shape->area();  //Rectangle class area
 
   // 存储三角形的地址
   shape = &tri;
   // 调用三角形的求面积函数 area
   shape->area();  //Triangle class area
   
   return 0;
}
```

若在基类中不能对虚函数给出有意义的实现，这个时候就会使用纯虚函数，在函数参数后直接加=0告诉编译器，函数没有主体，这种虚函数是纯虚函数。

### 相关面试题Ⅴ



Q：C++中的struct和class的区别？

A：struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。它们最本质的一个区别就是：struct访问权限默认是public的，class默认是private；



Q：析构函数是否需要是虚函数？

A：只有当一个类需要当作父类时，才将它的析构函数设置为虚函数。

1. 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏；
2. C++默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存；



Q：C++中析构函数的特点？

A：

- 当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数；
- 析构函数名与类名相同，只是在函数前面加一个位取反符~，只能有一个析构函数，不能重载；
- 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数；
- 如果一个类中有指针，且在使用过程中动态申请内存，那么最好显示构造析构函数。在销毁类前释放掉申请的内存，避免内存泄漏；
- 类析构顺序：1.派生类本身的析构函数；2.对象成员的析构函数；3.基类析构函数；





Q：静态函数和虚函数的区别？

A：

- 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候进行动态绑定；
- 虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销；



Q：举例必须使用成员初始化列表的场合？

A：初始化列表的好处：少了一次调用默认析构函数的过程，提高了效率；

- 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
- 引用类型，引用必须在定义的时候就初始化，并且不能重新赋值，所以也要写在初始化列表里面；
- 没有默认的构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化；



Q：面向对象三大特征？

A：

- 封装：把数据和操作绑定在一起封装成抽象的类，仅向用户暴露接口，而对其隐藏具体实现，以此避免外界干扰和不确定性访问；
- 继承：让某种类型对象获得另一个类型对象的属性和方法，提高了代码的可维护性；
- 多态：让同一事物体现不同事物的状态，提高了代码的扩展性；



Q：C++多态分类及实现？

A：

- 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载（静态多态）；
- 子类型多态（Subtype Polymorphism，运行期）：虚函数（动态多态）；
- 参数多态（Parametric Polymorphism，编译期）：类模板、函数模板；
- 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换；



Q：**C++中多态是怎么实现的？**

A：多态是面向对象的重要特性之一，是一种行为封装，不同对象对同一行为有不同状态。多态是以封装和继承为基础的，在C++中多态分为静态多态和动态多态，静态多态通过函数重载实现，动态多态通过虚函数实现。

**静态多态**：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

**动态多态**：动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。每一个类都会有一个虚函数表。

实现动态多态需要虚函数，需要条件有

- 在类中声明为虚函数

- 函数的函数名，返回值，函数参数个数，参数类型，全都与基类的所声明的虚函数相同(否则是函数重载的条件)

- 将子类对象的指针(或以引用形式)赋值给父类对象的指针(或引用)，再用该指向父类对象的指针(或引用)调用虚函数

  



Q：父类写了一个virtual函数，如果子类重写虚函数不加virtual，能实现多态吗？

A：能的，virtual修饰符会隐形继承，可加可不加；





Q：虚表指针、虚函数指针和虚函数表？

A：

- 虚表指针：在含有虚函数的类的对象中，指向虚函数表的指针，在运行时确定；
- 虚函数指针：指向虚函数的地址的指针；
- 虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建；



Q：简单描述虚继承与虚基类？

A：

定义：在C++中，在定义公共基类A的派生类B、C...的时候，如果在继承方式前使用关键字virtual对继承方式限定，这样的继承方式就是虚拟继承，公共基类A成为虚基类。这样，在具有公共基类的、使用了虚拟继承方式的多个派生类B、C...的公共派生类D中，该基类A的成员就只有一份拷贝；

作用：一个类有多个基类，这样的继承关系称为多继承。在多继承的情况下，如果不同基类的成员名称相同，匹配度相同，则会造成二义性。为了避免多继承产生的二义性，在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只有包含一份虚基类的成员。



Q：抽象类、接口类、聚合类？

A：

- 抽象类：含有纯虚函数的类；
- 接口类：仅含有纯虚函数的抽象类；
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：1.所有成员都是public；2.没有定义任何构造函数；3.没有类内初始化；4.没有基类；5.没有virtual函数；



Q：如何定义一个只能在堆上（栈上）生成对象的类？

A：

- 只能在堆上
  - 方法：将析构函数设置为私有；
  - 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。
- 只能在栈上
  - 方法：将new 和delete重载为私有；
  - 原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。



Q：构造函数是否可以用private修饰，如果可以，会有什么效果？

A：如果一个类的构造函数只有一个且为private：

- 可以编译通过；
- 如果类的内部没有专门创建实例的代码，则是无法创建任何实例的；
- 如果类的内部有专门创建实例的代码，则只能创建一个或多个实例（根据类内部声明的成员对象个数来定）；
- private构造函数如果参数为void（无参），则子类无法编译；



Q：子类的指针能否转换为父类的指针？父类指针能否访问子类成员？

A：首先明确，当一个父类指针指向子类对象时是安全的，但只能访问从父类继承的成员；然后当一个子类指针指向父类对象时，因为可能调用父类不存在的方法，所以是不安全的，会爆语法错误。

- 当自己的类指针指向自己类的对象时，无论调用的是虚函数还是实函数，其调用的都是自己的；
- 当指向父类对象的父类指针被强制转换成子类指针时，也就是子类指针指向父类对象，此时，子类指针调用函数时，只能非重写函数是自己的，虚函数是父类的；
- 当指向子类对象的子类指针被强制转换成父类指针时，也就是父类指针指向子类对象，此时，父类指针调用的虚函数都是子类的，而非虚函数都是自己的。



Q：this指针？

A：this指针是一个隐含与每一个非静态成员函数中的特殊指针，它指向调用该成员函数的对象的首地址。

- 当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针；
- this指针被隐含地声明为： ClassName *const this ， 这意味着不能给this指针赋值；
- this是一个右值，所以不能取this的指针；



Q：delete this

A：

- 类的成员函数中可以调用delete this，但是释放后，对象后续调用的方法不能再用到this指针；
- delete this 释放了类的对象的内存空间，但是内存空间却并不是马上被回收到系统中，此时其中的值是不确定的；
- delete的本质是为将被释放的内存调用一个或多个析构函数，如果在类的析构函数中调用delete this，会陷入无限递归，造成栈溢出；



Q：一个空类class中有什么？

A：构造函数、拷贝构造函数、析构函数、赋值运算符重载、取地址操作符重载、被const修饰的取地址操作符重载；



Q：C++计算一个类的sizeof ？

A：

- 一个空的类sizeof返回1，因为空类也要实例化，所谓类的实例化就是在内存中分配一块地址；
- 类内的普通成员函数不参与sizeof的统计，因为sizeof是针对实例的，而普通成员函数，是针对类体的；
- 一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针，占4个字节；
- 静态成员不影响类的大小，被编译器放在程序的数据段中；
- 普通继承的类sizeof，会得到基类的大小加上派生类自身成员的大小；
- 当存在虚拟继承时，派生类中会有一个指向虚基类表的指针。所以其大小应为普通继承的大小，再加上虚基类表的指针大小。



Q：构造函数和析构函数能被继承吗？

A：不能。构造函数和析构函数是用来处理对象的创建和析构的，它们只知道对它们的特殊层次的对象做什么。



Q：构造函数能不能是虚函数？

A：不能，虚函数对应一个虚函数表，可是这个虚函数表存储在对象的内存空间的。问题就在于，如果构造函数是虚的，就需要通过虚函数表来调用，可以对象还没有实例化，也就是内存空间还没有，就不会有虚函数表。



Q：构造函数和析构函数能不能被重载？

A：构造函数可以被重载，析构函数不能被重载。因为构造函数可以有多个且可以带参数，而析构函数不能带参数，且只有一个。



Q：构造函数调用顺序，析构函数呢？

A：基类的构造函数——成员类对象的构造函数——派生类的构造函数；析构函数相反。



Q：构造函数和析构函数调用时机？

A：

- 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数；
- 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数；
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数；
- 静态局部变量对象：建立对象时调用构造函数，在主函数结束时调用析构函数；



Q：拷贝构造函数中深拷贝和浅拷贝的区别？

A：

- 深拷贝会先申请一块和拷贝数据一样大的内存空间，然后将数据逐字节拷贝过去，拷贝后两个指针指向不同的两个内存空间；
- 浅拷贝仅是拷贝指针地址，拷贝后两个指针指向同一个内存空间；

当浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针，因为所指向的内存空间已经被释放了。



Q：拷贝构造函数在什么时候会被调用？

A：

- 当用类的一个对象去初始化该类的另一个对象（或引用）时系统自动调用拷贝构造函数实现拷贝赋值；
- 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数；
- 当函数的返回值是类对象时，系统自动调用拷贝构造函数；
- 需要产生以恶搞临时类对象时。



Q：什么时候必须重写拷贝构造函数？

A：当构造函数涉及到动态内存分配时，要自己写拷贝构造函数，并且要深拷贝；



Q：什么是常对象？

A：常对象是指在任何场合都不能对其成员的值进行修改的对象；



Q：面向过程编程和面向对象编程的区别？

A：

- 面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现；
- 面向对象：面向对象就是一种对现实世界理解和抽象的方法，强调的是通过需求要素转化为对象进行问题处理的一种思想；



Q：为什么内联函数、构造函数、静态成员函数不能为virtual函数？

A：

- 内联函数：内联函数是在编译时期展开，而虚函数的特性是运行时才动态联编，所以二者矛盾，不能定义内联函数为虚函数；
- 构造函数：构造函数用来创建一个新对象，而虚函数的运行是建立在对象的基础上，在构造函数执行时，对象尚未形成，所以不能将构造函数定义为虚函数；
- 静态成员函数：静态成员函数属于一个类而非某一对象，没有this指针，所以无法进行对象的判别；
- 友元函数：C++不支持友元函数的继承，所以没有继承性的函数就没有虚函数；



Q：如何定义和实现一个类的成员函数为回调函数？

A：所谓的回调函数，就是预先在系统的对函数进行注册，让系统知道这个函数的存在，以后当某个事件发生时，再调用这个函数对事件进行响应。定义一个类的成员函数时在该函数前加上CALLBACK即将其定义为回调函数，函数的实现和普通成员函数没有区别。



### C++动态内存：

C++程序中的内存分为两个部分：

- 栈：在函数内部声明的所有变量都将占用栈内存；
- 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存；

new和delete运算符：

分配堆内存：new ； 删除堆内存： delete

```cpp
#include <iostream>
using namespace std;
 
int main ()
{
   double* pvalue  = NULL; // 初始化为 null 的指针
   pvalue  = new double;   // 为变量请求内存
 
   *pvalue = 29494.99;     // 在分配的地址存储值
   cout << "Value of pvalue : " << *pvalue << endl;
 
   delete pvalue;         // 释放内存
 
   return 0;
}
```



动态内存分配：

对象的动态内存分配：

```cpp
#include <iostream>
using namespace std;
 
class Box
{
   public:
      Box() { 
         cout << "调用构造函数！" <<endl; 
      }
      ~Box() { 
         cout << "调用析构函数！" <<endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray; // 删除数组
   return 0;
}
```

如果要为一个包含四个Box对象的数组分配内存，构造函数将被调用4次，同样地，当删除这些对象时，析构函数也将被调用相同的次数。



### 相关面试题Ⅵ



Q：new/delete具体步骤？

A：使用new操作符来分配对象内存时会经历三个步骤：

1. 调用operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象；
2. 编译器运行相应的构造函数以构造对象，并为其传入初值；
3. 对象构造完，返回一个指向该对象的指针；



Q：new/delete与malloc/free的区别是什么？

A：

- malloc/free是C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存；
- malloc/free不会去自动调用构造和析构函数，对于基本数据类型的对象而言，光用malloc/free无法满足动态对象的要求；
- malloc/free需要指定分配内存的大小，而new/delete会自动计算所需内存大小；
- new返回的是指定对象的指针，而malloc返回的是*void，因此malloc的返回值一般都需要进行强制类型转换。



Q：C++内存管理？

A：在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、栈区以及文件映射区六部分。

- 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码；
- 数据段：存储程序中已初始化的全局变量和静态变量；
- BSS段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量；
- 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存；
- 映射区：存储动态链接库以及调用mmap函数进行的文件映射；
- 栈区：使用栈空间存储函数的返回地址、参数、局部变量、返回值



Q：内存的分配方式？

A：内存分配方式有三种：

- 静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量；
- 栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限；
- 堆上分配，也称动态分配，比如使用new/malloc来分配内存，使用delete/free来释放内存；



Q：内存池是什么东西？

A：内存池是一种内存分配方式。通常我们习惯直接使用new，malloc申请内存，这样做的缺点在于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的显著优点就是使得内存分配效率得到提升。



Q：内存泄漏是什么东西？

A：内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那一块内存不能被再次使用。内存泄漏并不是指内存从物理上消失，而是指程序在运行的过程中失去了对该内存的控制，从而造成内存的浪费。使用malloc、new等分配内存要相应调用free或delete来进行释放内存。



Q：C++中的不安全是什么概念？

A：C++中的不安全包括以下两种：1.程序得不到正确的结果；2.发生不可预知的错误（占用了不该用的内存空间）。可能会发生如下问题：

- 最严重的：内存泄漏、程序崩溃；
- 一般严重的：发生一些逻辑错误，且不方便调试；
- 轻微的：丢失部分数据，就像强制转换一样；



Q：内存中的堆与栈有什么区别？

A：

- 申请方式：栈由系统自动分配和管理，堆由程序员手动分配和管理；
- 效率：栈由系统分配，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行，因此，其速度快，不会有内存碎片；堆由程序员分配，堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低，可能由于操作不当产生内存碎片；
- 扩展方向：栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展；
- 程序局部变量是使用的栈空间，new/malloc动态折你去哪个的内存是堆空间；同时，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间；



### C++STL库（标准模板库）

STL（Standard Template Library ），即标准模板库，具有工业强度的，高效的C++程序库：

STL包括六大组件：容器、迭代器、算法、仿函数、迭代适配器、空间配置器；

**容器**

序列式容器：vector、deque、list

关联式容器：map、set

容器适配器：queue、stack



**vector**

```cpp
//需要包含头文件
#include <vector>
 
//1.定义和初始化
vector<int> vec1;    //默认初始化，vec1为空
vector<int> vec2(vec1);  //使用vec1初始化vec2
vector<int> vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2
vector<int> vec4(10);    //10个值为0的元素
vector<int> vec5(10,4);  //10个值为4的元素
 
//2.常用操作方法
//2.1 添加函数
vec1.push_back(100);            //尾部添加元素
vec1.insert(vec1.end(),5,3);    //从vec1.back位置插入5个值为3的元素
 
//2.2 删除函数
vec1.pop_back();              //删除末尾元素
vec1.erase(vec1.begin(),vec1.begin()+2);  //删除vec1[0]-vec1[2]之间的元素，不包括vec1[2]其他元素前移
vec1.clear();                 //清空元素，元素在内存中并未消失，通常使用swap()来清空
vector<int>().swap(V);        //利用swap函数和临时对象交换内存，交换以后，临时对象消失，释放内存。
 
//2.3 遍历函数
vec1[0];        //取得第一个元素
vec1.at(int pos);     //返回pos位置元素的引用
vec1.front();  //返回首元素的引用
vec1.back();  //返回尾元素的引用
vector<int>::iterator begin= vec1.begin();  //返回向量头指针，指向第一个元素
vector<int>::iterator end= vec1.end();  //返回向量尾指针，指向向量最后一个元素的下一个位置
vector<int>::iterator rbegin= vec1.rbegin();  //反向迭代器，指向最后一个元素
vector<int>::iterator rend= vec1.rend();  //反向迭代器，指向第一个元素之前的位置
 
//2.4 判断函数
bool isEmpty = vec1.empty();    //判断是否为空
 
//2.5 大小函数
int size = vec1.size();  //元素个数
vec1.capacity();  //返回容器当前能够容纳的元素个数
vec1.max_size();  //返回容器最大的可能存储的元素个数
 
//2.6 改动函数
vec1.assign(int n,const T& x);  //赋n个值为x的元素到vec1中，这会清除掉vec1中以前的内容。
vec1.assign(const_iterator first,const_iterator last);  //当前向量中[first,last)中元素设置成迭代器所指向量的元素，这会清除掉vec1中以前的内容。
```



**deque**

deque是double ended queue 的缩写，双向队列

```cpp
#include <deque>  // 头文件
 
//1.声明和初始化
deque<type> deq;  // 声明一个元素类型为type的双端队列que
deque<type> deq(size);  // 声明一个类型为type、含有size个默认值初始化元素的的双端队列que
deque<type> deq(size, value);  // 声明一个元素类型为type、含有size个value元素的双端队列que
deque<type> deq(mydeque);  // deq是mydeque的一个副本
deque<type> deq(first, last);  // 使用迭代器first、last范围内的元素初始化deq
 
//2.常用成员函数
deq[index];  //用来访问双向队列中单个的元素。
deq.at(index);  //用来访问双向队列中单个的元素。
deq.front();  //返回第一个元素的引用。
deq.back();  //返回最后一个元素的引用。
deq.push_front(x);  //把元素x插入到双向队列的头部。
deq.pop_front();  //弹出双向队列的第一个元素。
deq.push_back(x);  //把元素x插入到双向队列的尾部。
deq.pop_back();  //弹出双向队列的最后一个元素。
```



**list**

双向链表

```cpp
#include <list>
 
//1.定义和初始化
list<int>lst1;          //创建空list
list<int> lst2(5);       //创建含有5个元素的list
list<int>lst3(3,2);  //创建含有3个元素值为2的list
list<int>lst4(lst2);    //使用lst2初始化lst4
list<int>lst5(lst2.begin(),lst2.end());  //同lst4
 
//2.常用操作函数
lst1.assign(lst2.begin(),lst2.end());  //给list赋值为lst2
lst1.back(); //返回最后一个元素 
lst1.begin();  //返回指向第一个元素的迭代器 
lst1.clear();  //删除所有元素 
lst1.empty();  //如果list是空的则返回true 
lst1.end();  //返回末尾的迭代器 
lst1.erase();  //删除一个元素 
lst1.front();  //返回第一个元素 
lst1.insert();  //插入一个元素到list中 
lst1.max_size();  //返回list能容纳的最大元素数量 
lst1.merge();  //合并两个list 
lst1.pop_back();  //删除最后一个元素 
lst1.pop_front();  //删除第一个元素 
lst1.push_back();  //在list的末尾添加一个元素 
lst1.push_front();  //在list的头部添加一个元素 
lst1.rbegin();  //返回指向第一个元素的逆向迭代器 
lst1.remove();  //从list删除元素 
lst1.remove_if();  //按指定条件删除元素 
lst1.rend();  //指向list末尾的逆向迭代器 
lst1.resize();  //改变list的大小 
lst1.reverse();  //把list的元素倒转 
lst1.size();  //返回list中的元素个数 
lst1.sort();  //给list排序 
lst1.splice();  //合并两个list 
lst1.swap();  //交换两个list 
lst1.unique();  //删除list中相邻重复的元素
```



**map**

map内部自建一个红黑树（一种非严格意义上的平衡二叉树），这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

```cpp
#include <map>
 
//1.定义与初始化
map<int, string> ID_Name;
// 使用{}赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012
map<int, string> ID_Name = {{ 2015, "Jim" },{ 2016, "Tom" },{ 2017, "Bob"}};
 
//2.基本操作函数
count()         //返回指定元素出现的次数
find()          //查找一个元素
get_allocator() //返回map的配置器
key_comp()      //返回比较元素key的函数
lower_bound()   //返回键值>=给定元素的第一个位置
upper_bound()    //返回键值>给定元素的第一个位置
value_comp()     //返回比较元素value的函数
map<int,string>::iterator iter_map = map1.begin();//取得迭代器首地址
int key = iter_map->first;             //取得key
string value = iter_map->second;       //取得value
```



**set**

集合，所有操作都是在logn时间内完成的。



### 相关面试题Ⅶ



Q：六大组件介绍？

A：

- 容器：数据结构，用来存放数据；

- 算法：常用算法；
- 迭代器：容器和算法之间的胶合剂，”范型指针“
- 仿函数：一种重载了operator（）的类，使得这个类的使用看上去像一个函数；
- 配置器：为容器分配并管理内存；
- 适配器：修改其他组件接口；



Q：STL常用的容器有哪些以及各自的特点是什么？

A：

- vector底层数据结构为数组，支持快速随机访问；
- list底层数据结构为双向链表，支持快速增删；
- deque底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问；
- stack底层一般用deque/list实现，封闭头部即可，不用vector的原因为容量大小有限制，扩容耗时；
- queue底层一般用deque/list实现，封闭头部即可，不用vector的原因如上；
- priority_queue底层数据结构一般为vector，堆heap为处理规则来管理底层容器实现；
- set底层数据结构为红黑树，有序，不重复；
- multiset底层数据结构为红黑树，有序，可重复；
- unordered_set底层数据结构为hash表，无序，不重复；
- unordered_multiset底层数据结构为hash表，无序，可重复 。
- unordered_map底层数据结构为hash表，无序，不重复。
- unordered_multimap底层数据结构为hash表，无序，可重复。



Q：vector和list的区别？

A：

- vector底层实现是数组，所以在内存中是连续存放的，随机读取效率高，但插入、删除效率低；list底层实现是双向链表，所以在内存中是任意存放的，插入、删除效率高，但是访问元素效率低；
- vector在中间节点进行插入，删除会导致内存拷贝，而list不会；
- vector一次性分配好内存，不够时再进行2倍扩容；list每次插入新节点都会进行内存申请；



Q：vector的扩容原理？

A：以原内存空间大小的两倍配置一份新的内存空间，并将原空间数据拷贝过来进行初始化；



Q：map和set有什么区别？

A：

- map中的元素是键值对；Set仅仅是关键字的简单集合；
- set的迭代器是const，不允许修改元素的值；map允许修改value，但不允许修改key；
- map支持用关键字作下标操作，set不支持下标操作；



Q：map和unordered_map的区别？

A：

- map：map内部实现了一个红黑树，红黑树的每一个节点都代表着map的一个元素，因此所有元素都是有序的，对其进行查找、插入、删除的效率都是O（logn）；但是，因为每个节点都需要额外保存数据，所以空间占用率比较高；
- unordered_map：内部实现了一个哈希表，因此内部元素是无序的，对其进行查找、插入、删除的效率都是O（1）；但是建立哈希表比较费时；



Q：STL中迭代器的作用，有指针为何还要迭代器？

A：

- Iterator（迭代器）模式又称为Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示；
- 迭代器不是指针，是类模板，表现得像指针，只是模拟了指针的一些功能，通过重载了指针的一些操作符，-> , * , ++ , -- 等，相当于一种智能指针；
- 迭代器产生的原因：Iterator采用的是面向对象的思想，把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果；



### C++异常处理

```txt
C++ 异常处理涉及到三个关键字：try、catch、throw。

throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。
catch: 在想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。
try: try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。它后面通常跟着一个或多个 catch 块。
```



**抛出异常**
可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

```cpp
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
```

**捕获异常**

```cpp
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

上面的代码会捕获一个类型为 ExceptionName 的异常。如果想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，例如：

```cpp
try
{
   // 保护代码
}catch(...)
{
  // 能处理任何异常的代码
}
```

**C++标准的异常**
C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDU5MzE3LWVhZTNiN2IxYWE2OGVhOGMucG5n?x-oss-process=image/format,png)



**定义新的异常**

可以通过继承和重载 exception 类来定义新的异常。

```cpp
#include <iostream>
#include <exception>
using namespace std;

struct MyException : public exception
{
  const char * what () const throw ()
  {
    return "C++ Exception";
  }
};

int main()
{
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的错误
  }
}
```



### C++重要设计模式

**单例模式**

保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。

实现方式：

单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。

默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的，这样禁止在类的外部创建该对象；
全局访问点也要定义成 静态类型的成员函数，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。

- 懒汉模式：直到第一次用到类的实例时才去实例化；（加锁）
- 饿汉模式：类定义的时候就实例化



#### 设计模式六大原则

- **单一职责原则：** 就一个类而言，应该仅有一个引起它变化的原因；
- **开放封闭原则：** 软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码；
- **里氏代换原则：** 一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化；
- **依赖倒转原则：** 抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要针对实现编程；
- **迪米特原则：** 如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用；
- **接口隔离原则：** 每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口；



总结：

- 开闭原则：实现热插拔，提高扩展性。
- 里氏代换原则：实现抽象的规范，实现子父类互相替换；
- 依赖倒转原则：针对接口编程，实现开闭原则的基础；
- 接口隔离原则：降低耦合度，接口单独设计，互相隔离；
- 迪米特法则，又称不知道原则：功能模块尽量独立；
- 合成复用原则：尽量使用聚合，组合，而不是继承；

#### 设计模式三大类

- **创造型模式：** 单例模式、工厂模式、建造者模式、原型模式；
- **结构型模式：** 适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式；
- **行为型模式：** 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式；

#### 常见的设计模式：

- **单例模式：** 保证一个类仅有一个实例，并提供一个访问它的全局访问点；
- **工厂模式：** 包括简单工厂模式、抽象工厂模式、工厂方法模式
  - **简单工厂模式：** 主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后不同类的虚函数得到不同的结果。
  - **工厂方法模式：** 修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。
  - **抽象工厂模式：** 定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。
- **观察者模式：** 定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己；
- **装饰模式：** 动态地给一个对象添加一些额外地职责，就增加功能来说，装饰模式比生成派生类更为灵活；







### C++语言特性总结

**左值与右值**

- 左值：指表达式结束后依然存在的持久对象。可以取地址，可以通过内置（不包含重载）&来获取地址，可以将一个右值赋给左值；

- 右值：表达式结束就不再存在的临时对象。不可取地址，不可以通过内置（不包含重载）&来获取地址。不能将任何值赋给右值；

- 函数返回值可以是左值，也可以是右值；

  ```cpp
  // x 是左值，666 为右值
  int x = 666;   // ok 
  int *y = x; // ok
  int *z = &666 // error
  666 = x; // error
  int a = 9; // a 为左值
  int b = 4; // b 为左值
  int c = a + b // c 为左值 , a + b 为右值
  a + b = 42; // error
  ```

  ```cpp
  int setValue()
  {
      return 6;
  }
  
  int global = 100;
  
  int& setGlobal()
  {
      return global;    
  }
  setValue() = 3; // error!
  setGlobal() = 400; // OK
  ```





switch里面不要定义变量，每个case的作用域是相互独立的，互不影响；





### 关键问题

**1.关键字static作用，变量加入static以后在内存中存储位置的变化。**

 static修饰局部变量时：①改变了其存储位置，存储在静态区；②同时改变了其生命周期，为整个源程序，因此它只被初始化一次，若没显式初始化则自动初始化为0。 

static修饰全局变量时：改变了其作用域，只可以被文件内所用函数访问。

static修饰函数时：改变了其作用域，只可被这一文件内的其它函数调用。

**2.malloc的底层是如何实现的？**

malloc函数的底层实现是操作系统有一个可用内存块连接成的空闲链表。调用malloc时，它将遍历该链表寻找足够大的内存空间，将该块一分为二（一块与用户申请的大小相等，另一块为剩下来的碎片，会返回链表），调用free函数时，内存块重现连接回链表；

若内存块过于琐碎无法满足用户需求，则操作系统会合并相邻的内存块。

**3.在1G内存的计算机中能否通过malloc申请大于1G的内存？为什么？**

可以。因为malloc函数是在程序的虚拟地址空间申请的内存，与物理内存没有直接的关系。虚拟地址与物理地址之间的映射是由操作系统完成的，操作系统可通过虚拟内存技术扩大内存。

**4.关键字volatile的作用是什么？给出三个不同例子？**

作用：告诉编译器不要去假设（优化）这个变量的值，每次使用都必须每次读取内存中的这个变量的值，而不是去使用保存在寄存器中的备份。

例子：

1. 并行设备的硬件寄存器（如：状态寄存器）
2. 一个中断服务子程序中会访问到的非自动变量
3. 多线程应用中被几个线程共享的变量

**5.关键字extern的作用是什么？**

用于跨文件引入全局变量，即在本文件引入一个已经在其他文件中定义的全局变量；

注意引用时不能初始化，如extern var，而不能是extern var = 0。

另外，函数默认是extern类型的，表明是整个程序（工程）可见的，加不加都一样。

**6.关键字register的作用是什么？使用时需要注意什么？**

- 作用：编译器会将register修饰的变量尽可能地放在CPU的寄存器中，以加快其存取速度，一般用于频繁使用的变量。

- 注意：register变量可能不存放在内存中，所以不能用&来获取该变量的地址；只有局部变量和形参可以作为register变量；寄存器数量有限，不能定义过多register变量。

  

- C++为什么有指针还要引用，为什么不和JAVA一样抛弃指针 

- delete和delete[]的区别 

- 虚函数是用来干嘛的？虚函数机制怎么实现的？虚表指针在内存中的存放位置？ 

- C++多态怎么理解？C++有哪些多态的典型例子？ 

- 叙述程序编译都包含哪些阶段，每个阶段干了什么？ 

- CMake是如何包含文件目录的 

- 全局变量和局部变量在什么地方？堆栈如何申请资源？ 

- C语言编译后的内存分布 

- 我连续调用同一个函数两次，他的局部变量初始化结果是否会一致？（函数调用的过程） 

- 你说静态局部变量存储在静态区，那么静态区的创建和消失是在什么时候? 

- 我在windows里面运行了多个进程，其中一个进程执行完了，他的静态区会如何处理？（多进程的内存管理问题） 

- 静态局部变量与局部变量的区别？为什么局部变量未定义时，每次初始化的结果是不确定的？是个真随机数还是个伪随机数？ 

- 嵌入式中栈的工作机制是什么？ 

- struct字节对齐了解么？ 

- 容器了解吗？vector实现的机制是怎么样的？ 

- 迭代器有了解吗？讲解一下你的理解 

- 内存分配函数了解么？如果系统中只有10K内存，而我要分配12K，能分配成功吗？如果能，那么将分配到的区域用memset进行初始化，会成功吗？ 



### STL库用法

#### vector

vector为可变长数组（动态数组），定义的vector的数组可以随时添加数值和删除元素。

**在局部区域中开vector数组，是在堆空间里面开的**

局部区域不可以开大长度数组，但是可以开大长度vector

```cpp
#include <vector>

int main(){
    // 1.一维初始化
    vector<int> a;
    vector<char> b;
    vector<ListNode*> c;
    
    // 2.指定长度和初始值的初始化
    vector<int> Ans(n);// Ans填充了n个0
    vector<int> Ans(n,1);// Ans填充了n个1
    
    // 3.初始化多元素
    vector<int> a{1,2,3,4,5};
    
    // 4.拷贝初始化
    vector<int> a(n+1,0);
    vector<int> b(a);
    
    // 5.二维初始化
    vector<int> v[5];//定义了一个第一维固定长度为5，第二维可变化的二维数组
    
    // 6.上述二维初始化可以进行的操作：
    v[1].push_back(2);
	v[2].push_back(3);
    
    // 7.初始化二维均可变长数组
    vector<vector<int>> v;
    
    // 8.定义行列长度固定n+1行m+1列的初始值为0
    vector<vector<int>> a(n+1,vector<int>(m+1,0));
    
}
```

方法函数：

| 代码                  | 含义                                                 |
| --------------------- | ---------------------------------------------------- |
| v.front()             | 返回第一个数据O(1)                                   |
| v.pop_back()          | 删除最后一个数据O(1)                                 |
| v.push_back(*element) | 在尾部加入一个数据O(1)                               |
| v.size()              | 返回实际数据个数（unsigned类型）O(1)                 |
| v.clear()             | 清楚元素个数O(N)，N为元素个数                        |
| v.resize(n,num)       | 改变数组大小为n，n个空间赋值为num，没有就默认赋值为0 |
| v.insert(it,x)        | 向任意迭代器it插入一个元素x，O(N)                    |
| v.erase(first,last)   | 删除【first，last)的所有元素，O(N)  左闭右开         |
| v.begin()             | 返回首元素的迭代器O(1)                               |
| v.end()               | 返回最后一个元素后一个位置的迭代器O(1)               |
| v.empty()             | 判断是否为空，为空返回true，反之返回false O(1)       |

用法：

```cpp
int main(){
    // 1.可以指定区间进行排序
    sort(v.begin(),v.end());
    sort(v.begin()+1,v.end());
    
    // 2.迭代器定义
    vector<int>::iterator it = v.begin();//声明一个迭代器指向vi的初始位置
    
    auto it =v.begin();
    
    // 3.迭代器遍历
    vector<int>::iterator it;
	for(it = vi.begin(); it != vi.end();it ++)
    cout << *it << " ";
    
    // 4.智能指针
    for(auto val:v){
        cout << val << " ";
    }
    
}
```

#### stack

先进后出，后进先出的容器

```cpp
#include <stack>
int main(){
    // 1.定义栈容器
    stack<int> stk;
    stack<string> stk;
    stack<ListNode*> stk;
    
    
}
```

方法函数：

| 代码              | 含义                              |
| ----------------- | --------------------------------- |
| stk.push(element) | 元素element入栈，增加元素O(1)     |
| stk.pop()         | 移除栈顶元素O(1)                  |
| s.top()           | 取得栈顶元素，但不删除O(1)        |
| s.empty()         | 检测栈内是否为空，空返回true O(1) |
| s.size()          | 返回栈内元素的个数O(1)            |

#### queue

队列，先进先出

```cpp
#include <queue>
int main(){
    queue<int> q;
    queue<ListNode*> q;
}
```

方法函数：

| 代码            | 含义                                            |
| --------------- | ----------------------------------------------- |
| q.front()       | 返回队首元素O(1)                                |
| q.back()        | 返回队尾元素O(1)                                |
| q.push(element) | 尾部添加一个元素element 进队O(1)                |
| q.pop()         | 删除第一个元素 出队O(1)                         |
| q.size()        | 返回队列中元素个数，返回值类型unsigned int O(1) |
| q.empty()       | 判断是否为空，为空返回true O(1)                 |

#### deque

首尾都可以插入和删除的队列称为双端队列

```cpp
#include <deque>
int main(){
    deque<int> dq;
}
```

方法函数：

| 代码                                | 含义                                            |
| ----------------------------------- | ----------------------------------------------- |
| push_back(x)/push_front(x)          | 把x插入队尾后/队首O(1)                          |
| back()/front()                      | 返回队尾/队首元素O(1)                           |
| pop_back()/pop_front()              | 删除队尾/队首元素O(1)                           |
| erase(iterator it)                  | 删除双端队列中的某一个元素                      |
| erase(iterator first,iterator last) | 删除双端队列中【first，last）中的元素，左闭右开 |
| empty()                             | 判断deque是否为空O(1)                           |
| size()                              | 返回deque的元素数量O(1)                         |
| clear()                             | 清空deque                                       |

deque可以进行排序：

```cpp
// 从小到大进行排序
sort(dq.begin(),dq.end());

// 从大到小排序
sort(dq.begin(),dq.end(),greater<int>());
sort(dq.begin(),dq.end(),greater());
```

#### priority_queue

优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。底层是通过堆来实现的。

```cpp
#include <queue>
int main(){
    priority_queue<int> pq;
}
```

函数方法：

| 代码                              | 含义                 |
| --------------------------------- | -------------------- |
| pq.top()                          | 访问队首元素         |
| pq.push()                         | 入队                 |
| pq.pop()                          | 堆顶（队首）元素出队 |
| pq.size()                         | 队列元素个数         |
| pq.empty()                        | 是否为空             |
| 优先队列没有clear()               | 不提供该方法         |
| 优先队列只能通过top()访问队首元素 | （优先级最高的元素） |

设置优先级：

```cpp
priority_queue<int> pq; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue<int, vector<int>, greater<int> > pq; // 小根堆, 每次取出的元素是队列中的最小值
```

参数：

- **第二个参数：**
  `vector< int >` 是用来承载底层数据结构堆的容器，若优先队列中存放的是`double`型数据，就要填`vector< double >`
  **总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。**

- **第三个参数：**
  `less< int >` 表示数字大的优先级大，堆顶为最大的数字
  `greater< int >`表示数字小的优先级大，堆顶为最小的数字
  **int代表的是数据类型，也要填优先队列中存储的数据类型**

- 第三个参数可以自定义排序：

  ```cpp
  struct cmp1
  {
      bool operator()(int x,int y)
      {
          return x > y;
      }
  };
  struct cmp2
  {
      bool operator()(const int x,const int y)
      {
          return x < y;
      }
  };
  priority_queue<int, vector<int>, cmp1> q1; // 小根堆
  priority_queue<int, vector<int>, cmp2> q2; // 大根堆
  ```


存储pair类型：默认先对pair的first进行降序排序，再对second进行降序排序

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    priority_queue<pair<int, int> >q;
    q.push({7, 8});
    q.push({7, 9});
    q.push(make_pair(8, 7));
    while(!q.empty())
    {
        cout << q.top().first << " " << q.top().second << "\n";
        q.pop();
    }
    return 0;
}

// 输出：
// 8 7
// 7 9
// 7 8
```

#### map(红黑树)

一个键对应一个值，和python的字典有点类似

红黑树是一个自平衡的二叉排序树：

特点如下：

- 每一个结点都有一个颜色，要么为红色，要么为黑色；
- 树的根结点为黑色；
- 树中不存在两个相邻的红色结点（即红色结点的父结点和孩子结点均不能是红色）；
- 从任意一个结点（包括根结点）到其任何后代 NULL 结点（默认是黑色的）的每条路径都具有相同数量的黑色结点。



map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小

```cpp
#include <map>
int main(){
    map<string,string> mp;
    map<string,int> mp;
    map<ListNode*,int> mp;
}
```

函数方法：

| 代码                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| mp.find(key)         | 返回键为key的映射的迭代器O(logN)。find函数定位数据，若存在，则返回一个迭代器，不存在，则返回mp.end() |
| mp.erase(it)         | 删除迭代器所对应的键和值O(1)                                 |
| mp.erase(key)        | 根据映射的键删除键和值O(logN)                                |
| mp.erase(first,last) | 删除左闭右开区间迭代器对应的键和值O(last-first)              |
| mp.size()            | 返回映射的对数O(1)                                           |
| mp.clear()           | 清空map中的所有元素O(N)                                      |
| mp.insert()          | 插入元素，插入时要构造键值对                                 |
| mp.empty()           | 如果map为空，则返回true，否则返回false                       |
| mp.begin()           | 返回指向map第一个元素的迭代器（地址）                        |
| mp.end()             | 返回指向map尾部的迭代器（最后一个元素的下一个地址）          |
| mp.rbegin()          | 返回指向map最后一个元素的迭代器地址                          |
| mp.rend()            | 返回指向map第一个元素前一个的逆向迭代器                      |
| mp.count(key)        | 查看元素是否存在，因为mao中键是唯一的，所以存在返回1，不存在返回0 |
| mp.lower_bound()     | 返回一个迭代器，指向键值>=key的第一个元素                    |
| mp.upper_bound()     | 返回一个迭代器，指向键值>key的第一个元素                     |

查找元素：

- mp.find()
- mp.count()
- mp[key]
- 第三种情况，如果不存在对应的key时，会自动创建一个键值对！！

插入方法：

```cpp
#include <map>
int main(){
    map<string,int> mp;
    mp['a']=1;
    mp['b']=3;
    mp.insert(make_pair("c",6));
    mp.insert(pair<string,string>("d",10));
    mp.insert({'e',29});
}
```

遍历：

```cpp
// 迭代器访问
for(it = mp.begin(); it != mp.end(); it++) {
    cout << it->first << " " << it->second 
}

// 智能指针访问
for(auto i:mp){
    cout << i.first << i.second << endl;
}

// 迭代器指定单个元素访问
map<char,int>::iterator it = mp.find('a');
cout<< it->first << it->second ;

// 新特性
for(auto [x,y]:mp){
    cout << x << y;
}
```

#### set

set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序（不重复，且有序）

```cpp
#include <set>
int main(){
    set<int> s;
    set<LisetNode*> ss;
}
```

方法和map差不多

排序改变：

```cpp
set<int> s1; // 默认从小到大排序
set<int, greater<int> > s2; // 从大到小排序
```

- `multiset`:元素可以重复，且元素有序
- `unordered_set` ：元素无序且只能出现一次
- `unordered_multiset` ： 元素无序可以出现多次



#### unordered_set

```cpp
#include <unordered_set>               

int main() {
    // 1. 初始化哈希集
    unordered_set<int> hashset;   
    // 2. 新增键
    hashset.insert(3);
    hashset.insert(2);
    hashset.insert(1);
    // 3. 删除键
    hashset.erase(2);
    // 4. 查询键是否包含在哈希集合中
    if (hashset.count(2) <= 0) {
        cout << "键 2 不在哈希集合中" << endl;
    }
    // 5. 哈希集合的大小
    cout << "哈希集合的大小为: " << hashset.size() << endl; 
    // 6. 遍历哈希集合
    for (auto it = hashset.begin(); it != hashset.end(); ++it) {
        cout << (*it) << " ";
    }
    cout << "在哈希集合中" << endl;
    // 7. 清空哈希集合
    hashset.clear();
    // 8. 查看哈希集合是否为空
    if (hashset.empty()) {
        cout << "哈希集合为空！" << endl;
    }
}
```

#### unordered_map（哈希表）

```cpp
#include <unordered_map>                

int main() {
    // 1. 初始化哈希表
    unordered_map<int, int> hashmap;
    // 2. 插入一个新的（键，值）对
    hashmap.insert(make_pair(0, 0));
    hashmap.insert(make_pair(2, 3));
    // 3. 插入一个新的（键，值）对，或者更新值
    hashmap[1] = 1;
    hashmap[1] = 2;
    // 4. 获得特定键对应的值
    cout << "The value of key 1 is: " << hashmap[1] << endl;
    // 5. 删除键
    hashmap.erase(2);
    // 6. 检查键是否存在于哈希表中
    if (hashmap.count(2) <= 0) {
        cout << "键 2 不在哈希表中" << endl;
    }
    // 7. 哈希表的大小
    cout << "哈希表的大小为: " << hashmap.size() << endl; 
    // 8. 遍历哈希表
    for (auto it = hashmap.begin(); it != hashmap.end(); ++it) {
        cout << "(" << it->first << "," << it->second << ") ";
    }
    cout << "在哈希表中" << endl;
    // 9. 清空哈希表
    hashmap.clear();
    // 10. 检查哈希表是否为空
    if (hashmap.empty()) {
        cout << "哈希表为空！" << endl;
    }
}
```

#### pair

pair只含有两个元素，可以看作是只有两个元素的结构体

应用：

- 代替二元结构体
- 作为map键值对进行插入

```cpp
#include<utility>
int main(){
    map<string,int>mp;
    mp.insert(pair<string,int>("cc",1));
    
    pair<string,int> p;
    pair<string,int> p("ccd",2);
    p={"dd",13};
    mp.insert(p);
}
```

#### string

string是一个字符串类，和char型字符串类似。

```cpp
//头文件
#include<string>

//1.
string str1; //生成空字符串

//2.
string str2("123456789"); //生成"1234456789"的复制品 

//3.
string str3("12345", 0, 3);//结果为"123" ，从0位置开始，长度为3

//4.
string str4("123456", 5); //结果为"12345" ，长度为5

//5.
string str5(5, '2'); //结果为"22222" ,构造5个字符'2'连接而成的字符串

//6.
string str6(str2, 2); //结果为"3456789"，截取第三个元素（2对应第三位）到最后
```

string可以拼接，通过+加号运算符进行拼接



C++ string和C-string的区别

- string 是C++的一个类，专门实现字符串的相关操作，数据类型为string，字符串结尾没有'\0' 字符
- C-string是C语言中的字符串，用char数组实现，类型为const char * ，字符串结尾以'\0' 结尾



c_str()可以实现string向char数组的转换

```cpp
string ss = "sdadasdasd";
char s2[] = ss.c_str();
```

函数方法：

**获取字符串长度**

| 代码                 | 含义                                                       |
| -------------------- | ---------------------------------------------------------- |
| s.size()和s.length() | 返回string对象的字符个数，二者执行效果相同                 |
| s.max_size()         | 返回string对象最多包含的字符数，超出会排除length_error异常 |
| s.capacity()         | 重新分配内存之前，string对象能包含的最大字符数             |

**插入元素**

| 代码                    | 含义                         |
| ----------------------- | ---------------------------- |
| s.push_back('a')        | 在末尾插入字符a              |
| s.insert(s.begin(),'1') | 在第一个位置插入字符1        |
| s.append('abc')         | 在s字符串末尾添加字符串”abc“ |

**删除元素**

| 代码                                | 含义                                            |
| ----------------------------------- | ----------------------------------------------- |
| erase(iterator p)                   | 删除字符串中p所指的字符                         |
| erase(iterator first,iterator last) | 删除字符串中迭代器区间【first，last）上所有字符 |
| erase(pos,len)                      | 删除字符串中从索引位置pos开始的len个字符        |
| clear()                             | 删除字符串中所有字符                            |

**字符替换**

| 代码                   | 含义                                                   |
| ---------------------- | ------------------------------------------------------ |
| s.replace(pos,n,str)   | 把当前字符串从索引pos开始的n个字符替换为str            |
| s.replace(pos,n,n1,c)  | 把当前字符串从索引pos开始的n个字符替换为n1个字符c      |
| s.replace(it1,it2,str) | 把当前字符串【it1，it2）区间替换为str it1，it2为迭代器 |

**大小写转换**

| 代码          | 含义       |
| ------------- | ---------- |
| tolower(s[i]) | 转换为小写 |
| toupper(s[i]) | 转换为大写 |



有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。

```cpp
string s;
transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写
transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写
```



**分隔字符串**

| 代码            | 含义                       |
| --------------- | -------------------------- |
| s.substr(pos,n) | 截取从pos索引开始的n个字符 |

**查找**

| 代码            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| s.find(str,pos) | 在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 |
| s.find(c,pos)   | 在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符 |

**排序**

```cpp
sort(s.begin(),s.end());
// 按ASCII码排序
```



#### 一些STL常用函数

atoi：将字符串转为int类型，只能转换char型数组

```cpp
string s = "1234";
int a = atoi(s.c_str());
cout << a << "\n"; // 1234
```



iota：让序列递增赋值

```cpp
vector<int> a(10);
iota(a.begin(), a.end(), 0);
for(auto i : a)
    cout << i << " ";
// 0 1 2 3 4 5 6 7 8 9
```



lower_bound + upper_bound

二分查找

```cpp
//在a数组中查找第一个大于等于x的元素，返回该元素的地址
lower_bound(a, a + n, x);
//在a数组中查找第一个大于x的元素，返回该元素的地址
upper_bound(a, a + n, x);

//如果未找到，返回尾地址的下一个位置的地址

```



*max_element + *min_element

```cpp
//函数都是返回地址，需要加*取值
int max_num = *max_element(a, a + n);
int min_num = *min_element(a, a + n);
int max_num = *max_element(res.begin(),res.end());
```



max + min

找多个元素的最大值和最小值

```cpp
//找a，b的最大值和最小值
mx = max(a, b);
mn = min(a, b);

//找到a,b,c,d的最大值和最小值
mx = max({a, b, c, d});
mn = min({a, b, c, d});
```



reverse

对序列进行翻转

```cpp
string s = "abcde";
reverse(s.begin(), s.end());//对s进行翻转
cout << s << '\n';//edcba

//对a数组进行翻转
int a[] = {1, 2, 3, 4};
reverse(a, a + 4);
cout << a[0] << a[1] << a[2] << a[3];//4321

```



sort

对一个序列进行排序

```cpp
//对a数组的[1,n]位置进行从小到大排序
sort(a + 1, a + 1 + n);

//对a数组的[0,n-1]位置从大到小排序
sort(a, a + n, greater<int>());
//对a数组的[0,n-1]位置从小到大排序
sort(a, a + n, less<int>());

//自定义排序，定义比较函数
bool cmp(node a,node b)
{
    //按结构体里面的x值降序排列
    return a.x > b.x;
}
sort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则
```



to_string

将数字转化为字符串，支持小数（double）

```cpp
int a = 12345678;
cout << to_string(a) << '\n';
```





## 12.C

**数据类型：**

数据类型的转换优先级：

char --> float --> short --> int --> double

![img](https://www.runoob.com/wp-content/uploads/2014/09/32-64.jpg)

存储0或1的最小单位叫做比特bit

一个字节（byte）为8个bit



**数据类型打印格式：**

| 打印格式 | 含义                                           |
| -------- | ---------------------------------------------- |
| %c       | 打印字符类型                                   |
| %s       | 打印字符串类型                                 |
| %d       | 打印整型                                       |
| %f       | 打印单精度浮点型（float）                      |
| %lf      | 打印双精度浮点型（double）                     |
| %p       | 打印地址类型                                   |
| %x       | 打印16进制数                                   |
| %o       | 打印8进制数                                    |
| %lu      | 打印 long int 【简写为long】数据类型           |
| %lld     | 打印 long long int 【简写为long long】数据类型 |



**printf格式化输出：**

```c
int a = 123, b = 1234567;
printf("%2d\n", a);
printf("%5d\n", a);
printf("%5d\n", b);
/*
123
  123
1234567
*/
// 不足m位的int变量以m位进行右对齐输出，高位用空格不起，如果本身超过m位，则保持原样

printf("%05d\n", a);
printf("%05d\n", b);
/*
00123
1234567
*/
// 当变量不足m位时，在前面补0

float y = 12.345;
    // %m.nf：m为指定的输出字段的宽度，n为小数点后保留n位
printf("x=%0.2f\n", y); // 输出结果：x=12.35
printf("x=%1.2f\n", y); // 输出结果：x=12.35
printf("x=%2.2f\n", y); // 输出结果：x=12.35
printf("x=%3.2f\n", y); // 输出结果：x=12.35
printf("x=%4.2f\n", y); // 输出结果：x=12.35
printf("x=%5.2f\n", y); // 输出结果：x=12.35
printf("x=%6.2f\n", y); // 输出结果：x= 12.35 注意有空格
// m为输出宽度，小数点也算宽度，如果大于m，则不用管，小于m则往最左边加空格


```



**ASCII值**

常用的

| 字符  | ASCII值 |
| ----- | ------- |
| A     | 65      |
| a     | 97      |
| 空格  | 32      |
| 换行  | 10      |
| 数字0 | 48      |
| 数字1 | 49      |



**变量命名规范：**

- 只能由 `字母、数字、下划线` 构成；
- `开头` 只能由字母、下划线构成；
- `关键字` 不能作为标识符



**关键字变量存储类型：**

auto、static、extern、register、const、volatile



1. auto

   声明变量的生存期为自动，即将不在任何类、结构、枚举、联合和函数中定义的变量视为全局变量，而在函数中定义的变量视为**局部变量**

   不怎么常用，在C++的威力更大，所以C++用的比较多

   

2. register

   命令编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问以提高效率。

   但是不能用指针进行寻址，因为它可能没有内存位置；

3. static

   - static存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
   - static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
   - static 是全局变量的默认存储类

4. extern

   - extern存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

   - 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。



**变量**

- C语言语法规定，变量要定义在当前代码块的最前面，C++突破了这个限制；
- 局部变量和全局变量的区别



**字符串：**

字符串是重点：

```c
char arr1[]="abcd";
char arr2[]={'x','y','z','\0'};
printf("%s\n",arr1);
printf("%s\n",arr2);
```



**数组：**

arr 和 &arr的区别：

- 都可以表示数组首元素的地址
- arr + 1 表示后移一个元素
- &arr + 1 表示后移整个数组长度



二维数组初始化可以省略行数，但不能省略列数



内存对齐







# 三.项目向：

## 1.基于FreeRTOS+STM32+Bluetooth的二轮自平衡小车

讲一下这个二轮自平衡小车？

这个二轮自平衡小车是22年暑假花了两个月左右的时间复现师兄师姐的项目再将它移植FreeRTOS实时操作系统里。实现的功能就是一个蓝牙遥控的二轮平衡小车。因为所需资源不是特别多，所以还是采用了STM32F103C8T6核心板作为硬件主控，然后把小车的程序以任务的形式分区，分别有测速任务，测压任务，姿态解算任务，pid调节任务，，蓝牙解析。主任务：喂狗、oled显示等等任务。任务本质就是线程，对于一些共享变量，采用互斥锁的形式，对于一些缓冲区而言，则采用信号量的方式来保障线程也就是FreeRTOS的task安全。然后代码的主要逻辑就是初始化硬件和hal库，获取MPU6050六轴数据，进行滤波处理，归一化等等，得到四元数以及欧拉角，然后对编码器进行计数，转换为速度，然后蓝牙解析，最后应用以上数据进行PID调节，并且限值输出相应的PWM波，修正误差，并进行OLED的显示。



说一下你这个PID调参？

说实话，前面硬件部分的搭建和程序部分的书写并不难，测试完一个又一个模块，成功后再把程序给整合起来。困难的是PID调参，理想态的调参肯定是matlab之类模拟出来，但是往往理想与实际相差很大，所以直接采用了实际调参法，每次参数的改变需要重复性的烧写，所以我把蓝牙遥控给改为蓝牙调参，在手机上控制kp，ki，kd这三个参数，这样就不用烧写去调参。然后PID算法比较简单，就是三环融合，直立环，速度环，转向环。第一个以当前角度和当前角速度为参数，进行角度为0的逼近调节。控制kp，kd参数。然后第二个以两个直流编码电机的速度为参数，控制kp，ki参数来使两轮差值逼近0.第三个就是以输入的蓝牙命令和z轴角速度为参数，进行kp，kd的调节。然后调节具体过程就是每个环在前一个环的基础上进行调节。

1. 介绍一下这个平衡小车？

   这个平衡小车使用STM32F103C8T6核心板作为硬件主控，使用FreeRTOS嵌入式系统作为软件控制，将在裸机上的程序按照功能分为不同的任务并划分不同的栈和优先级，完成对平衡小车的控制；

2. 小车硬件用了什么模块？

   STM32F103最小核心板、直流编码电机、MPU6050、TB6612电机驱动模块、DC降压模块、OLED屏等

3. 平衡小车用了什么技术栈？

   以STM32为硬件核心，FreeRTOS实时操作系统为软件核心，

4. 你说你用了FreeRTOS系统，来简单说一下在平衡小车里面怎么实现？（说一下你分的平衡小车的任务；）

   核心是将原有程序分为几大任务，分别是主任务，测速任务，测压任务，读取数据任务，运动控制任务。每个任务的大题逻辑就是具体逻辑代码加上绝对延时函数。主任务有喂狗、OLED屏显示等；测速任务有测量两个电机现在的速度；测压任务是通过ADC测算电池电压；读取数据任务就是陀螺仪和加速度计任务的读取及数据换算；运动控制就是通过PID调节PWM波的输出。

5. 你开发的时候遇到的难点是什么？

   - 硬件搭建；
   - 姿态解算；
   - PID调参：这个是最困难的，可能开发项目的主要时间都用在这个上面。其他东西都是分模块完成，只需要验证各个模块的正常，然后就可以搭建了。PID调节虽然是最简单的调节，但是实际操作起来还是有点难度。先是直立环、速度环和转向环。直立环的kp和kd调节到刚刚好的状态需要很有耐心的调，既不低频抖动，又不高频抖动，这是一个挑战；而且一开始的调参是那种串口修改重启来调，并没有引入蓝牙进行控制调参环节，最后也是加上了蓝牙模块，让调参更加地轻松；

6. 说一下你的蓝牙部分？

   蓝牙用的是低功耗模块，通过串口和单片机相连，使用dma的模式读取，不断去查询flag，若是手机通过蓝牙发送了消息，则发起中断，使flag=1；则下一次轮询时直接读取相应寄存器中的值，根据值直接修改pid的参数；蓝牙模块整个封装好了，并不需要去了解具体复杂的操作，直接操作串口即可。

7. 你任务中有出现线程通信的方式吗？如果没有，那你知道什么线程通信方式吗？

   我认为这个平衡小车每个都相当于是独立的模块，直接之间并没有影响或者需要同步互斥的程序，所以并没有用到线程通信的方式；但是还是了解一些线程通信方式的。比如消息队列（queue）、信号量（semaphore）、互斥量（mutex）、任务通知（task notification）、事件组（event group）等来实现同步互斥。

   - 消息队列（queue）：就一个队列，创建时要指定大小，然后FIFO，可以在任务与任务，任务与中断间传递消息；
   - 信号量（semaphore）：实现任务之间同步或临界资源的互斥访问；二值信号量：用于实现同步（任务之间或者任务与中断之间）。==初始化为0，为同步同步量；初始化为1，为互斥信号量==；
   - 互斥量（mutex）：特殊的信号量，==初始值为1==。它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界资源的独占式处理，是用于保护资源的互锁。**不能用于中断函数中**
   - 任务通知（task notification）：直接在任务TCB中，无需额外创建队列；
   - 事件组（event group）：32位的二进制，高八位不用，可以等待一个bit位或者多个bit位

8. 你的项目用到了FreeRTOS，请问你是用哪种方法对系统内存进行控制的？你对FreeRTOS的内存分配机制有什么了解？

   面试官你好，我这个平衡小车的项目使用了heap_4.c的分配方式，因为本身需要申请和释放内存，并且要避免严重的碎片化后果，所以选择heap_4.c。此外，我了解FreeRTOS的内存分配机制如下，FreeRTOS嵌入式实时操作系统的内存分配有5种方式，都是用`pvPortMalloc`和`vPortFree`分别在heap_1.c~heap_5.c；heap_1.c是用一个大数组分配空间，但是无法动态分配内存，无法释放内存；heap_2.c也是用一个大数组来分配空间，但是使用best fit最佳匹配算法（大于申请内存的最小内存）进行动态分配内存，会导致内存碎片化严重的问题,但是支持释放内存这一选择；heap_3.c是使用标准库函数`Malloc`和`Free` 来分配内存，Heap_3.c暂停FreeRTOS的调度器，实现了线程安全但是效率不高；heap_4.c也是使用大数组来进行分配内存，但是使用首次适应算法first fit来分配动态内存，并且还可以合并为一个更大的空闲内存，但是执行时间不确定，效率高于malloc和free；heap_5.c分配内存和释放内存和heap_4.c一样，但是它可以管理多块、分隔开的内存，对于某些内存地址不连续的嵌入式系统中十分适合使用，但是使用前需要进行初始化内存。

9. 平衡小车项目当时做了多久？

   当时是2022年暑假过后开学那一段时间，也就是9月左右开始做的，做了两个月左右；

10. 说一下平衡小车具体的代码流程？

11. 你开发是用什么语言？开发时有遇到什么坑吗？

    开发平衡小车这个项目使用的是纯C语言进行开发，开发主要是数据结构体的构建以及使用需要注意，其他还可以。

12. 这个项目是自己做的还是师兄师姐的项目拿过来改进的？

    因为师兄师姐也做过类似的项目，所以整理梳理一遍他们的项目，参考了他们的项目思路，并且做出自己的改变，引入了FreeRTOS实时嵌入式操作系统来实现程序功能。但主要是自己完成项目的大部分，包括硬件搭建和软件编写；其实硬件方面比较好解决，3D打印车模，然后就是飞线，也可以焊上排座。硬件的Pin脚记录下来，在文件中用宏定义的形式记录。软件部分就比较难了，还是分模块验证运作正常。然后分任务，这个项目就是把原来延时给分给各个任务来完成而已。然后滤波方面参考了师兄师姐，用巴特沃斯滤波和IIR滤波器；然后后面就是漫长的调PID环节了；

13. 代码主要逻辑？

    - 获取MPU6050的六轴数据；
    - 对获取的六轴数据进行处理，得到四元数以及欧拉角；
    - 获取编码器的计数值，然后转换为速度；
    - 对当前速度进行测速；
    - 然后PID调节，限值输出相应的PWM波；
    - 修正误差；
    - OLED的显示；

14. 什么是MPU6050？

    MPU6050内部整合了三轴MEMS陀螺仪、三轴MEMS加速度计以及一个可扩展的数字运动处理器DMP(Digital Motion Processor)，而且还可以连接一个第三方数字传感器(如磁力计)，这样的话，就可以通过IIC接口输出一个9轴信号(链接第三方数字传感器才可以输出九轴信号，否则只有六轴信号)。更加方便的是，有了DMP，可以结合InvenSense公司提供的运动处理资料库，实现姿态解算。通过自带的DMP，可以通过IIC接口输出9轴融合演算的数据，大大降低了运动处理运算对操作系统的负荷，同时也降低了开发难度。==其实，简单一句话说，陀螺仪就是测角速度的，加速度传感器就是测角加速度的，二者数据通过算法就可以得到PITCH、YAW、ROLL角了。==

15. MPU6050的读取与姿态解算？

    总结一下就是使用iic来读取MPU6050的六轴数据，分别是陀螺仪三轴数据（角速度值）和加速度计三轴数据（角加速度值）。然后角速度值转换为（rad/s为单位）与角加速度值（g为单位）一起参与姿态解算。先是二者归一化处理求单位向量，然后加速度三轴数据与上一次结果的余弦矩阵进行叉乘，并且对误差向量进行积分，然后一阶龙格库塔算法更新四元数，四元数归一化处理，套公式求解欧拉角。最后由四元数求解旋转矩阵及其转置矩阵，也是套公式，以备下一次姿态解算使用。

    

    或者：

    求解姿态角的方式有欧拉角法、方向余弦法、三角函数法、四元数法、旋转矢量法，然后说明四元数是一个超复数，其基本表现形式是Q=q0+q1i+q2j+q3k

    先用物理模型使用（方向余弦法）求解出物体坐标系与地理坐标系的变换矩阵将他们化成规范化四元数的格式（范数为1），然后也用欧拉角的方式建模求解出物理坐标系与地理坐标系的变换矩阵，最后从而推导出欧拉角，roll，pitch，yaw

    求解四元数，使用的是递归的思想，用微积分的方式以及陀螺仪检测到的三个方向角速度值求解出各个时刻的四元数，再用四元数来换算欧拉角（我们的地理坐标系）

    积分的消除（引入加速度计的数值，首先用加速度测得的值去求解姿态误差向量（归一化的值与重力分量叉乘），对误差积分，得到的值，再与角速度做互补滤波，最后修正角速度，以该角速度带入四元数的解微分方程中，得出正确的四元数）

    

16. 稍微讲一讲PID的控制？你实际开发中是怎么样选定这些参数的？

    要根据实际参数来调节PID，修正速度值。P提高响应速度，I用来减小静差，D用来抑制震荡。平衡小车有三个要调节，分别是直立环（PD控制），速度环（PI控制），转向环（PD控制）。开发中调参的顺序依次往下，先调直立环。首先是kp参数极性和大小，要调到低频振动的临界点，再调节kd来抑制震荡，调节到高频振动的临界点就可以了，此时的小车基本保持平衡，且对抖动十分敏感，此时将kp和kd都乘以0.6就是最后的直立环kp和kd参数；然后是速度环，主要是控制和调节两轮的速度差，根据经验公式ki参数大小为kp的1/200，可以微调。所以直接调节kp即可，但是速度环的控制不能影响直立环的控制，所以要加上低通滤波器实现，此时的低通滤波器可以简单化直接比率分配即可，减轻单片机负担和响应的速度；最后是转向环的控制，如果没有蓝牙WIFI的控制，一般只需要kd值即可，还是一样判断极性和大小，需要做到用手稍微旋转小车能感受到小车抗拒旋转的力。

17. 具体读取MPU6050原始数据怎么滤波，数据要经过什么处理？

iic通信获取陀螺仪三轴原始数据，并且使用低通滤波器——二阶巴特沃斯滤波器进行滤波，尽最大可能来消除数据抖动的影响。然后通过不同因子，将三轴原始数据转换为以度为单位的速率，以弧度为单位的速率。再通过iic获取加速度原始数据，IIR滤波器进行滤波，再将原始加速度转换为以重力加速度g为单位的数据。

18. 你在开发的时候有没有发现到FreeRTOS的一些特性？

- 傻逼的匈牙利命名法，需要一段时间才可以习惯，变量命名是类型前缀+变量名；函数命名是返回类型+定义文件+函数名；
- 两套API函数，一套在ISR中使用，一套在任务中使用；
- 优先级翻转：FreeRTOS本身并没有提供优先级继承机制或其他的避免优先级翻转的方法。

19. 你了解过RT-thread吗？能说一下，它和FreeRTOS的区别？

了解过，RT-thread和FreeRTOS都是嵌入式实时操作系统；

- 产地不同，一个是亚马逊公司开发，一个是熊谱翔团队开发；
- Real Time-Thread，它是一个嵌入式实时多线程操作系统，FreeRTOS也支持多线程，只不过线程这一概念变成了任务；
- RT-Thread提供了非常多的组件，尤其是IoT这方面的，大而全；而FreeRTOS没有配备这么多。
- FreeRTOS的内部API比RT-Thread丰富，但是FreeRTOS在中断中使用API还要判断一下任务切换；
- RT-Thread更像Linux，它的编程风格方式也类似Linux/Unix，还有虚拟文件系统、FinSH 命令行界面、 网络框架、设备框架

20. 卡尔曼滤波和二阶巴特沃斯滤波和IIR滤波？
    滤波这一块我知道一点原理，但是实际并不会过深去了解，术业有专攻，而且我是一个人完成一个项目的，所以怎么简单怎么来了。

21. CMSIS是什么？
    CMSIS（Cortex Microcontroller Software Interface Standard），$ARM Cortex^{TM}$ 微控制器软件接口标准。CMSIS向下负责与内核和各个外设直接打交道，向上提供实时操作系统用户程序调用的函数接口。

- 核内外设访问层：ARM公司提供的访问，定义处理器内部寄存器地址以及功能函数；

- 中间件访问层：由ARM公司提供的定义访问中间件的通用API；

- 外设访问层：定义硬件寄存器的地址以及外设的访问函数；
  ![img](https://img-blog.csdnimg.cn/20200429004851620.png)

  CMSIS就是定义了一套芯片外设控制及编写规范的标准。我们在移植一个新的工程时，只需要修改添加：

  1、添加system_stm32f4xx.c、startup_stm32f429xx.s、stm32f429xx_flash.icf

  2、添加stm32f4xx.h

  3、修改全局宏标识 STM32F429xx
  链接：http://t.csdn.cn/P3wen

22. bsp是什么？了解过吗？
    **board  support  package**板级支持包。要和Linux的bsp区分开来，Linux的bsp是Boot Strap Processor。负责系统引导启动。BSP就是介于主板硬件和操作系统之间的一层，应该说是属于操作系统的一部分,主要目的是为了支持操作系统，使之能够更好的运行于硬件主板上。BSP是相对于操作系统而言的，不同的操作系统对应于不同定义形式的BSP。bsp实际上是操作系统内部提供出来对接CMSIS层的，与硬件方面对接。hal库是硬件抽象层
23. ARM软件架构？
    用户层代码-->操作系统-->hal-->bsp-->CMSIS标准-->硬件寄存器
24. 项目软件架构？

    - 用户级代码：主要是Task或者具体的device代码，也就是项目开发主要干的事；
    - Middleware 中间件：由FreeRTOS提供的中间件，主要是任务、定时器、线程通信、内存分配、cmsis_os2等的文件，完成对系统的初始化或者使用；调用CMSIS的API来完成具体的操作；
    - CMSIS标准（微控制器软件接口标准）中间件访问层提供的CMSIS-RTOS API和CMSIS-Driver API给中间件使用；
    - RTOS内核层和Hal硬件抽象层：RTOS kernel操作bsp板级支持包和hal库对bsp再一次封装完成对硬件的控制；
    - CMSIS-CORE核内外设和外设层，操作各种硬件寄存器及其映射、准备启动文件等；
    - Cortex-M CPU core cpu内核及其外设
25. 说一下你的OLED那一块？
    OLED是有机发光二极管组成的屏幕，在正负极通上一定的电压就可以发光。OLED屏这里用到iic通信。单片机只需要通过IIC将数据写进OLED屏的SRAM中，刷新屏幕的事全部交给OLED的驱动芯片就可以。有一个需要注意的是，OLED有三种扫描方法：垂直扫描，水平扫描和页扫描，用不同的扫描方式所取的字模也不相同。默认是页扫描。

26. freertos的移植裁剪工作

freertos裁剪其实就是函数和一些变量、结构体等选择性的定义。通过裁剪来减少系统占用RAM和ROM的大小。裁剪就是条件编译的方法。许多RTOS系统都是采用这样的方法进行条件编译裁剪。

裁剪的核心在于配置FreeRTOSConfig.h文件的宏定义。

1. 内存管理，静态分配减少内核大小；动态分配灵活管理但是内存空间要更大；
2. 任务管理，使用哪些任务管理器，如果不需要延迟何以将延迟功能禁用；
3. 信号量和互斥量：不需要的话就禁用，因为会有额外的代码和数据结构会增加内核的大小；
4. 队列，使用简单的队列，那么就可以将复杂队列功能禁用以减少内核的大小；
5. 定时器，可以通过调整定时器的精度和分辨率来减小内核的大小。

其中钩子函数就是在内核代码插个占位，当执行到该位置时，执行用户自定义的功能函数，从而避免直接修改原始的内核代码。







## 2.智能元件管家

第三个项目，智能元件管家，这个项目是大二的时候和竞赛团队一起参加物联网比赛的时候开发的。基本功能就是，解决实验室和课堂的元器件的损耗问题。就是教师在排课出来之后，上传本课程每一段时间需要的元器件的数目类型清单到后台，然后后台自动下发命令到一个装置，就是类似贩卖机的那种，进行每种元器件的选用分发，然后打包，装在一个塑料盒里，将塑料盒存放在贩卖机内部，然后学生来领取只需要拿校卡进行领取即可。回收就是设计了一个振动盘加磁吸装置的，后期本来想用机器视觉，但是难度有点大，而振动盘＋磁吸的话，效果不太好，所以就这样了。然后我负责的部分是电机驱动和硬件上云。

1. 这个智能元件管家是什么样的？？

   简单来说就是从学校生活中的模电数电课中，了解到上课配套的器件时多时少，而且往往需要再找同学进行分配，这个是很麻烦的操作。所以基于此需求，我和我的三个队友设计了一款元件精细化管理的系统。它不是那种盒子固定死的，要提前分类分装的这种。而是有个入料和分料系统，通过老师课程要求的安排来进行分发。学生使用也方便，直接刷卡领取，装置会将元件分发装料好装进盒子，再像那种自动贩卖机一样交给学生。省去了人工分拣等麻烦。

   

2. 你怎么看待你自己这个项目？

   因为我本身是机械专业嘛，所以这个装置的机械笔墨有点多。而且亮点是杂乱元器件的分离没有做得很完美，所以得奖的奖项并不高，但是我觉得这个项目对我来说真的是一个挑战，更不用说组内还有个纯萌新的当时大一的学生。

   

3. 你在其中的分工是什么？

- 参与EMQX网站API与后端网络的连接；

- 硬件装置上云，利用ESP8266模块以MQTT协议的方式对接云端；

- 硬件与机械结构的配合，调试。

  

4. 项目的技术栈？

- MQTT服务；
- STM控制诸如步进电机，气泵（PWM电子开关），RFID识别模块等
- 网站前后端服务



5. 为什么采用这种技术？调查过其他的通信传输技术吗？比如zigbee，2G，5G等。。

物联网协议中，一般有两大类，一类是传输协议，一类是通信协议。传输协议负责子网内设备间的组网及通信；通信协议则主要在传统互联网TCP/IP协议上的设备通讯协议。

IOT通信协议：REST/HTTP、CoAP协议、MQTT协议、DDS协议（高可靠、实时）、AMQP协议（互操作性）、XMPP协议（即时通信）、JMS协议（消息队列）

项目预备是多个机器，像贩卖机一样，需要每个设备都上云，并且有数据上传和命令下发环节，对时间的要求不是很高，并且MQTT协议的实现比较简单，所以就选用了MQTT协议。

硬件支持是ESP8266、ESP01S

原本是想要通过EMQ源码或者Mosquitto在Linux服务器上搭建MQTT服务器的，但是搭建成功之后，总是会时不时出现连接失败，重启之后还是没有解决的问题，所以就直接用EMQX的限时体验服务器进行开发。



6. 你开发这个项目遇到的困难有什么？

- 第一步进电机驱动开发，项目需要通过老师导入的元气件表来控制步进电机，其中步进电机有驱动滚轮机构，有驱动传送带，有驱动剪刀机构，还有驱动气泵装置移动等，其中控制的量需要利用不同的函数式来进行开发。而且用的核心板的TIM明显不够，电机多了之后也驱动不足，所以用了两块板，用串口通信来实现通信。电机驱动也有个问题，步进电机一旦小幅高频率就容易发热，但有些数量的设置就得这样，所以装置散热也得考虑！
- 还有一个就是网络连接，当时申请不到2G模块，所以不得不采用MQTT协议。当时的想法是简单一个命令下发，有许多自动贩卖机同时工作，学生可以去不同地方去申领。所以通过搭建网络后台连接EMQX的API来控制上云的硬件设备。但是实际开发又遇到了个问题，就是测试时从EMQX下发的命令给单片机执行时，单片机会发生TIM脉冲来驱动步进电机的运行，此时再来一个命令，会出现命令接收不到的，接收过程被密集的定时器中断打断。第一个就想到了用修改优先级来实现，但是改了之后还是一样，后续回顾发现可能是收包没有受到影响，但是跳转函数去解包的时候，还是被TIM所打断，出现异常。所以还是遇事不决2，上位机解决。。。
- 开发中的噪音，发热问题，无法解决，尤其是步进电机驱动丝杠时，有一定载荷的时候，就一直搁那发出大的噪音，听到人实在难受。而且在正转后再反转这种稍微密集一点的操作就开始发热发烫。还好工作过程中并未有接触，倒也可以接受。



7. 工作流程图



8. 为什么项目中用步进电机？

呃，因为这个项目涉及到传送带和丝杠机械装置的驱动控制，需要的扭矩普通的直流电机远远达不上，所以选用了步进电机。而且步进电机可以很精准的控制旋转的方向和度数，丝杠运动也可以得到精确限位。







## 3.树莓派拍照上云传输

Linux环境下V4L2-API调取抓取摄像头照片并使用Socket-TCP传输照片

1. 项目是干什么的？

   这个项目在Linux环境下搭建了一个摄像头的应用程序，功能是实现照片的抓取以及图片的传输上云。

2. 分流程讲一讲

- 打开设备文件 /dev/video0。
- 设置摄像头采集格式，并向内核发送 VIDIOC_S_FMT 命令。
- 申请内核空间，用于存储采集到的图像数据，并向内核发送 VIDIOC_REQBUFS 命令。
- 将内核空间映射到用户空间，以便读取采集到的图像数据，并向内核发送 VIDIOC_QUERYBUF 和 VIDIOC_QBUF 命令。
- 向内核发送 VIDIOC_STREAMON 命令，开始采集图像数据。
- 从队列中提取一帧图像数据，并保存到文件中。
- 将已读取的缓冲区放回队列，并向内核发送 VIDIOC_QBUF 命令。
- 停止采集图像数据，向内核发送 VIDIOC_STREAMOFF 命令。
- 释放已映射的内核空间，使用 munmap 函数。
- 关闭设备文件。



Linux环境下V4L2-API调取抓取摄像头照片并使用Socket-TCP传输照片

智能安防方向的Linux交叉编译，识别人像报警发送信息，并且屋内响铃。



V4L2驱动框架

V4L2 (Video for Linux 2) 是Linux内核中一个视频设备驱动框架，它允许应用程序访问和控制各种视频设备，如摄像头、视频采集卡等。V4L2提供了一系列API函数，使开发人员可以编写程序来控制和操作视频设备。

V4L2的主要特点包括：

- 跨架构：V4L2的代码和API可以在各种架构的Linux设备上使用。
- 标准化：V4L2是Linux内核的一部分，因此是标准化的。这意味着应用程序可以在各种Linux平台上使用相同的API函数。
- 灵活性：V4L2支持多种视频设备，包括摄像头、视频采集卡、视频播放器等。它还支持多种视频格式和分辨率。
- 高性能：V4L2提供了许多高性能功能，如硬件加速、DMA传输等，可以帮助应用程序实现高效的视频处理。

V4L2是Linux系统中最常用的视频设备驱动框架之一，广泛应用于视频采集、视频监控、视频通信等领域。



V4L2是Linux内核中用于支持视频设备的框架，提供了一套API函数供应用程序与视频设备进行交互。下面介绍几个重要的V4L2 API函数：

```c
int ioctl(int fd, int request, void *arg)
```

该函数是Linux中的系统调用函数，可以实现设备的控制、传输数据等操作。V4L2使用该函数来与视频设备进行交互。

其中，

- fd参数为设备文件描述符，
- request参数表示要执行的操作（V4L2中定义了许多操作），
- arg参数则是传递给设备的参数。例如，可以使用VIDIOC_QUERYCAP操作获取设备的能力信息。

```c
int mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset){}
int mmap(映射地址NULL自动分配,映射长度,访问权限,标志位,文件描述符,内存偏移量){}
```

该函数用于内存映射，可以将一个文件映射到内存中，从而可以通过内存访问文件。V4L2中使用该函数将视频数据映射到应用程序的内存中。

其中，

- addr参数为映射的地址（如果为NULL则表示由系统自动分配），
- length参数为映射的长度，
- prot参数为访问权限，
- flags参数为标志位，
- fd参数为文件描述符，
- offset参数为偏移量。例如，可以使用mmap函数将视频帧数据映射到应用程序的内存中。

```c
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
```

该函数用于在一组文件描述符中等待事件的发生。在V4L2中，可以使用该函数等待视频设备的数据就绪（例如，一个视频帧已经被采集完成）。

其中，

- nfds参数为最大文件描述符值加1，
- readfds、writefds、exceptfds参数分别表示可读、可写、异常事件文件描述符集合，
- timeout参数为超时时间（如果为NULL则表示永久等待）。例如，可以使用select函数等待视频设备数据的就绪。

这些函数是V4L2中常用的API函数之一，掌握了这些函数的使用，就能够基本实现对视频设备的采集和处理。



**1.V4L2拍照，保存为my.jpg**

v4l2总代码(ioctl函数)

- 打开设备文件 /dev/video0。
- 设置摄像头采集格式，并向内核发送 VIDIOC_S_FMT 命令。设置视频格式，对应结构体为struct v4l2_format；
- 申请内核空间，用于存储采集到的图像数据，并向内核发送 VIDIOC_REQBUFS 命令。申请缓冲区，对应结构体为struct v4l2_requestbuffers；
- 将内核空间映射到用户空间，以便读取采集到的图像数据，并向内核发送 VIDIOC_QUERYBUF 查询缓冲区状态，对应结构体为struct v4l2_buffer； 和 VIDIOC_QBUF 命令。将空缓冲区放入缓冲队列，对应结构体为struct v4l2_buffer；
- 向内核发送 VIDIOC_STREAMON 命令，开始采集图像数据。打开数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；
- 从队列中提取一帧图像数据，并保存到文件中。
- 将已读取的缓冲区放回队列，并向内核发送 VIDIOC_QBUF 命令。将空缓冲区放入缓冲队列，对应结构体为struct v4l2_buffer；
- 停止采集图像数据，向内核发送 VIDIOC_STREAMOFF 命令。关闭数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；
- 释放已映射的内核空间，使用 munmap 函数。
- 关闭设备文件。close(fd)


```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/videodev2.h>
#include <string.h>
#include <sys/mman.h>
int main(void) 
{
    // 打开设备
    int fd = open("/dev/video0",O_RDWR);
    if (fd < 0)
    {
        perror("打开设备失败");
        return -1;
    }

    
    
    
    //获取摄像头支持格式 ioctl(文件描述符,命令，与命令对应的结构体)
    struct v4l2_format vfmt;

    vfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; //摄像头采集
    vfmt.fmt.pix.width = 640; //设置摄像头采集参数，不可以任意设置
    vfmt.fmt.pix.height = 480;
    vfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //设置为mjpg格式，则我可以直接写入文件保存，YUYV格式保存后需要转换格式才能查看
    int ret = ioctl(fd,VIDIOC_S_FMT,&vfmt);
    if (ret < 0)
    {
        perror("设置格式失败1");
    }

    
    
    //申请内核空间
    struct v4l2_requestbuffers reqbuffer;
    reqbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    reqbuffer.count = 4; //申请4个缓冲区
    reqbuffer.memory = V4L2_MEMORY_MMAP;  //映射方式

    ret = ioctl(fd,VIDIOC_REQBUFS,&reqbuffer);
    if (ret < 0)
    {
        perror("申请空间失败");
    }
   
    
    
    
    
    
    //内存映射
    unsigned char *mptr[4];//保存映射后用户空间的首地址
    unsigned int size[4];
    struct v4l2_buffer mapbuffer;
    //初始化type和index
    mapbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    for(int i = 0; i <4;i++) {
        mapbuffer.index = i;
        ret = ioctl(fd,VIDIOC_QUERYBUF,&mapbuffer); //从内核空间中查询一个空间作映射
        if (ret < 0)
        {
            perror("查询内核空间失败");
        }
        //映射到用户空间
        mptr[i] = (unsigned char *)mmap(NULL,mapbuffer.length,PROT_READ|PROT_WRITE,MAP_SHARED,fd,mapbuffer.m.offset);
        size[i] = mapbuffer.length; //保存映射长度用于后期释放
        //查询后通知内核已经放回
        ret = ioctl(fd,VIDIOC_QBUF,&mapbuffer); 
        if (ret < 0)
        {
            perror("放回失败");
        }
    }
    
    
    
    //开始采集
    int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    ret = ioctl(fd,VIDIOC_STREAMON,&type); 
    if (ret < 0)
        {
            perror("开启失败");
        }
    
    
    
    //从队列中提取一帧数据
    struct v4l2_buffer readbuffer;
    readbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; //每个结构体都需要设置type为这个参赛要记住
    ret = ioctl(fd,VIDIOC_DQBUF,&readbuffer); 
    if (ret < 0)
        {
            perror("读取数据失败");
        }
    
    FILE *file=fopen("my.jpg", "w+");  //打开一个文件
    fwrite( mptr[readbuffer.index],readbuffer.length,1,file);//写入文件
    fclose(file);    //写入完成，关闭文件

    
    
    
    //通知内核使用完毕
   ret = ioctl(fd, VIDIOC_QBUF, &readbuffer);
   if(ret < 0)
	{
		perror("放回队列失败");
	}
	
    
    
    //停止采集
    ret = ioctl(fd,VIDIOC_STREAMOFF,&type);
    
    
    
	//释放映射
    for(int i=0; i<4; i++)munmap(mptr[i], size[i]);

    
    close(fd); //关闭文件
    
    
    return 0;
}

```





头文件代码：

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/videodev2.h>
#include <string.h>
#include <sys/mman.h>

/**这些都是Linux系统下的系统头文件。它们包含了一系列函数和结构体的定义，可以让开发人员调用系统底层的功能实现更加高效和精确的编程。下面是每个头文件的简要介绍：

stdio.h：标准输入输出头文件，包含了标准输入输出函数的声明。
sys/types.h：包含了各种类型的定义，如size_t、time_t等。
sys/stat.h：包含了文件状态信息的函数和结构体，如chmod()、stat()等。
fcntl.h：包含了文件控制函数的声明，如open()、fcntl()等。
stdlib.h：包含了一些通用的函数，如malloc()、calloc()等。
unistd.h：包含了许多Unix标准函数的定义，如read()、write()等。
sys/ioctl.h：包含了ioctl()函数的定义，用于控制设备的输入输出。
linux/videodev2.h：包含了V4L2的函数和结构体的定义，如VIDIOC_QUERYCAP、VIDIOC_REQBUFS等。
string.h：包含了一些字符串操作的函数，如strcpy()、strlen()等。
sys/mman.h：包含了内存映射函数的定义，如mmap()、munmap()等。 **/
```

main函数代码：

打开摄像头设备

```c
    int fd = open("/dev/video0",O_RDWR);
    if (fd < 0)
    {
        perror("打开设备失败");
        return -1;
    }

/*这段代码是用于打开 Linux 下的 V4L2 视频设备的，其中：

/dev/video0 表示视频设备的文件名，通常在 Linux 系统中使用 V4L2 框架采集视频时，设备文件名是 /dev/video0、/dev/video1、/dev/video2 等，这取决于你使用的是哪个设备。
O_RDWR 参数表示以可读可写模式打开文件。

代码中的 open 函数会返回一个整数类型的文件描述符 fd，如果 fd 小于 0，则表示打开设备失败。*/
```

open函数详解如下：

```c
//open函数是一个系统调用函数，用于打开一个文件或设备，并返回一个文件描述符，以便后续的读写操作使用。
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags, mode_t mode);
```

其中，

- pathname表示要打开的文件路径；
- flags表示打开文件的方式，
  - 例如**O_RDONLY**表示只读方式打开，
  - **O_WRONLY**表示只写方式打开，
  - **O_RDWR**表示读写方式打开；
- mode表示文件的权限，例如0666表示文件所有用户都有读写权限。可以不填这一个参数；

open函数执行成功后，返回一个非负整数的文件描述符，表示文件的访问指针，该文件描述符将用于后续的读写操作。如果执行失败，open函数返回-1，并设置errno变量来指示错误类型。



设置摄像头格式

```c
//获取摄像头支持格式 ioctl(文件描述符,命令，与命令对应的结构体)
    struct v4l2_format vfmt;

    vfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; //摄像头采集
    vfmt.fmt.pix.width = 640; //设置摄像头采集参数，不可以任意设置
    vfmt.fmt.pix.height = 480;
    vfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; //设置为mjpg格式，则我可以直接写入文件保存，YUYV格式保存后需要转换格式才能查看
    
    int ret = ioctl(fd,VIDIOC_S_FMT,&vfmt);
    if (ret < 0)
    {
        perror("设置格式失败1");
    }

/*

type：表示流类型，例如视频数据流或元数据流。
fmt：用于描述视频帧的格式，包括以下字段：
pix：视频像素格式信息。包含以下字段：
	width：视频图像宽度。
	height：视频图像高度。
	pixelformat：视频像素格式。可以是标准格式，如YUV420P，RGB565等，也可以是厂商自定义格式。


这段代码的作用是通过 ioctl() 函数设置摄像头采集格式。
函数的参数 fd 是打开摄像头设备后得到的文件描述符，
VIDIOC_S_FMT 是命令标志，
vfmt 是一个结构体类型，用于设置摄像头采集参数。
其中，vfmt.type 设置为 V4L2_BUF_TYPE_VIDEO_CAPTURE 表示采集摄像头数据，
	vfmt.fmt.pix.width 和 vfmt.fmt.pix.height 分别设置采集图像的宽和高。
	vfmt.fmt.pix.pixelformat 设置采集数据的像素格式，此处设置为 V4L2_PIX_FMT_MJPEG 表示采用 MJPEG 格式。
	如果设置成功，函数返回值为 0，否则返回错误码，并通过 perror() 函数输出错误信息。

*/
```

ioctl函数详解如下：

```c
/*ioctl()函数是Unix、Linux系统中的一个系统调用函数，用于设备的控制和通信，它的原型如下：*/

int ioctl(int fd, unsigned long request, ...);


/*其中，参数fd是打开的设备的文件描述符，request是设备请求的命令，命令和请求的数据根据不同的设备而不同，...是一个可选参数，用于传递请求的数据或者返回设备响应的数据。*/

```

ioctl()函数常用于控制硬件设备，例如摄像头、音频设备、串口、USB等，也可以用于控制软件设备，例如socket等。

在V4L2应用开发中，ioctl()函数被广泛使用，用于对摄像头设备进行格式、分辨率、曝光等参数的设置，以及启动、停止摄像头数据流等操作。在这些操作中，请求的命令和请求数据都是由V4L2提供的数据结构指定的。

其中request参数可以查看官方手册，这里使用到了**VIDIOC_S_FMT**，设置视频格式。所以相应使用结构体`struct v4l2_format`



```txt
设备请求命令request是指在ioctl函数中，用于指定需要操作的命令类型，不同的命令类型对应不同的结构体参数。在V4L2驱动中，常见的设备请求命令request有以下几种：

VIDIOC_QUERYCAP：查询驱动能力，对应结构体为struct v4l2_capability；
VIDIOC_ENUM_FMT：查询驱动支持的视频格式，对应结构体为struct v4l2_fmtdesc；
VIDIOC_S_FMT：设置视频格式，对应结构体为struct v4l2_format；
VIDIOC_REQBUFS：申请缓冲区，对应结构体为struct v4l2_requestbuffers；
VIDIOC_QUERYBUF：查询缓冲区状态，对应结构体为struct v4l2_buffer；
VIDIOC_STREAMON：打开数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；
VIDIOC_STREAMOFF：关闭数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；
VIDIOC_QBUF：将空缓冲区放入缓冲队列，对应结构体为struct v4l2_buffer；
VIDIOC_DQBUF：从缓冲队列中取出已经填充好数据的缓冲区，对应结构体为struct v4l2_buffer；
VIDIOC_G_CTRL：获取控制属性，对应结构体为struct v4l2_control；
VIDIOC_S_CTRL：设置控制属性，对应结构体为struct v4l2_control。

以上仅列举了常见的设备请求命令request及其对应的结构体参数，具体命令类型还可以通过查询V4L2的官方文档获取更详细的信息。
```



申请内核空间

摄像头采集数据需要涉及到对硬件的读取，而硬件资源一般都受到操作系统的管理。因此，为了安全性和效率性，摄像头驱动程序一般使用内核空间进行缓存，以便能够安全地进行对硬件资源的访问。

具体来说，内核空间中的缓存能够确保对摄像头缓存数据的读取和写入操作是原子的，避免了多个进程同时访问造成数据冲突的问题；同时，内核空间中的缓存能够更好地利用系统的物理内存，提高了程序的效率。

因此，为了保证程序的可靠性和高效性，使用内核空间进行数据的映射和缓存是一个比较好的选择。而将读取的数据直接放在队列里，可能会导致数据丢失和访问冲突等问题。

```c
    //申请内核空间
    struct v4l2_requestbuffers reqbuffer;
    reqbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    reqbuffer.count = 4; //申请4个缓冲区
    reqbuffer.memory = V4L2_MEMORY_MMAP;  //映射方式

    ret = ioctl(fd,VIDIOC_REQBUFS,&reqbuffer);
    if (ret < 0)
    {
        perror("申请空间失败");
    }

/*
这段代码是使用ioctl函数，向摄像头驱动程序请求分配一定数量的内存缓冲区用于存储摄像头采集到的数据，该内存映射方式为mmap。

具体来说，代码中使用v4l2_requestbuffers结构体来设置请求缓冲区的参数，包括采集数据类型、缓冲区数量和映射方式等。
然后使用ioctl函数发送VIDIOC_REQBUFS命令，以此向摄像头驱动程序发出申请内存缓冲区的请求。
如果申请成功，则内核空间将分配一定数量的缓冲区，并返回缓冲区的地址和数量等信息，程序可以利用这些缓冲区来存储采集到的图像数据。
如果申请失败，则会输出"申请空间失败"的错误信息。
*/
```

映射

在这个示例代码中，使用了4个缓冲区进行视频采集，这是一种常见的做法。由于视频采集需要占用大量的计算资源，所以使用多个缓冲区进行循环利用可以提高采集效率，避免丢帧的情况。一般情况下，选择的缓冲区个数需要根据具体的应用场景和系统硬件性能进行调整。如果缓冲区个数过少，则可能会导致丢帧或者采集帧率过低的问题，而缓冲区过多则可能会浪费系统资源。

```c
 	//内存映射
    unsigned char *mptr[4];//保存映射后用户空间的首地址
    unsigned int size[4];
    struct v4l2_buffer mapbuffer;
    //初始化type和index
    mapbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    for(int i = 0; i <4;i++) {
        mapbuffer.index = i;
        ret = ioctl(fd,VIDIOC_QUERYBUF,&mapbuffer); //从内核空间中查询一个空间作映射
        if (ret < 0)
        {
            perror("查询内核空间失败");
        }
        
        //映射到用户空间
        mptr[i] = (unsigned char *)mmap(NULL,mapbuffer.length,PROT_READ|PROT_WRITE,MAP_SHARED,fd,mapbuffer.m.offset);
        size[i] = mapbuffer.length; //保存映射长度用于后期释放
        //查询后通知内核已经放回
        ret = ioctl(fd,VIDIOC_QBUF,&mapbuffer); 
        if (ret < 0)
        {
            perror("放回失败");
        }
    }

/*这段代码的作用是进行内存映射，将摄像头采集到的数据从内核空间映射到用户空间，方便后续进行处理。
首先，定义了一个指针数组mptr和一个整型数组size，用来保存映射后的用户空间地址和长度信息。
然后，使用for循环进行四次映射，每次从内核空间中查询一个空闲缓冲区，将其映射到用户空间，并将用户空间首地址保存到mptr数组中，将映射长度保存到size数组中。
映射完成后，调用ioctl函数将该缓冲区放回内核空间。这样就完成了内存映射的过程。*/
```

mmap函数详解如下：

**mmap()（memory map）**函数是一种将文件或其他对象映射到内存的机制，

**该机制使得进程可以直接读写该对象而不必调用I/O函数。**

当一个进程向内存区域写入数据时，数据会直接被保存到文件中，当进程从内存区域读取数据时，数据会直接从文件中读取。

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);


/*其中参数的含义如下：

addr：映射的地址。通常为 NULL，表示由操作系统自动分配映射的地址。
length：映射的长度。通常是文件的大小，也可以更大。
prot：保护权限。指定映射区域的读写权限，取值可以是 PROT_READ、PROT_WRITE 或者 PROT_EXEC。可以通过按位或组合多个选项。
flags：标志参数。取值可以是 MAP_SHARED 或者 MAP_PRIVATE，表示映射的共享和私有的。
fd：被映射文件的文件描述符。
offset：被映射文件中的偏移量。可以是 0，表示从文件开头开始映射。

mmap()函数返回的是映射区域的起始地址，如果失败则返回 MAP_FAILED（通常为 (void*)-1）。映射成功后，可以使用该地址直接访问文件数据。

需要注意的是，使用完毕后需要使用 munmap() 函数解除映射关系，释放内存资源。*/
```



开始采集视频数据(VIDIOC_STREAMON)

**打开数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；**

```c
   //开始采集
    int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    ret = ioctl(fd,VIDIOC_STREAMON,&type); 
    if (ret < 0)
        {
            perror("开启失败");
        }

/*这段代码使用ioctl函数的VIDIOC_STREAMON命令来开始视频流的捕获，
将视频捕获设备的type参数设置为V4L2_BUF_TYPE_VIDEO_CAPTURE，
然后使用VIDIOC_STREAMON命令启动视频流捕获。
这样，视频设备开始将捕获到的视频数据缓存到内核空间的缓存区。*/
```



队列取数据写入新的文件中(VIDIOC_DQBUF)

**从缓冲队列中取出已经填充好数据的缓冲区，对应结构体为struct v4l2_buffer；**

```c
  //从队列中提取一帧数据
    struct v4l2_buffer readbuffer;
    readbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; //每个结构体都需要设置type为这个参数要记住
    ret = ioctl(fd,VIDIOC_DQBUF,&readbuffer); 
    if (ret < 0)
        {
            perror("读取数据失败");
        }
    
    FILE *file=fopen("my.jpg", "w+");  //打开一个文件
    fwrite( mptr[readbuffer.index],readbuffer.length,1,file);//写入文件
    fclose(file);    //写入完成，关闭文件


/*这段代码是从摄像头采集到的数据缓存队列中取出一帧数据，并将其保存到文件中。
具体来说，它的实现过程如下：

定义一个v4l2_buffer类型的结构体readbuffer，设置其type为V4L2_BUF_TYPE_VIDEO_CAPTURE。

v4l2_buffer是一个结构体，用于传递有关视频帧缓冲区的信息，包括缓冲区的索引，缓冲区中数据的长度和地址，时间戳等。

它包含以下字段：

type：数据流类型，如V4L2_BUF_TYPE_VIDEO_CAPTURE等
memory：缓冲区类型，如V4L2_MEMORY_MMAP等
index：缓冲区索引，从0开始
length：缓冲区长度
m.offset：缓冲区地址偏移量
timestamp：时间戳
sequence：序列号
flags：缓冲区标志


使用ioctl函数调用VIDIOC_DQBUF命令从缓存队列中取出一帧数据，将其存储到readbuffer中。

使用fopen函数打开一个名为my.jpg的文件，打开方式为"w+"，即可读可写且文件不存在则创建。

使用fwrite函数将从缓存队列中取出的一帧数据写入到打开的文件中。
其中，第一个参数mptr[readbuffer.index]是取出的一帧数据的首地址，
	第二个参数readbuffer.length是数据长度，
	第三个参数为1，表示写入一次。

使用fclose函数关闭文件，写入完成。
*/
```

fopen函数详解如下：

fopen是C语言中常用的文件操作函数之一，用于打开文件并返回指向该文件的文件指针，使得我们可以对该文件进行读取或写入等操作。

```c
FILE *fopen(const char *filename, const char *mode);


/*其中，filename表示需要打开的文件名，mode表示文件打开模式，包括读模式和写模式等。

常见的打开模式有：

"r": 读模式，打开一个已有的文本文件，并允许读取文件。
"w": 写模式，打开一个文本文件，并允许写入文件。如果该文件已存在，则会将其截断为0字节；如果不存在，则会创建该文件。
"a": 追加模式，打开一个文本文件，并在文件末尾写入。如果该文件不存在，则会创建一个新文件。
"rb": 二进制读模式，打开一个二进制文件，并允许读取文件。
"wb": 二进制写模式，打开一个二进制文件，并允许写入文件。如果该文件已存在，则会将其截断为0字节；如果不存在，则会创建该文件。
"ab": 二进制追加模式，打开一个二进制文件，并在文件末尾写入。如果该文件不存在，则会创建一个新文件。

fopen函数成功打开文件后，会返回指向文件的指针，否则返回NULL。
对于打开成功的文件，可以使用fread、fwrite、fseek、ftell等函数进行文件读写和定位操作。使用完文件后，应该使用fclose函数关闭文件。*/
```



fwrite函数详解如下：

fwrite函数是C语言中用于将数据块写入文件的标准库函数。

```c
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);


/*其中，参数ptr表示要写入文件的数据指针，参数size表示每个数据块的字节数，参数count表示要写入的数据块数量，参数stream表示要写入的文件指针。函数返回值为实际写入的数据块数量。

例如，要将一个长度为len的数据块data写入到文件file中，可以使用如下代码：
FILE *file = fopen("filename", "w");
fwrite(data, sizeof(char), len, file);
fclose(file);

这段代码将会把data指向的数据块写入到filename文件中，每个数据块的大小为sizeof(char)，数据块数量为len。注意，fwrite函数写入的数据是二进制数据，如果要写入字符串，需要使用fprintf等函数。*/
```



fclose函数详解如下：

fclose() 是 C 语言标准库中的一个函数，用于关闭一个已打开的文件。它需要传入一个文件指针，即 fopen() 返回的文件指针，以及需要关闭的文件类型。

```c
int fclose(FILE *stream);


/*其中 stream 为需要关闭的文件指针，函数返回值为 0 表示关闭成功，否则返回一个非 0 的值。

fclose() 函数会将缓冲区的内容写回到文件中，并释放与该文件关联的资源。
在程序结束之前，应该确保所有已打开的文件都被关闭，以避免资源泄漏和文件系统的问题。*/
```



通知内核进程使用完毕（VIDIOC_QBUF）

**将空缓冲区放入缓冲队列，对应结构体为struct v4l2_buffer；**

```c
  //通知内核使用完毕
   ret = ioctl(fd, VIDIOC_QBUF, &readbuffer);
   if(ret < 0)
	{
		perror("放回队列失败");
	}
```

停止采集（VIDIOC_STREAMOFF）

**关闭数据流，对应参数为枚举类型V4L2_BUF_TYPE_VIDEO_CAPTURE；**

```c
     //停止采集
    ret = ioctl(fd,VIDIOC_STREAMOFF,&type);
```



释放映射（munmap）

```c
    //释放映射
    for(int i=0; i<4; i++)munmap(mptr[i], size[i]);
```

关闭文件（close）

```c
    close(fd); //关闭文件
```

close函数详解如下：

close函数是一个系统调用，用于关闭文件描述符。在操作系统中，每个进程都有一个文件描述符表，用于维护打开的文件和其他I/O设备。close函数将打开的文件和I/O设备与文件描述符表中的对应项断开连接。

```c
#include <unistd.h>
int close(int fd);


/*其中，fd是要关闭的文件描述符。如果操作成功，close函数返回0；否则，返回-1并设置errno来表示错误。

使用close函数可以释放文件描述符，避免资源浪费和其他进程访问同一文件时出现问题。通常在打开文件后处理完毕后，应该及时关闭文件。*/
```



tip-close&&fclose

fclose()和close()函数都是用于关闭文件描述符的，但是它们之间有几个重要的区别：

fclose()函数只能用于关闭FILE*类型的文件指针，即标准库中使用的文件流，而close()函数可以关闭任何类型的文件描述符，包括标准输入、标准输出、网络套接字等。

fclose()函数会自动冲洗（flush）缓冲区的内容，将缓冲区中未写入磁盘的数据写入磁盘中，而close()函数不会冲洗缓冲区，缓冲区中未写入磁盘的数据将会丢失。

fclose()函数返回值为0表示成功关闭文件流，非零值表示关闭失败，而close()函数返回值为0表示成功关闭文件描述符，-1表示关闭失败。

因此，在使用fclose()函数和close()函数时需要根据具体情况选择合适的函数。如果使用标准库函数操作文件，应该使用fclose()函数，如果使用系统调用函数操作文件描述符，应该使用close()函数。



2.server端，发送数据给客户端client

server端总代码

```c
/*server.c*/
#include<netinet/in.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>

#define SERVER_PORT    5678         //端口号
#define LENGTH_OF_LISTEN_QUEUE     20
#define BUFFER_SIZE                1024
#define FILE_NAME_MAX_SIZE         512

int main(int argc, char **argv)
{
    // 创建服务器套接字
    // 设置一个socket地址结构server_addr,代表服务器ip地址和端口
    struct sockaddr_in   server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htons(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);
    // 创建用于流协议(TCP)socket，用server_socket代表服务器向客户端提供服务的接口
    int server_socket = socket(PF_INET, SOCK_STREAM, 0);
    if (server_socket < 0)
    {
        printf("Create Socket Failed!\n");
        exit(1);
    }
    else
        printf("Create Socket Success.\n");

    
    
    
    
    // 把socket和socket地址结构绑定
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)))
    {
        printf("Server Bind Port: %d Failed!\n", SERVER_PORT);
        exit(1);
    }
    else
        printf("Client Bind Port Success.\n");

    // server_socket用于监听
    if (listen(server_socket, LENGTH_OF_LISTEN_QUEUE))
    {
        printf("Server Listen Failed!\n");
        exit(1);
    }
    else
        printf("Listening....\n");

    
    
    
    // 服务器始终监听
    while(1)
    {
        // 堵塞监听端口
        // 定义客户端的socket地址结构client_addr，当收到来自客户端的请求后，调用accept
        // 接受此请求，同时将client端的地址和端口等信息写入client_addr中
        struct sockaddr_in client_addr;
        socklen_t   length = sizeof(client_addr);

        // 接受一个从client端到达server端的连接请求,将客户端的信息保存在client_addr中
        // 如果没有连接请求，则一直等待直到有连接请求为止，这是accept函数的特性
        // accpet返回一个新的socket,这个socket用来与此次连接到server的client进行通信
        // 这里的new_server_socket代表了这个通信通道
        int new_server_socket = accept(server_socket, (struct sockaddr*)&client_addr, &length);
        if (new_server_socket < 0)
        {
            printf("Server Accept Failed!\n");
            break;
        }
        else
            printf("Server Accept Success.\n");

        
        
        
        // 接收端口数据
        char buffer[BUFFER_SIZE];
        bzero(buffer, sizeof(buffer));
        length = recv(new_server_socket, buffer, BUFFER_SIZE, 0);
        if (length < 0)
        {
            printf("Server Recieve Data Failed!\n");
            break;
        }
        else
            printf("Server Recieve Data Success.\n");

        
        
        
        
        // 打开文件读取发送
        char file_name[FILE_NAME_MAX_SIZE + 1];
        bzero(file_name, sizeof(file_name));
        strncpy(file_name, buffer,
                strlen(buffer) > FILE_NAME_MAX_SIZE ? FILE_NAME_MAX_SIZE : strlen(buffer));

        FILE *fp = fopen(file_name, "r");  //获取文件操作符
        if (fp == NULL)
        {
            printf("File:\t%s Not Found!\n", file_name);
        }
        else
        {
            bzero(buffer, BUFFER_SIZE);
            int file_block_length = 0;
            while( (file_block_length = fread(buffer, sizeof(char), BUFFER_SIZE, fp)) > 0)
            {
                // 发送buffer中的字符串到new_server_socket,实际上就是发送给客户端
                if (send(new_server_socket, buffer, file_block_length, 0) < 0)
                {
                    printf("Send File:\t%s Failed!\n", file_name);
                    break;
                }

                bzero(buffer, sizeof(buffer));
            }
            fclose(fp);
            printf("File:\t%s Transfer Finished!\n", file_name);
        }

        close(new_server_socket);
    }

    close(server_socket);

    return 0;
}
```

分解代码：

头文件代码：

```c
/*server.c*/
#include<netinet/in.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>

/*
这是一个基本的C语言程序，包含了一些系统头文件的声明，其中：

netinet/in.h：该头文件定义了一些互联网协议(IP)的常量、结构体等，例如IP地址、端口号等。
sys/types.h：该头文件定义了系统调用使用的一些基本数据类型，例如pid_t（进程ID）、uid_t（用户ID）等。
sys/socket.h：该头文件定义了一些套接字(Socket)编程中的数据结构、宏定义等，例如struct sockaddr（Socket地址结构体）等。
stdio.h：该头文件定义了输入/输出（I/O）操作相关的函数和宏定义，例如printf()、scanf()、FILE等。
stdlib.h：该头文件定义了一些通用的函数和变量类型，例如malloc()、free()、size_t等。
string.h：该头文件定义了一些操作字符串的函数和宏定义，例如memset()、strcat()、strlen()等。
unistd.h：该头文件定义了一些常量、函数和类型等，例如fork()、exec()、getpid()等。
*/
```

main函数代码：

创建服务端套接字

```c
    // 设置一个socket地址结构server_addr,代表服务器ip地址和端口
    struct sockaddr_in   server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htons(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);

    // 创建用于流协议(TCP)socket，用server_socket代表服务器向客户端提供服务的接口
    int server_socket = socket(PF_INET, SOCK_STREAM, 0);
    if (server_socket < 0)
    {
        printf("Create Socket Failed!\n");
        exit(1);
    }
    else
        printf("Create Socket Success.\n");


/*
这段代码是创建一个服务器的套接字，主要包括以下几个步骤：

初始化一个 sockaddr_in 结构体 server_addr，
表示服务器的 IP 地址和端口号。
其中，AF_INET 是 IP 地址族，
htons() 函数用于将主机字节序的端口号转换为网络字节序。
INADDR_ANY 表示监听来自任何 IP 地址的请求。

使用 socket() 函数创建一个 TCP socket，用 server_socket 变量来表示。

检查 socket 是否创建成功。如果创建失败，输出错误信息并退出程序。如果成功，则输出创建成功的信息。

总体来说，这段代码的作用是创建了一个 TCP 服务器套接字，用于接收客户端的连接请求。*/
```

htons函数详解如下：

htons函数是一个网络字节序和主机字节序之间进行转换的函数，其作用是将16位主机字节序转换为16位网络字节序（即大端字节序）。

在网络通信中，数据的传输是以字节为单位进行的，不同的计算机采用的字节序不同，因此需要将主机字节序转换为网络字节序，以保证通信的正确性。

例如，在x86处理器上，采用的是小端字节序，而网络通信一般采用大端字节序，因此需要将主机字节序进行转换。

==大端小端问题==

```c
uint16_t htons(uint16_t hostshort);


/*其中，hostshort是16位主机字节序的无符号整数，返回值是16位网络字节序的无符号整数。

例如，假设主机字节序为0x1234，则经过htons转换后，网络字节序为0x3412。*/
```



bzero函数详解如下：

bzero 函数用于将指定内存区域前 n 个字节清零，即将内存区域中的每个字节都置为0。

```c
void bzero(void *s, size_t n);


/*参数 s 为指向欲操作的内存区域的指针，n 为欲清零的字节数。调用 bzero 函数将会把这个内存区域的前 n 个字节都设置为 0。

在 C 语言中，我们可以使用 memset 函数达到同样的效果，但是 bzero 函数比 memset 函数更简单，且可以清零任何类型的数据，包括结构体等。*/
```

==但是在一些最新的 C 标准中，bzero 函数已经被标记为已弃用，不再推荐使用。==



绑定端口和监听套接字

```c
    // 把socket和socket地址结构绑定
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)))
    {
        printf("Server Bind Port: %d Failed!\n", SERVER_PORT);
        exit(1);
    }
    else
        printf("Client Bind Port Success.\n");

    // server_socket用于监听
    if (listen(server_socket, LENGTH_OF_LISTEN_QUEUE))
    {
        printf("Server Listen Failed!\n");
        exit(1);
    }
    else
        printf("Listening....\n");

/*
这段代码实现了将创建的socket和socket地址结构绑定，以及使用server_socket进行监听。
具体来说，这里调用了bind函数将socket和socket地址结构(server_addr)进行绑定，如果绑定失败则程序退出。
然后调用listen函数对server_socket进行监听，同时指定最大等待连接数，如果监听失败则程序也会退出。
整个过程是在服务器端进行的，目的是等待客户端连接。*/
```



bind函数详解如下：

当我们的服务器创建好 socket 后，我们需要通过 bind 函数把 socket 与一个具体的地址和端口绑定起来，这样客户端才能通过该地址和端口与服务器进行通信。

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

/*
sockfd：socket 文件描述符。
addr：指向要绑定给 sockfd 的地址结构。
addrlen：地址结构的长度。

另外，当我们调用 bind 函数时，我们需要先构造一个 struct sockaddr_in 类型的地址结构，该结构体包含了服务器 IP 地址和端口号等信息。
bind函数成功返回0，
*/

```



listen函数详解如下：

listen 函数则是用于启动服务端等待客户端的连接请求，

```c
int listen(int sockfd, int backlog);

/*sockfd：socket 文件描述符。
backlog：请求队列的最大长度。

这个函数会将 sockfd 指定的 socket 变成一个被动 socket，可以接收来自客户端的连接请求，
backlog 参数指定请求队列的最大长度，
一旦有新的客户端连接进来，它就会进入该请求队列，直到服务器端 accept 函数接收到它的请求并进行处理
listen函数成功返回0。
*/
```

堵塞监听端口

```c
		// 定义客户端的socket地址结构client_addr，当收到来自客户端的请求后，调用accept
        // 接受此请求，同时将client端的地址和端口等信息写入client_addr中
        struct sockaddr_in client_addr;
        socklen_t   length = sizeof(client_addr);

        // 接受一个从client端到达server端的连接请求,将客户端的信息保存在client_addr中
        // 如果没有连接请求，则一直等待直到有连接请求为止，这是accept函数的特性
        // accpet返回一个新的socket,这个socket用来与此次连接到server的client进行通信
        // 这里的new_server_socket代表了这个通信通道
        int new_server_socket = accept(server_socket, (struct sockaddr*)&client_addr, &length);
        if (new_server_socket < 0)
        {
            printf("Server Accept Failed!\n");
            break;
        }
        else
            printf("Server Accept Success.\n");

/*这段代码是使用accept函数来接受客户端连接请求的过程。

首先定义了一个客户端的socket地址结构client_addr，接下来调用accept函数来接收连接请求。
如果没有连接请求，accept函数会一直等待直到有连接请求到来。
当有连接请求到来时，accept函数会返回一个新的socket描述符new_server_socket，这个描述符用于和客户端进行通信。
同时，accept函数会将客户端的地址信息保存在client_addr中。

如果accept函数返回值小于0，表示接受连接请求失败，程序会跳出循环。如果accept函数返回值大于等于0，表示成功接收到连接请求，程序会继续执行。*/
```

accept函数详解如下：

accept()函数用于在服务器端接受客户端的连接请求，并创建一个新的socket通道来与客户端进行通信。

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);


/*其中，sockfd为服务器socket文件描述符，
	addr是一个指向sockaddr结构体的指针，表示客户端的地址信息，
	addrlen是addr指向的地址结构体的长度，即sizeof(struct sockaddr)。

accept()函数的返回值是一个新的socket文件描述符，用于服务器与客户端之间的通信。如果accept()函数执行成功，那么新的socket文件描述符将自动继承服务器socket的属性，如协议族、地址类型等。

在服务器端执行accept()函数时，如果没有客户端请求连接，那么accept()函数会阻塞，直到有客户端请求连接为止。
如果服务器socket文件描述符被设置为非阻塞模式，则accept()函数会立即返回-1并设置错误码为EAGAIN或EWOULDBLOCK。*/
```

接收端口数据

```c
        char buffer[BUFFER_SIZE];
        bzero(buffer, sizeof(buffer));
        length = recv(new_server_socket, buffer, BUFFER_SIZE, 0);
        if (length < 0)
        {
            printf("Server Recieve Data Failed!\n");
            break;
        }
        else
            printf("Server Recieve Data Success.\n");
/*
这段代码是在服务器接收来自客户端发送的数据。
首先定义了一个缓冲区 buffer ，并使用 bzero() 函数将其清空。
然后使用 recv() 函数从客户端发送的数据中读取数据，读取的数据将存储在缓冲区 buffer 中，函数返回值 length 表示实际接收到的数据的字节数。
如果 length 小于 0，表示接收数据失败，程序退出；否则表示接收数据成功，并打印相应的提示信息。*/
```

recv函数详解如下：

recv() 是一个系统调用函数，用于从指定的套接字中接收数据，并将其存储在缓冲区中。

```c
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

/*
sockfd：需要接收数据的套接字描述符。
buf：用于存放接收到的数据的缓冲区指针。
len：需要接收的数据长度。缓冲区大小
flags：接收操作的指定标志,无特殊要求就为0

recv() 函数的返回值为 ssize_t 类型，表示实际接收到的数据长度。函数返回值为 -1 表示出错，0 表示连接关闭。

当 recv() 函数返回值小于 len 时，需要再次调用 recv() 函数接收剩余的数据。由于 recv() 函数的数据接收是阻塞的，所以在没有接收到足够的数据前，程序会一直阻塞在该函数处。

*/
```

打开文件读取发送

```c
 char file_name[FILE_NAME_MAX_SIZE + 1];
        bzero(file_name, sizeof(file_name));
        strncpy(file_name, buffer,
                strlen(buffer) > FILE_NAME_MAX_SIZE ? FILE_NAME_MAX_SIZE : strlen(buffer));

        FILE *fp = fopen(file_name, "r");  //获取文件操作符
        if (fp == NULL)
        {
            printf("File:\t%s Not Found!\n", file_name);
        }
        else
        {
            bzero(buffer, BUFFER_SIZE);
            int file_block_length = 0;
            while( (file_block_length = fread(buffer, sizeof(char), BUFFER_SIZE, fp)) > 0)
            {
                // 发送buffer中的字符串到new_server_socket,实际上就是发送给客户端
                if (send(new_server_socket, buffer, file_block_length, 0) < 0)
                {
                    printf("Send File:\t%s Failed!\n", file_name);
                    break;
                }

                bzero(buffer, sizeof(buffer));
            }
            fclose(fp);
            printf("File:\t%s Transfer Finished!\n", file_name);
        }
/*
这段代码是在服务器接收到客户端请求后，打开一个指定的文件，读取文件内容并将其发送给客户端。

具体解释如下：

首先，代码定义了一个字符数组file_name，并将其清零。
然后将接收到的客户端请求信息复制到file_name中，限制复制长度为FILE_NAME_MAX_SIZE。
这里的FILE_NAME_MAX_SIZE是一个常量，表示文件名的最大长度。

然后，代码使用fopen函数打开指定的文件，并将文件操作符存储在fp变量中。如果打开文件失败，代码输出一个提示信息，表明文件没有找到。

接下来，代码使用一个循环读取文件中的内容，每次读取BUFFER_SIZE个字节，并将这些内容发送给客户端。
如果发送失败，循环退出。
当读取文件结束后，代码关闭文件，并输出一个提示信息，表示文件传输已经完成。*/
```

strncpy函数详解如下：

strncpy() 函数是 C 标准库中的字符串函数之一，用于将源字符串的指定长度复制到目标字符串中。

```c
char *strncpy(char *dest, const char *src, size_t n);

/*其中，dest 为目标字符串指针，src 为源字符串指针，n 为要复制的最大字符数。

该函数将源字符串中最多前 n 个字符复制到目标字符串中。
如果源字符串的长度小于 n，则目标字符串剩余部分将填充空字符 '\0' 直至 n 个字符为止。
如果源字符串的长度大于等于 n，则目标字符串将被截断，不会自动添加 '\0'。

需要注意的是，该函数不会在目标字符串的末尾自动添加 '\0'，因此在使用 strncpy() 函数复制字符串时，通常需要手动添加结束符。

在上述代码中，strncpy(file_name, buffer, strlen(buffer) > FILE_NAME_MAX_SIZE ? FILE_NAME_MAX_SIZE : strlen(buffer)) 的作用是将 buffer 中的字符串复制到 file_name 中，最多复制 FILE_NAME_MAX_SIZE 个字符，防止字符串溢出。如果 buffer 中的字符串长度小于 FILE_NAME_MAX_SIZE，则复制整个字符串，否则只复制前 FILE_NAME_MAX_SIZE 个字符。*/
```

fread函数详解如下：

fread() 函数是 C 语言标准库中的函数之一，用于从文件中读取数据并将其存储到内存中。

```c
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
/*
ptr：指向保存读取数据的缓冲区的指针。
size：读取每个数据项的大小（以字节为单位）。
count：要读取的数据项的数量。
stream：指向 FILE 对象的指针，它标识了要读取的文件。

fread() 函数从文件中读取 count 个数据项，每个数据项大小为 size 个字节，将其存储到由 ptr 指向的缓冲区中，返回实际读取到的数据项数目。
如果发生错误或读到文件末尾，则返回值小于 count。

使用 fread() 函数，可以读取任何类型的数据，如整数、字符、结构体等。*/
```



send函数详解如下：

send函数是一个在socket通信中发送数据的函数，其函数原型为：

```c
#include <sys/types.h>
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);

/*
sockfd：需要发送数据的socket描述符。
buf：需要发送的数据的缓冲区首地址。
len：需要发送的数据长度。
flags：调用方式标志，一般为0。

该函数会将buf中的数据发送给指定的socket描述符sockfd。如果发送成功，该函数返回发送的字节数，否则返回-1。在进行网络通信时，应该注意数据的字节顺序（大小端），需要进行字节序转换。*/
```

关闭所有socket

```c
        close(new_server_socket);

    close(server_socket);
```



3.client端，接收指定文件到本地

```c
/*client.c*/
#include<netinet/in.h>                         // for sockaddr_in  
#include<sys/types.h>                          // for socket  
#include<sys/socket.h>                         // for socket  
#include<stdio.h>                              // for printf  
#include<stdlib.h>                             // for exit  
#include<string.h>                             // for bzero  
#include <unistd.h>
#include <arpa/inet.h>
#define SERVER_PORT       			  5678  
#define BUFFER_SIZE                   1024  
#define FILE_NAME_MAX_SIZE            512  

int main(int argc, char **argv)  
{  
    // 检查执行命令参数
    if (argc != 2)  //判断有没有输入服务器ip 
    {  
        printf("Usage: ./%s ServerIPAddress\n", argv[0]);  
        exit(1);  
    }  
	// 正确的命令 应为 sudo ./client 127.0.0.1
    
    
    
    // 利用Socket创建一个客户端
    // 设置一个socket地址结构client_addr, 代表客户机的ip地址和端口  
    struct sockaddr_in client_addr;  
    bzero(&client_addr, sizeof(client_addr));  
    client_addr.sin_family = AF_INET; // internet协议族IPv4  
    client_addr.sin_addr.s_addr = htons(INADDR_ANY); // INADDR_ANY表示自动获取本机地址  
    client_addr.sin_port = htons(0); // auto allocated, 让系统自动分配一个空闲端口  

    // 创建用于internet的流协议(TCP)类型socket，用client_socket代表客户端socket  
    int client_socket = socket(AF_INET, SOCK_STREAM, 0); 
    if (client_socket < 0)
    {
        printf("Create Socket Failed!\n");
        exit(1);
    }
    else
        printf("Create Socket Success.\n");

    
    
    
    // 把客户端的socket和客户端的socket地址结构绑定   
    if (bind(client_socket, (struct sockaddr*)&client_addr, sizeof(client_addr)))  
    {  
        printf("Client Bind Port Failed!\n");  
        exit(1);  
    }
    else
        printf("Client Bind Port Success.\n");

    
    
    
    
    // 设置一个socket地址结构server_addr,代表服务器的internet地址和端口  
    struct sockaddr_in  server_addr;  
    bzero(&server_addr, sizeof(server_addr));  
    server_addr.sin_family = AF_INET;  

    // 服务器的IP地址来自程序的参数   
    if (inet_aton(argv[1], &server_addr.sin_addr) == 0)  
    {  
        printf("Server IP Address Error!\n");  
        exit(1);  
    }  
    
    server_addr.sin_port = htons(SERVER_PORT);  
    int  server_addr_length = sizeof(server_addr);  

    // 向服务器发起连接请求，连接成功后client_socket代表客户端和服务器端的一个socket连接  
    if (connect(client_socket, (struct sockaddr*)&server_addr, server_addr_length) < 0)  
    {  
        printf("Can Not Connect To %s!\n", argv[1]);  
        exit(1);  
    }
    else
        printf("Alreadly Connect To %s.\n", argv[1]);

    
    
    
    
    
    
    char file_name[FILE_NAME_MAX_SIZE + 1];  
    bzero(file_name, sizeof(file_name));  
    printf("Please Input File Name On Server: ");  
    scanf("%s", file_name);  

    char buffer[BUFFER_SIZE];//缓存区
    bzero(buffer, sizeof(buffer));  
    strncpy(buffer, file_name, strlen(file_name) > BUFFER_SIZE ? BUFFER_SIZE : strlen(file_name));  
    // 向服务器发送buffer中的数据，此时buffer中存放的是客户端需要接收的文件的名字  
    send(client_socket, buffer, BUFFER_SIZE, 0); 
   // send , sendto(), recv(),recvfrom()
    FILE *fp = fopen(file_name, "w");  
    if (fp == NULL)  
    {  
        printf("File: %s Can Not Open To Write!\n", file_name);  
        exit(1);  
    }  

    
    
    // 从服务器端接收数据到buffer中   
    bzero(buffer, sizeof(buffer));  
    int length = 0;  
    while(length = recv(client_socket, buffer, BUFFER_SIZE, 0))  
    {  
        if (length < 0)  
        {  
            printf("Recieve Data From Server %s Failed!\n", argv[1]);  
            break;  
        }  

        int write_length = fwrite(buffer, sizeof(char), length, fp);  
        if (write_length < length)  
        {  
            printf("File:\t%s Write Failed!\n", file_name);  
            break;  
        }  
        bzero(buffer, BUFFER_SIZE);  
    }  

    printf("Recieve File: %s From Server[%s] Finished!\n", file_name, argv[1]);  

    // 传输完毕，关闭socket   
    fclose(fp);  
    close(client_socket);  
    return 0;  

}  
```

client端总代码

分解代码：

头文件代码：

```c
#include<netinet/in.h>                         // for sockaddr_in  
#include<sys/types.h>                          // for socket  
#include<sys/socket.h>                         // for socket  
#include<stdio.h>                              // for printf  
#include<stdlib.h>                             // for exit  
#include<string.h>                             // for bzero  
#include <unistd.h>
#include <arpa/inet.h>

/*
这段代码是一个基于TCP协议的Socket服务器程序，它实现了一个简单的文件传输服务。代码包含了以下头文件：

<netinet/in.h>：提供了sockaddr_in结构体和一些网络相关的宏定义。
<sys/types.h>和<sys/socket.h>：提供了网络编程需要用到的一些系统调用和数据类型，例如socket、bind、listen、accept、send、recv等。
<stdio.h>：提供了输入输出函数，例如printf。
<stdlib.h>：提供了一些通用工具函数，例如exit。
<string.h>：提供了字符串操作函数，例如bzero、strncpy等。
<unistd.h>：提供了一些标准的系统调用，例如read、write、close等。
<arpa/inet.h>：提供了一些网络相关的函数，例如inet_addr、inet_ntoa等。
*/
```



main函数代码：

检查执行命令参数

```c
int main(int argc, char **argv);   
	if (argc != 2)  //判断有没有输入服务器ip 
    {  
        printf("Usage: ./%s ServerIPAddress\n", argv[0]);  
        exit(1);  
    }  
	// 正确的命令 应为 sudo ./client 127.0.0.1
	
	/*这段代码用于检查命令行参数数量是否正确。
	如果argc不等于2，表示没有输入服务器IP地址或输入了多个参数，此时程序将输出提示信息并退出。
	*/
```



利用Socket创建一个客户端

```c
    // 设置一个socket地址结构client_addr, 代表客户机的ip地址和端口  
    struct sockaddr_in client_addr;  
    bzero(&client_addr, sizeof(client_addr));  
    client_addr.sin_family = AF_INET; // internet协议族IPv4  
    client_addr.sin_addr.s_addr = htons(INADDR_ANY); // INADDR_ANY表示自动获取本机地址  
    client_addr.sin_port = htons(0); // auto allocated, 让系统自动分配一个空闲端口  

    // 创建用于internet的流协议(TCP)类型socket，用client_socket代表客户端socket  
    int client_socket = socket(AF_INET, SOCK_STREAM, 0); 
    if (client_socket < 0)
    {
        printf("Create Socket Failed!\n");
        exit(1);
    }
    else
        printf("Create Socket Success.\n");
/*这段代码是用于创建一个 TCP 客户端 socket 的过程，其具体含义如下：

创建一个客户端 socket 的结构体 client_addr，用于存储客户端的 IP 地址和端口号信息。

初始化 client_addr 的各个成员变量：
sin_family 表示协议族（IPv4 或 IPv6），
sin_addr.s_addr 表示 IP 地址（使用 INADDR_ANY 表示自动获取本机地址），
sin_port 表示端口号（使用 0 表示让系统自动分配一个空闲端口）。

使用 socket 函数创建一个 TCP 类型的 socket，返回一个整型的文件描述符 client_socket，该文件描述符可用于后续的 socket 操作。

判断 socket 创建是否成功，如果返回值小于 0，则表示创建 socket 失败，程序将输出错误信息并退出，否则程序输出“Create Socket Success.”。*/
```



绑定socket

```c
    // 把客户端的socket和客户端的socket地址结构绑定   
    if (bind(client_socket, (struct sockaddr*)&client_addr, sizeof(client_addr)))  
    {  
        printf("Client Bind Port Failed!\n");  
        exit(1);  
    }
    else
        printf("Client Bind Port Success.\n");

/*这段代码是用于将客户端的 socket 和客户端的 socket 地址结构绑定的过程，其具体含义如下：

使用 bind 函数将客户端的 socket client_socket 与客户端的 socket 地址结构 client_addr 绑定。

bind 函数的第一个参数是要绑定的 socket 文件描述符，
第二个参数是一个指向 sockaddr 类型的结构体指针，指向存储有 IP 地址和端口号的 socket 地址结构体变量，
第三个参数是该结构体的大小。

如果绑定失败，则 bind 函数返回非零值，表示绑定端口失败，程序将输出错误信息并退出；否则程序输出“Client Bind Port Success.”。

注意，该代码中客户端 socket 地址结构体中的 sin_port 成员变量已经在前面的代码中设为 0，表示让系统自动分配一个空闲端口。绑定成功后，客户端的 socket 将绑定到系统分配的空闲端口上，可以用 getsockname() 函数获取该端口号。*/
```



客户端连接服务器

```c
 // 设置一个socket地址结构server_addr,代表服务器的internet地址和端口  
    struct sockaddr_in  server_addr;  
    bzero(&server_addr, sizeof(server_addr));  
    server_addr.sin_family = AF_INET;  

    // 服务器的IP地址来自程序的参数   
    if (inet_aton(argv[1], &server_addr.sin_addr) == 0)  
    {  
        printf("Server IP Address Error!\n");  
        exit(1);  
    }  
    
    server_addr.sin_port = htons(SERVER_PORT);  
    int  server_addr_length = sizeof(server_addr);  

    // 向服务器发起连接请求，连接成功后client_socket代表客户端和服务器端的一个socket连接  
    if (connect(client_socket, (struct sockaddr*)&server_addr, server_addr_length) < 0)  
    {  
        printf("Can Not Connect To %s!\n", argv[1]);  
        exit(1);  
    }
    else
        printf("Alreadly Connect To %s.\n", argv[1]);

/*这段代码是基于TCP协议实现的客户端连接服务器的代码。

首先，代码定义了一个名为server_addr的sockaddr_in结构体，用于存储服务器的IP地址和端口信息。
然后，代码调用了bzero函数，将该结构体清零，以确保其中的所有字段都被初始化为0。
接着，代码设置了server_addr结构体的地址族（AF_INET）和端口（通过htons函数将端口号从主机字节序转换为网络字节序）。
代码还调用了inet_aton函数，将程序的第一个命令行参数（即服务器的IP地址）转换为网络字节序的IP地址，并将该地址存储在server_addr结构体的sin_addr字段中。

然后，代码定义了一个名为server_addr_length的变量，用于存储server_addr结构体的大小。
接下来，代码调用connect函数，向服务器发起连接请求。
connect函数的第一个参数是客户端socket的描述符，第二个参数是指向server_addr结构体的指针，第三个参数是server_addr结构体的大小。如果连接成功，connect函数返回0；否则，返回-1。

最后，代码通过if-else语句判断连接是否成功，并输出相应的提示信息。
如果连接成功，将输出Alreadly Connect To xxx，其中xxx是程序的第一个命令行参数（即服务器的IP地址）。
如果连接失败，将输出Can Not Connect To xxx。*/
```



获取文件

```c
char file_name[FILE_NAME_MAX_SIZE + 1];  
    bzero(file_name, sizeof(file_name));  
    printf("Please Input File Name On Server: ");  
    scanf("%s", file_name);  

    char buffer[BUFFER_SIZE];//缓存区
    bzero(buffer, sizeof(buffer));  
    strncpy(buffer, file_name, strlen(file_name) > BUFFER_SIZE ? BUFFER_SIZE : strlen(file_name));  
    // 向服务器发送buffer中的数据，此时buffer中存放的是客户端需要接收的文件的名字  
    send(client_socket, buffer, BUFFER_SIZE, 0); 
   // send , sendto(), recv(),recvfrom()
    FILE *fp = fopen(file_name, "w");  
    if (fp == NULL)  
    {  
        printf("File: %s Can Not Open To Write!\n", file_name);  
        exit(1);  
    }  
/*
这段代码是一个基于TCP协议的客户端程序，用于从服务器端获取文件。

首先，代码定义了一个名为file_name的字符数组，用于存储服务器端的文件名。
然后，代码调用了bzero函数，将file_name数组清零，以确保其中的所有元素都被初始化为0。
接着，代码通过printf函数向用户提示输入文件名，并调用scanf函数读取用户输入的文件名，并将其存储在file_name数组中。

接下来，代码定义了一个名为buffer的字符数组，作为数据的缓存区。代码再次调用了bzero函数，将buffer数组清零。
接着，代码使用strncpy函数将file_name数组中的内容复制到buffer数组中，并在复制时保证不超过buffer数组的大小（即BUFFER_SIZE），以防止缓冲区溢出。
最后，代码调用send函数将buffer数组中的数据发送到服务器端。此时，服务器端就知道客户端需要获取的文件名了。

接下来，代码调用fopen函数打开一个名为file_name的文件，以便将从服务器端接收到的文件内容写入该文件。
如果文件打开失败，代码将输出错误信息并退出程序。

需要注意的是，代码中使用了send函数将数据发送给服务器端。send函数用于发送数据到已连接的socket上，第一个参数是要发送的socket的描述符，第二个参数是指向包含待发送数据的缓冲区的指针，第三个参数是缓冲区的长度，第四个参数是可选的标志，通常可以设置为0。此外，还有其他的发送和接收函数，如sendto、recv和recvfrom，它们的参数和作用不完全相同。*/
```



接收数据

```c
// 从服务器端接收数据到buffer中   
    bzero(buffer, sizeof(buffer));  
    int length = 0;  
    while(length = recv(client_socket, buffer, BUFFER_SIZE, 0))  
    {  
        if (length < 0)  
        {  
            printf("Recieve Data From Server %s Failed!\n", argv[1]);  
            break;  
        }  

        int write_length = fwrite(buffer, sizeof(char), length, fp);  
        if (write_length < length)  
        {  
            printf("File:\t%s Write Failed!\n", file_name);  
            break;  
        }  
        bzero(buffer, BUFFER_SIZE);  
    }  

    printf("Recieve File: %s From Server[%s] Finished!\n", file_name, argv[1]); 

/*这段代码是从服务器接收数据，存储到本地文件中。具体实现过程如下：

首先，使用recv()函数从服务器端接收数据，将接收到的数据存储到缓冲区buffer中。

接着，通过fwrite()函数将缓冲区中的数据写入到指定的本地文件中，fwrite()函数的参数依次是写入数据的起始地址、每个数据块的大小和写入的数据块数。

在将数据写入本地文件后，将缓冲区buffer清空，继续接收下一批数据，直到接收完所有数据为止。

最后，输出接收完成的提示信息，包括接收到的文件名和服务器的IP地址。*/
```

关闭Socket

```c
    // 传输完毕，关闭socket   
    fclose(fp);  
    close(client_socket);  
    return 0;  
```



Socket多线程

基本实现思路：

1. 创建一个监听socket（一般是TCP），并绑定到一个端口上，开始监听客户端的连接请求。
2. 当有客户端连接请求到达监听socket时，接受连接请求，创建一个新的socket，用于与客户端进行通信。这里需要注意的是，为了能够同时处理多个客户端请求，应该使用非阻塞I/O模型，以便能够在不阻塞主线程的情况下同时处理多个客户端请求。
3. 对于每个新的socket，创建一个新的线程，用于与该客户端进行通信。线程应该在接收到客户端数据时立即响应，将数据处理结果返回给客户端。注意，每个线程应该独立处理自己的socket，以免出现线程竞争问题。
4. 当客户端断开连接时，关闭socket，释放资源。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8888

void *handle_client(void *arg)
{
    int client_fd = *(int *)arg;
    char buf[1024];
    int n;

    while ((n = recv(client_fd, buf, sizeof(buf), 0)) > 0) {
        // 处理客户端数据
        printf("received: %s\n", buf);

        // 将数据处理结果发送给客户端
        send(client_fd, "OK", 2, 0);
    }

    // 关闭socket，释放资源
    close(client_fd);
    free(arg);
    pthread_exit(NULL);
}

int main()
{
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);
    pthread_t tid;

    // 创建监听socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);

    // 绑定到端口上
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);
    bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    // 开始监听
    listen(server_fd, 10);

    while (1) {
        // 接受连接请求
        client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &addr_len);

        // 创建新线程处理客户端数据
        int *pclient_fd = (int *)malloc(sizeof(int));
        *pclient_fd = client_fd;
        pthread_create(&tid, NULL, handle_client, pclient_fd);
    }

    // 关闭socket，释放资源
    close(server_fd);

    return 0;
}

```





## 4.基于S3C2440与Socket的行车记录仪





M9芯片

三星的S3C2440A，主频 400MHz，最高 533Mhz

64M的SDRAM，32位，时钟频率高达100MHz

==Nand Flash启动==，板子Mini2440即是这种开机方式

在 NAND Flash 启动模式下，内部的 4K Bytes BootSram 被映射到 nGCS0 片选的空间；

使用烧写工具还是厂家自带的MiniTools



板载分析：

**版本** 

\- Linux 2.6.32.2(BSP 可自适应 64M/128M/256M/512M/1GB Nand Flash)

**支持的文件系统** 

\- yaffs2(可读写的文件系统，推荐使用)

\- cramfs(压缩的只读文件系统，不在线更新数据时推荐使用)

\- Ext2 

\- Fat32

\- NFS(网络文件系统，开发驱动程序及应用程序时方便使用) 



只支持EXT2



统一的交叉编译器==arm-linux-gcc-4.4.3 with EABI==

```
arm-none-linux-gcc-gnueabi
// 工具链

arm-linux-gcc
// 使用
```

\- 最新的 Linux 内核源代码包 ==Linux-2.6.32.2==，包含十分齐全完善的 BSP

Bootloader 源代码(vboot)



SDRAM 地址空间：0x30000000 ~ 0x34000000

另一种是 Nand Flash，型号为 K9F1G08,大小为 128M  (旧版本为 K9F1208，大小为 64Mbyte)



**29**

I2CSCL 

I2CSCL/GPE14 



**30** 

I2CSDA 

I2CSDA/GPE15



MiniTools 刷系统

NFS目录 

开发板mount挂载

```bash
mount -t nfs -o nolock,vers=3 192.168.137.11:/home/book/nfs_roofs /mnt
```

选挂载

讲一下这个项目：

这个项目是基于S3C2440开发的，基于Linux环境下的行车记录仪。然后本项目是今年学习的成果，然后是个人通过一些学习教程综合一下，并且加入一个Socket的上传线程，在Mini2440上来实现自己的项目。项目大体功能像寻常行车记录仪那样，每1分钟录制一段视频，然后另存为.mp4格式文件保存在板载SD卡中，MPU6050时刻采集自身姿态数据和加速度，若姿态异常和加速度突变，则会截止当前录制的视频另存并继续录制，再将SD卡中的最新的5个视频以Socket的形式上传到云服务器上进行保存。



第二个项目，基于S3C2440与Socket的行车记录仪项目是我借助网上一些教学视频在Mini2440上实现出来的，基本就是Linux环境下的多线程应用开发，应为主要目的是应用开发，所以驱动什么的就能移植就移植，稍微修改一下即可。主要功能就是像行车记录仪一样，每1分钟录制一段视频，然后时刻通过MPU6050六轴传感器进行加速度和姿态的解算和检测，当有事故发生，就是姿态异常或者加速度突变，就截止当前录制的视频，并保存为新的一个视频，然后继续录制，将最新的5个视频上传到云端，主要是防止一个现场的火情把录像设备和存储设备给烧毁，就没有了第一手的证据。具体是将系统分为几个线程，录制线程、检测线程和上传线程，一些线程得先休眠，像上传线程可以在检测线程检测出一个事故也就是加速度突变的情况下，才唤醒上传线程。这其中用到条件变量和互斥锁机制来实现。并且设置合适的优先级，事故发生后，上传线程优先级应该是最高的。最终实现一个变相保护现场的功能。





1. 你对 S3C2440 和 MPU6050 的技术规格有了解吗？

   ​		S3C2440是一款由韩国三星电子公司推出的32位嵌入式微处理器，采用ARM920T内核，工作频率为200MHz。它具有强大的计算能力、丰富的外设接口以及低功耗特性，适合用于嵌入式系统领域。它支持各种接口，如UART、I2C、SPI、USB、MMC/SD以及LCD等，可以用于多种应用场合。

   ​		MPU6050是一款六轴运动处理器，由MEMS加速度计和陀螺仪组成。它能够实时测量设备在空间中的加速度和角速度，支持高精度的姿态解算，广泛应用于移动设备、智能家居、游戏设备等领域。它具有小巧、低功耗、高性能等优点，可以通过I2C或SPI接口与主控器连接。

   

2. 请说一下这个项目，画流程图说一下软件程序思路？

   这个项目是基于S3C2440开发板嵌入式Linux开发的一款行车记录仪，用ffmpeg来调用V4l2，alsa等底层音视频采集接口来获取音视频数据，并且

3. 你熟悉 Linux 系统的驱动开发吗？有哪些驱动开发经验？

   是的，我比较熟悉 Linux 系统的驱动开发。

   开发一个I2C驱动程序来读取MPU6050需要经过以下步骤：

   - 首先确定使用哪个I2C控制器来连接MPU6050。在S3C2440中有两个I2C控制器，分别是IIC0和IIC1。需要根据硬件连接关系选择一个I2C控制器。

   - 在Linux内核中加载对应I2C控制器的驱动程序。可以使用现有的内核I2C驱动程序，也可以编写自己的驱动程序。

   - 配置I2C控制器的==时钟和寄存器参数==，以便与MPU6050通信。需要根据MPU6050的通信协议和寄存器地址来进行配置。

   - 编写I2C驱动程序的读写函数。使用I2C控制器提供的API来实现数据的读写，以便与MPU6050进行通信。

   - 对MPU6050的数据进行解析。需要根据MPU6050的数据格式和协议来解析读取到的数据，以得到加速度和角速度等信息。

   - 将读取到的MPU6050数据传输给应用层，以便进行后续处理。

   - 在进行I2C驱动程序的开发时，需要了解MPU6050的寄存器映射关系、数据格式和通信协议，并掌握Linux内核中的I2C驱动程序开发流程和API。

   由于本项目是着重于应用层的开发，所以对驱动程序都是用现成的即可！

   

4. 你了解 IIC 总线的原理和工作方式吗？

   见FreeRTOS二轮平衡小车的问答环节，详细。

5. 你了解设备树吗？

   ​		设备树出现在Linux系统的引导阶段。在Linux内核启动时，启动程序（例如U-Boot）将设备树作为参数传递给内核，内核将其解析并使用它来初始化设备和驱动程序。设备树可以在启动之前预装入到系统中，也可以由引导程序动态生成。

6. 你熟悉 S3C2440 上的 GPIO 端口操作吗？

   ​		S3C2440 是一款嵌入式处理器，提供了多个 GPIO 端口，可以用于连接外部设备或者进行输入输出操作。对于 S3C2440 上的 GPIO 端口操作，可以通过以下几个步骤来实现：

   - 配置 GPIO 端口工作模式：在使用 GPIO 端口之前，需要配置端口的工作模式，包括输入输出模式、上拉下拉模式、中断模式等。可以通过 S3C2440 的控制寄存器来配置 GPIO 端口的工作模式。

   - 设置 GPIO 端口的值：对于输出模式的 GPIO 端口，可以通过设置 GPIO 控制寄存器的值来改变端口的输出状态；对于输入模式的 GPIO 端口，则可以通过读取 GPIO 控制寄存器的值来获取端口的输入状态。

   - 中断处理：如果需要在 GPIO 端口的输入状态发生改变时得到通知，可以通过配置 GPIO 端口的中断模式来实现。在中断处理程序中，可以读取 GPIO 控制寄存器的值来获取端口的状态。

     比如要设置S3C2440的GPIO端口GPH2.0为输出模式，可以按照以下步骤进行操作：

     - 在S3C2440的寄存器手册中查找GPIO端口GPH2.0对应的寄存器地址，一般是通过偏移地址来找到对应的寄存器，比如GPHCON寄存器的偏移地址为0x56000070。
     - 将GPHCON寄存器的相应位设置为1，以将GPH2.0设置为输出模式，具体可以参考寄存器手册中对GPHCON寄存器的描述。
     - 如果需要将GPH2.0的输出电平设置为高电平或低电平，可以通过GPFDAT寄存器来控制，具体也可以参考寄存器手册中对GPFDAT寄存器的描述。

   需要注意的是，对于S3C2440上的GPIO端口操作需要对寄存器操作比较熟悉，以确保正确地设置和读取寄存器的值。

   

7. 你知道如何在 Linux 系统中编写和加载内核模块吗？

   ​		在 Linux 系统中，内核模块是可以动态加载和卸载的。内核模块通常用于添加新的设备驱动程序、文件系统、网络协议栈、安全模块等功能。

   ​		内核模块的编写需要了解内核的 API 和内部机制。一般来说，内核模块的开发流程包括以下步骤：

   - 准备开发环境：安装内核源码、内核头文件、编译工具链等。

   - 编写内核模块代码：使用 C 语言编写内核模块代码，使用内核提供的 API 进行操作。

   - 编译内核模块：使用编译工具链将内核模块源码编译成二进制模块文件。

   - 加载内核模块：==使用 insmod 命令将编译好的内核模块加载到内核中==。

   - 卸载内核模块：==使用 rmmod 命令将已加载的内核模块从内核中卸载==。

     加载内核模块时，内核会为其分配一块内存，并将内核模块的代码和数据拷贝到该内存中。卸载内核模块时，内核会释放该内存，并将该内存标记为可用。


   内核模块的调试可以使用 printk 函数输出调试信息，也可以使用 gdb 调试器进行调试。性能优化可以使用 perf 工具进行分析和优化。

8. Linux操作GPIO怎么操作？简单说一说？

   ​		在 Linux 内核中，有一种抽象出来的结构体来操作 GPIO，就是 `struct gpio_chip`。

   ​		它定义了 GPIO 的一些基本操作，包括获取 GPIO 状态、设置 GPIO 状态等等。

   ​		GPIO 驱动程序需要实现 struct gpio_chip 中的一些回调函数来完成 GPIO 的具体操作。这种抽象的结构体让开发者能够更加方便地操作 GPIO，同时也提高了代码的可读性和可维护性。

   ```c
   //S3C2440 的 GPIO 端口操作可以使用 GPIO API 进行封装，包括以下几个函数：
   
   int gpio_request(unsigned int gpio, const char *label);//请求指定的 GPIO 引脚并设置其标签。
   void gpio_free(unsigned int gpio);//释放指定的 GPIO 引脚。
   int gpio_direction_input(unsigned int gpio);//将指定的 GPIO 引脚设置为输入模式。
   int gpio_direction_output(unsigned int gpio, int value);//将指定的 GPIO 引脚设置为输出模式，并设置初始值。
   int gpio_get_value(unsigned int gpio);//读取指定 GPIO 引脚的值。
   void gpio_set_value(unsigned int gpio, int value);//设置指定 GPIO 引脚的值。
   int gpio_cansleep(unsigned int gpio);//检查指定的 GPIO 引脚是否支持睡眠模式。
   
   //使用这些 API 可以方便地对 GPIO 进行操作，避免了手动操作寄存器的繁琐。
   ```

   ​		使用GPIO.h可以方便地读取设置GPIO口

   ```c
   #include <linux/gpio/driver.h>
   
   // 定义 GPIO 控制器信息结构体
   static struct gpio_chip s3c2440_gpio_chip = {
       .label = "s3c2440-gpio",
       .direction_output = s3c2440_gpio_direction_output,
       .direction_input = s3c2440_gpio_direction_input,
       .get = s3c2440_gpio_get_value,
       .set = s3c2440_gpio_set_value,
       .base = 0,
       .ngpio = 100,
       .can_sleep = true,
   };
   
   // GPIO 控制器初始化函数
   static int __init s3c2440_gpio_init(void)
   {
       int ret;
   
       // 注册 GPIO 控制器
       ret = gpiochip_add(&s3c2440_gpio_chip);
       if (ret < 0) {
           pr_err("Failed to add s3c2440-gpio chip: %d\n", ret);
           return ret;
       }
   
       // 获取 GPIO 控制器信息结构体指针
       struct gpio_chip *gpio_chip = gpiochip_get_data(ret);
   
       // 设置 GPH2.0 为上拉输出
       gpiochip_set_defaults(gpio_chip);
   
       // 设置 GPH2.0 输出电平为高电平
       gpiochip_set_value(gpio_chip, 2, 1);
   
       // 读取 GPH2.0 输入电平
       int value = gpiochip_get_value(gpio_chip, 2);
       pr_info("GPH2.0 value is %d\n", value);
   
       return 0;
   }
   
   // 注册初始化函数
   module_init(s3c2440_gpio_init);
   
   ```

   

9. 你有经验使用过 IIC 设备来读取其他传感器吗？

   传感器没有，EEPROM倒是有读取过。

   

10. 你了解如何使用交叉编译工具链编译 Linux 内核和应用程序吗？

    ​		在交叉编译的过程中，我们需要选择合适的交叉编译工具链，根据目标平台的体系结构和操作系统选择相应的工具链，然后通过配置 Makefile 或其他构建系统来指定交叉编译工具链的路径和其他相关参数。

    - 对于内核的交叉编译，我们需要先下载内核源代码，并根据目标平台的体系结构和操作系统选择合适的内核配置文件，然后运行命令进行内核的配置，最后使用交叉编译工具链进行编译和链接，生成==内核映像文件和模块文件==。

    - 对于应用程序的交叉编译，我们需要先编写程序代码，然后根据程序的编译选项和目标平台的体系结构使用交叉编译工具链进行编译和链接，==生成可执行文件==。需要注意的是，在交叉编译应用程序时，可能需要指定额外的编译选项和库路径，以便正确地链接所需的库文件和头文件。

      

11. 你了解如何在 Linux 系统中进行调试和性能优化吗？

    答出GDB即可，其余就直接说在ubuntu里面进行调试。

    在 Linux 系统中进行调试和性能优化通常需要使用调试工具和性能分析工具。下面是一些常用的工具：

    ==GDB：GDB 是 Linux 系统中最常用的调试工具，它可以对应用程序进行调试，包括单步执行、查看变量值等操作。==

    strace：strace 可以跟踪应用程序的系统调用，它可以帮助我们找到应用程序的瓶颈。

    ltrace：ltrace 可以跟踪应用程序的库函数调用，它可以帮助我们找到应用程序的瓶颈。

    valgrind：valgrind 是一款内存调试和性能分析工具，它可以检查应用程序的内存泄漏、使用未初始化的变量等问题。

    perf：perf 是 Linux 系统中最常用的性能分析工具，它可以跟踪 CPU 的性能指标，如 CPU 使用率、内存访问等情况。

    strace、ltrace、valgrind、perf 都是针对应用程序的调试和性能优化，而 GDB 还可以对内核进行调试。

    

12. 你有经验使用过 Socket 编程吗？你知道如何在 S3C2440 上实现 Socket 编程吗？

    ​		Socket 编程是一种网络编程技术，它允许两个应用程序在网络上进行通信。在 Linux 系统中，可以使用 Socket 编程来实现网络通信。常见的 Socket 类型有两种：流式套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）。

    ​		要在 S3C2440 上实现 Socket 编程，需要按照以下步骤进行操作：

    - 在内核配置中启用 Socket 支持。可以通过 make menuconfig 命令来打开内核配置，并确保以下选项被勾选：CONFIG_NET、CONFIG_PACKET、CONFIG_UNIX、CONFIG_INET、CONFIG_IP_MULTICAST。

    - 编写 Socket 应用程序。在 S3C2440 上运行 Socket 应用程序，需要将其交叉编译为 ARM 架构。可以使用 arm-linux-gcc 工具链进行编译。

    - 运行 Socket 应用程序。在 S3C2440 上，可以使用命令行或者脚本来启动 Socket 应用程序。例如，可以使用 nohup 命令在后台运行应用程序，或者将应用程序设置为系统服务。

      

13. 你了解如何在 Linux 系统中进行多线程编程吗？你觉得在这个项目中需要使用多线程吗？

    ​		在这个项目中，已经提到使用了pthread库实现了多线程服务。因为这个项目涉及到多个功能，比如视频录制、数据采集、事故检测等，这些功能之间可能存在相互影响，同时又需要进行异步处理。所以使用多线程可以提高程序的并发性和响应能力，从而更好地实现这些功能。

    在这个项目中，采用多线程的原因主要有以下几个方面：

    - 数据采集需要实时采集并处理数据，而事故检测需要对采集到的数据进行姿态解算和处理，这些功能之间需要同时运行并且互不干扰，因此可以采用多线程的方式实现。

    - 视频录制和音频采集需要连续不断地进行，采用多线程的方式可以提高程序的响应能力，并且避免阻塞主线程。

    - 数据上云功能需要在后台进行，并且需要检测危险情况进行触发，采用多线程可以实现后台持续运行，并在需要时快速响应。

    综上所述，使用多线程可以提高程序的并发性和响应能力，在这个项目中使用多线程是比较合理和必要的。

    

14. 你了解如何在 S3C2440 上使用 DMA 来提高数据传输速率吗？

    DMA（Direct Memory Access）是一种数据传输技术，它可以在不依赖 CPU 的情况下，直接在外设和内存之间进行数据传输，从而提高数据传输速率和 CPU 利用率。

    S3C2440芯片集成了两个DMA控制器，分别用于外设和内存之间的数据传输。在使用DMA传输数据时，需要首先配置DMA控制器的寄存器，然后让外设或者内存发起DMA请求，触发DMA控制器进行数据传输。传输完成后，DMA控制器会发出中断信号，通知CPU数据已经传输完成。

    对于行车记录仪这种需要高速数据传输的应用，使用DMA技术可以大大提高数据传输速率，提升系统性能。

    在使用DMA技术时，需要了解DMA控制器的寄存器配置，以及如何触发DMA传输。此外，还需要考虑数据传输的安全性，例如DMA传输过程中可能出现数据错误等问题，需要进行相关的错误处理。

    使用 DMA（Direct Memory Access，直接内存访问）来读取 IIC 设备的值，可以大大提高数据传输速率，减少 CPU 占用率。以下是一个简单的示例：

    确认需要使用的 DMA 控制器和 IIC 控制器对应的物理地址，并进行映射。

    配置 DMA 控制器，设置 DMA 通道的源地址、目的地址、传输长度等参数。

    配置 IIC 控制器，设置 IIC 设备的地址、寄存器地址等参数，启动读取操作。

    等待 DMA 传输完成中断，读取目的地址中的数据。

    下面是示例代码：

    ```c
    // 映射物理地址到虚拟地址
    dma_base = ioremap(DMA_BASE_ADDR, DMA_SIZE);
    iic_base = ioremap(IIC_BASE_ADDR, IIC_SIZE);
    
    // 配置 DMA 控制器
    void dma_init(void)
    {
        // 设置 DMA 通道的源地址和目的地址
        writel((unsigned long)iic_base + IIC_RX_DATA, dma_base + DMA_SRC_ADDR);
        writel((unsigned long)buf, dma_base + DMA_DST_ADDR);
    
        // 设置传输长度为1字节
        writel(1, dma_base + DMA_TRANSFER_LEN);
    
        // 配置 DMA 控制寄存器
        writel(DMA_MODE | DMA_SRC_INC | DMA_DST_INC, dma_base + DMA_CTRL_REG);
    }
    
    // 配置 IIC 控制器并启动读取操作
    void iic_read(void)
    {
        // 配置 IIC 控制寄存器
        writel(IIC_START | IIC_ENABLE | IIC_READ, iic_base + IIC_CTRL);
    
        // 等待读取完成
        while(!(readl(iic_base + IIC_STATUS) & IIC_DONE));
    }
    
    // DMA 传输完成中断处理函数
    irqreturn_t dma_irq_handler(int irq, void *dev_id)
    {
        // 读取目的地址中的数据
        unsigned char data = *(unsigned char *)buf;
    
        // 输出读取到的数据
        printk("Read data: %02X\n", data);
    
        // 清除中断标志
        writel(DMA_IRQ_BIT, dma_base + DMA_IRQ_CLEAR);
    
        return IRQ_HANDLED;
    }
    
    // 注册 DMA 中断处理函数
    int dma_init_irq(void)
    {
        // 注册中断处理函数
        if(request_irq(DMA_IRQ, dma_irq_handler, IRQF_SHARED, "dma_irq", NULL))
        {
            printk("Failed to register DMA IRQ handler\n");
            return -1;
        }
    
        // 使能中断
        writel(DMA_IRQ_EN, dma_base + DMA_IRQ_ENABLE);
    
        return 0;
    }
    
    // 主函数
    int main(void)
    {
        // 初始化 DMA 和 IIC 控制器
        dma_init();
        iic_read();
    
        // 注册 DMA 中断处理函数
        dma_init_irq();
    
        // 等待中断
        while(1);
    
        return 0;
    }
    
    ```

    上述代码中，dma_init 函数用于配置 DMA 控制器，iic_read 函数用于配置 IIC 控制器并启动读取操作，dma_irq_handler 函数是 DMA 传输完成中断处理函数，

15. 你了解如何进行软件和硬件协同设计来优化系统性能吗？

    是的，我了解软件和硬件协同设计的概念和方法，这可以帮助优化系统性能。软件和硬件协同设计是指在系统设计的早期阶段，软件和硬件工程师密切合作，共同优化系统性能。通过协同设计，软件和硬件可以同时考虑设计决策，使得整个系统的性能得到最大化的提升。

    在进行软件和硬件协同设计时，需要从以下几个方面进行考虑：

    系统架构设计：要考虑软件和硬件之间的接口和通信机制，以及各个模块的分配和优化。

    硬件设计：需要考虑硬件性能和资源的分配，如处理器、内存、IO等，以及芯片和板级设计的优化。

    软件设计：需要考虑软件算法和代码的优化，以及在硬件上的实现和调试。

    集成测试：要进行全面的系统测试，包括软件和硬件的测试，以确保整个系统能够正常工作并满足性能需求。

    在S3C2440这样的嵌入式系统中，软件和硬件协同设计可以通过以下几种方式进行：

    在系统架构设计时，需要考虑处理器的性能和资源，例如使用DMA来提高数据传输速率，使用中断来处理外部事件等。

    在硬件设计阶段，可以使用优化的芯片和板级设计，例如使用高速总线和外设，以及优化电路布局和信号传输。

    在软件设计时，需要进行代码优化，如使用编译器优化选项，使用高效算法等。

    在集成测试阶段，需要进行全面的测试，包括对软件和硬件的测试，以确保整个系统能够正常工作并满足性能需求。

16. 你知道如何进行实时操作系统（RTOS）开发吗？你觉得在这个项目中是否需要使用 RTOS？

    这个项目不需要RTOS，因为它是搭载了Linux系统的。

    是的，我了解实时操作系统（RTOS）开发。RTOS是为了满足实时性能要求而设计的一种操作系统，它可以提供更好的响应时间和可预测性。

    在这个项目中，如果需要满足实时性能要求，例如需要高精度的数据采集和处理，那么使用RTOS可能是一个不错的选择。RTOS可以帮助实现对任务优先级的控制，实现任务之间的同步和通信，以及提供实时调度和中断处理等功能。这些都有助于提高系统的性能和可靠性。

    当然，是否需要使用RTOS还要根据具体的项目需求和实际情况来确定。如果项目的实时性能要求不高，或者硬件资源有限，使用RTOS可能会带来额外的开销和复杂性。因此，在决定是否使用RTOS时，需要进行综合考虑和评估。

17. 你知道如何使用 CMake 等工具来管理代码编译和构建吗？

    是的，我可以介绍一下 CMake 和其他类似工具。

    CMake 是一个跨平台的开源构建工具，它可以生成针对不同平台的 Makefile、Visual Studio 等 IDE 的项目文件，从而实现自动化构建。CMake 提供了一种简单的方式来管理项目依赖关系、编译选项、测试、安装等构建任务，同时可以方便地生成各种构建工具所需的文件，比如编译器的编译选项、链接器的库搜索路径等。

    CMake 的配置文件是 CMakeLists.txt 文件，该文件包含了项目的配置信息和编译规则，可以使用简单的语法定义源文件、头文件、库文件、编译选项等信息。通过 CMake 进行构建时，可以生成 Makefile 或 IDE 项目文件，然后使用相应的构建工具来构建项目。

    除了 CMake，还有其他类似的构建工具，比如 GNU Autotools、Make 等。它们都可以帮助我们管理项目的编译和构建，提高开发效率。CMake是一款开源的跨平台构建工具，可以用于自动化生成makefile和构建代码。以下是使用CMake构建项目的一般步骤：

    编写CMakeLists.txt文件，该文件包含项目名称、编译选项、目标、库和其他构建规则等信息。

    创建一个构建目录，进入该目录并运行cmake命令，指定源代码目录和其他选项，例如构建类型（Debug或Release）和目标平台等。

    运行make命令进行编译，或者使用其他构建工具如ninja等。

    运行生成的可执行文件进行测试。

    可以使用cmake --build . --target <target>命令来编译指定的目标。

    CMake还支持其他高级功能，如自动生成文档、测试、安装等，可以通过编写CMakeLists.txt文件来使用这些功能。

18. 你了解如何进行版本控制和团队协作开发吗？

    Git，详情请看前面部分。

19. 你知道如何在 S3C2440 上实现文件系统和存储管理吗？

    是的，我可以回答你关于在 S3C2440 上实现文件系统和存储管理的问题。

    S3C2440 内置了一些存储设备，如 NAND Flash、SD/MMC 卡等，因此实现文件系统和存储管理需要考虑如下几个方面：

    存储设备驱动程序的开发：需要针对 S3C2440 的硬件特性，编写相应的驱动程序，以便能够与 NAND Flash、SD/MMC 卡等存储设备进行通信。

    文件系统的选择：Linux 内核中有许多文件系统可供选择，如 ext4、NTFS、FAT 等，开发者需要根据实际应用场景选择合适的文件系统。

    文件系统驱动程序的开发：需要根据所选择的文件系统，编写相应的文件系统驱动程序，以便能够在操作系统中进行挂载和使用。

    存储管理：在应用程序中，需要实现存储管理的功能，如文件读写、文件夹操作、文件格式转换等。

    需要注意的是，S3C2440 的存储设备与 PC 机的存储设备相比较，存在许多差异，因此需要针对 S3C2440 的硬件特性进行优化，以保证文件系统和存储管理的性能和稳定性。

20. 你了解如何使用 ARM 开发板上的硬件调试器来进行调试吗？

    是的，我可以回答这个问题。

    常见的 ARM 开发板上的硬件调试器有 JTAG 和 SWD，它们可以用来在开发板上调试运行中的程序，包括内核和应用程序。

    使用硬件调试器进行调试的流程一般包括以下步骤：

    连接调试器：将调试器连接到开发板上的调试接口上（通常是 JTAG 或 SWD 接口）。

    配置调试器：使用调试器的软件工具（如 OpenOCD）来配置调试器和目标处理器的连接参数。

    启动调试器：启动调试器的软件工具，连接到目标处理器，然后进入调试模式。

    设置断点：在程序中设置断点，可以在代码执行到指定的位置时停止程序的执行，方便调试。

    单步执行：使用调试器的单步执行功能可以逐条执行代码，并观察程序状态的变化。

    查看寄存器：通过调试器可以查看目标处理器中各个寄存器的值，方便了解程序执行状态。

    查看内存：可以使用调试器查看目标处理器的内存，了解程序运行时的数据状态。

    模拟外设：一些调试器支持模拟外设，可以在调试器上模拟一些外设的输入输出，方便测试程序与外设的交互。

    使用硬件调试器进行调试可以大大提高开发效率和调试精度，特别是在处理器性能高、程序复杂的情况下，使用硬件调试器进行调试可以事半功倍。

21. 你熟悉 ARM 体系结构和指令集吗？你知道如何进行 ARM 汇编语言编程吗？

    作为一名 AI，我可以说我对 ARM 体系结构和指令集有一定的了解，并且可以支持 ARM 汇编语言编程。

    ARM 是一种流行的 CPU 架构，广泛应用于嵌入式系统中。ARM 汇编语言是一种底层的编程语言，可以直接控制 CPU 执行指令。与高级编程语言相比，ARM 汇编语言具有更高的执行效率和更好的硬件控制能力，但编写起来更加复杂和繁琐。

    在 ARM 汇编语言编程中，需要掌握 ARM CPU 的寄存器、指令集、内存操作等基本概念，以及编写汇编代码的语法和规则。可以使用 GNU 工具链中的汇编编译器 as 来将汇编代码转换为可执行的机器码，并且可以使用 objdump 来查看生成的机器码的指令和数据。

    需要注意的是，由于 ARM 架构有多个版本，因此在编写汇编代码时需要选择适合目标硬件的指令集。例如，在 S3C2440 开发板中，使用的是 ARMv4T 指令集，需要在汇编代码中使用对应的指令集。同时，为了保证代码的可读性和可维护性，应该尽量避免过多的使用汇编代码，优先考虑使用高级编程语言进行开发。

22. 你了解如何进行软硬件接口设计和调试吗？

    是的，我了解如何进行软硬件接口设计和调试。

    在软硬件接口设计方面，我们需要考虑硬件和软件之间的通信方式以及数据格式。通常情况下，硬件提供的接口是基于寄存器或者总线的方式，而软件则需要通过读取寄存器或者总线的方式来获取硬件的状态和数据。

    在调试方面，我们需要先确定问题所在，然后通过调试工具和方法来定位和解决问题。常用的调试工具包括逻辑分析仪、示波器、仿真器等，而调试方法则包括单步调试、断点调试、追踪调试等。

    需要注意的是，在进行软硬件接口设计和调试时，需要充分考虑系统的可靠性和稳定性，以确保系统能够正常运行并且不会出现意外情况。

23. 你觉得这个项目存在哪些难点和挑战？你有什么解决方案和优化建议？

    在嵌入式系统中，特别是在对硬件进行控制的项目中，常常需要深入理解硬件的工作原理，并熟悉底层驱动程序的编写。因此，这个项目可能存在以下难点和挑战：

    硬件的工作原理：需要了解 MPU6050 传感器和 S3C2440 处理器的原理和特性，包括 MPU6050 的数据格式和传输协议，以及 S3C2440 的 GPIO、IIC、DMA 等硬件模块的使用方法和时序要求等。

    驱动程序的编写：需要了解 Linux 操作系统的内核模块开发和设备驱动开发技术，以及如何使用 IIC 接口和 DMA 控制器来读取 MPU6050 传感器的数据。

    数据处理和算法设计：需要对传感器的原始数据进行处理和滤波，以及设计相应的算法来实现姿态解算等功能。此外，还需要考虑数据的存储和传输问题，例如采用何种数据格式、如何传输数据等。

    系统性能优化：在实现数据处理和算法的同时，还需要考虑系统性能优化的问题，例如如何降低系统的资源占用率、如何提高数据传输和处理的效率等。

    为了解决这些难点和挑战，可以采取以下一些方案和优化建议：

    深入理解硬件原理和特性，包括数据格式、时序要求等。可以查阅相关的数据手册、参考资料和实验结果，并通过仿真软件模拟硬件工作状态来加深理解。

    采用模块化设计和封装技术，将不同的功能模块分离开来，便于调试和维护。例如，将传感器的读取、数据处理和算法设计等功能模块分别实现，并在应用程序中进行调用。

    采用性能优化技术，例如使用 DMA 控制器来提高数据传输效率，使用多线程技术来提高数据处理效率，使用硬件加速技术来加速算法执行等。

    进行系统调试和性能测试，查找系统的瓶颈和问题，并针对性地进行优化和改进。可以采用调试工具和性能测试工具来进行测试和分析，例如 GDB、strace、perf 等。

    进行版本控制和团队协作开发，采用 Git 等版本控制工具来管理代码，便于多人协作开发和代码维护。同时，可以采用代码审查和测试等质量保证措施来确保代码的质量

24. 你是如何选择和配置 ffmpeg 的编解码器和格式器的？这是否对性能和存储空间造成了影响？

    在上述项目中，需要根据实际需求选择和配置 ffmpeg 的编解码器和格式器。首先需要确定需要处理的音视频格式和编解码要求，例如是否需要支持 H.264 视频编码和 AAC 音频编码。然后根据需求选择合适的编解码器和格式器，比如 libx264 编码器和 libfdk_aac 解码器。同时，还需要根据实际情况配置编解码参数，例如码率、分辨率等。

    选择和配置合适的编解码器和格式器对性能和存储空间都有影响。选择高效的编解码器可以提高处理速度和减少存储空间的占用，而不合适的编解码器可能会导致性能下降和存储空间浪费。同时，配置合适的编解码参数也可以对性能和存储空间产生影响。例如，增加视频的码率和分辨率会导致处理速度变慢和存储空间增加，而减少视频的码率和分辨率则可以提高处理速度和减少存储空间的占用。因此，在选择和配置编解码器和格式器时，需要综合考虑性能和存储空间的需求。

25. 你了解 ffmpeg 的原理和内部实现吗？它与音视频采集的底层实现有哪些联系和区别？

    FFmpeg是一个流行的开源跨平台音视频处理库，可以对音视频进行编解码、转码、过滤、采集等操作。它采用 modularity 设计，以多个独立的库组件组成，包括 libavcodec、libavformat、libavutil、libswscale 等。这些组件可以分别用于音视频编解码、封装和格式转换、工具函数、图像缩放等操作。

    在音视频采集的底层实现中，通常会使用特定的驱动程序或硬件模块来实现对摄像头或麦克风等硬件设备的访问和数据采集。在采集到音视频数据后，可以将数据通过 FFmpeg 提供的 API 接口传递给 FFmpeg 进行后续的处理。FFmpeg 支持多种音视频编解码格式和容器格式，用户可以根据自己的需要选择合适的编解码器和格式器进行配置。同时，由于 FFmpeg 库是一个通用的音视频处理库，对于特定的应用场景，也可以进行相应的定制和优化，以满足不同的性能和存储需求。

    FFmpeg 内部实现的细节较为复杂，涉及到音视频压缩算法、封装格式等方面的知识。对于使用 FFmpeg 进行音视频处理的开发者来说，需要了解 FFmpeg 的基本架构和接口设计，以及相关的音视频编解码知识和格式规范。

26. 你对音视频采集的帧率、分辨率和编码质量有什么要求？如何实现对这些参数的控制和调整？

    对于本项目的音视频采集，通常会有一定的帧率、分辨率和编码质量的要求。这些要求通常由项目的具体需求和硬件性能决定。

    在实现音视频采集时，通常可以通过以下方式来控制和调整这些参数：

    帧率控制：通过设置采集设备的帧率参数来控制帧率，可以使用常用的接口和协议，例如 V4L2 和 DirectShow。

    分辨率控制：通过设置采集设备的分辨率参数来控制分辨率，可以使用常用的接口和协议，例如 V4L2 和 DirectShow。

    编码质量控制：可以使用 FFmpeg 提供的编码器 API 来调整编码质量参数，例如码率和量化系数等。

    同时，在采集过程中，也可以根据采集设备和应用程序的实际情况对这些参数进行动态调整和优化，以获得更好的采集效果和性能表现。

27. 你对音视频采集的时延和抖动有什么要求？如何通过缓冲和同步机制来实现？

    本项目对音视频采集的时延和抖动有一定的要求，特别是对于实时视频传输的应用。一般来说，需要将音视频采集和传输的时延控制在可接受范围内，同时减小抖动，确保接收端可以正常播放。

    为了实现对时延和抖动的控制，一种常见的方法是采用缓冲和同步机制。具体而言，可以在采集端和传输端都加入一定大小的缓冲区，用来存储待传输的音视频数据。在传输过程中，采集端和传输端可以通过一定的同步机制来协调数据的传输和处理，以控制时延和抖动。例如，可以采用时间戳来标识每一帧音视频数据的播放时间，以便接收端能够按照正确的时间顺序播放。

    此外，还可以采用一些技术手段来减小时延和抖动。例如，可以采用一些流控制技术来控制传输带宽和数据流量，以便在网络拥塞或带宽波动的情况下，能够自适应地调整数据传输速率，以减小时延和抖动。还可以采用一些数据压缩和加密技术来优化数据传输效率和安全性。

28. 你对音视频采集的数据传输方式有什么要求？如何通过网络传输或者存储设备传输来实现？

    在本项目中，对于音视频采集的数据传输方式，主要有以下要求：

    实时性：采集的音视频数据需要在一定时间内传输到接收端，以保证实时性和连续性。
    可靠性：传输过程中需要保证数据的可靠性，避免数据丢失或者损坏。
    带宽效率：传输过程中需要尽量利用有限的带宽资源，保证数据传输的高效率。

    为了实现这些要求，可以采用以下方式来进行音视频数据的传输：

    网络传输：使用网络传输可以方便地将采集的音视频数据传输到远程的接收端。可以选择 TCP 或者 UDP 协议进行传输，也可以使用 RTP/RTCP 协议来保证实时性和可靠性，并且在传输过程中可以进行流量控制和拥塞控制来提高带宽效率。
    存储设备传输：将采集的音视频数据存储到本地设备中，如硬盘或者闪存卡，并通过 USB 接口或者 SDIO 接口将数据传输到接收端。这种方式可以避免网络传输的时延和带宽限制，并且可以方便地进行后续的数据处理和分析。

    在实现音视频数据传输时，需要考虑数据缓冲和同步机制，以保证数据的实时性和连续性。可以使用循环缓冲区来进行音视频数据的缓存和传输，同时在接收端需要进行数据同步和处理，以保证音视频数据的同步和播放的流畅性。

29. 你了解音视频采集的标准和法规吗？如何保证采集数据的合法性和规范性？

    是的，我了解一些音视频采集的标准和法规。

    在音视频采集过程中，需要遵守国际标准和法规，如ISO、ITU、EIA、CE、FCC、RoHS等，以确保采集数据的合法性和规范性。例如，音频采集需要满足ISO 266、ITU-T G.711、G.722、G.726、G.728等标准，视频采集需要满足ITU-T H.264、H.265、MPEG-2、MPEG-4等标准。此外，还需要遵守数据保护和隐私保护的相关法规。

    为了保证采集数据的合法性和规范性，可以采取以下措施：

    选用符合标准和法规的硬件设备和软件工具；
    对采集数据进行严格的验证和检测，以确保其符合规范和标准；
    遵循数据保护和隐私保护的相关法规，如加密数据传输、保护用户隐私等；
    实施访问控制和权限管理，以确保采集数据仅被授权人员访问和处理；
    定期更新软件和固件，修复已知漏洞，以确保数据的安全和可靠性。

30. 你对 Linux 设备驱动框架和内核模块有什么了解？

    Linux设备驱动框架是Linux内核中的一个重要组成部分，它为各种硬件设备提供了标准化的接口和驱动程序，使得开发人员可以更加方便地编写驱动程序。Linux设备驱动框架通常由以下组成部分：

    1.字符设备驱动：用于访问字符设备（如串口、终端等）的驱动程序。

    2.块设备驱动：用于访问块设备（如硬盘、U盘等）的驱动程序。

    3.网络设备驱动：用于访问网络设备（如网卡）的驱动程序。

    4.USB设备驱动：用于访问USB设备的驱动程序。

    5.I2C设备驱动：用于访问I2C总线设备的驱动程序。

    6.其他设备驱动：用于访问其他设备（如音频设备、摄像头等）的驱动程序。

    内核模块则是一种动态加载到Linux内核中的代码，它可以添加新的功能或者修改已有的功能。内核模块可以由开发人员编写，也可以由第三方开发人员编写并发布。内核模块通常由以下组成部分：

    1.初始化函数：用于初始化内核模块并注册设备驱动程序。

    2.读写函数：用于对设备进行读写操作。

    3.控制函数：用于控制设备的状态，如打开或关闭设备等。

    4.中断处理函数：用于处理设备产生的中断。

    开发人员可以利用Linux设备驱动框架和内核模块来实现各种硬件设备的驱动程序，从而让这些硬件设备能够被Linux系统所识别和使用。

31. 你了解如何使用 Linux 内核的 I/O 接口、中断处理、内存管理等机制吗？

    作为一个语言模型，我了解和掌握了这些概念和机制，以下是一些简要的介绍：

    I/O 接口：Linux 内核提供了许多 I/O 接口，例如字符设备、块设备、网络设备等。它们通过文件系统进行访问，应用程序可以使用标准的文件操作函数来进行 I/O 操作。
    中断处理：Linux 内核通过中断处理程序来响应硬件设备的中断请求。中断处理程序通常需要尽快完成处理并返回，以避免影响系统的响应性能。
    内存管理：Linux 内核负责管理系统的内存资源，包括内存分配、释放、映射等。它使用虚拟内存机制来为每个进程提供独立的内存地址空间，以保证进程之间的隔离和安全。
    系统调用：Linux 内核提供了许多系统调用，例如读写文件、创建进程、网络通信等。应用程序可以通过这些系统调用来访问系统资源和执行系统功能。

    在 Linux 驱动开发中，这些机制都是非常重要的，开发人员需要了解它们的原理和使用方法，以保证驱动程序的性能、可靠性和安全性。

32. 你了解如何使用 Linux 的系统调用、文件操作和网络协议等机制吗？

    是的，作为一个常用的操作系统，Linux提供了丰富的系统调用、文件操作和网络协议等机制，开发者可以使用这些机制来实现各种功能。

    其中，系统调用是Linux中最基本的机制之一，它允许应用程序与操作系统内核交互，并使用操作系统提供的服务。例如，开发者可以使用系统调用来打开或关闭文件、分配或释放内存、创建或销毁进程等。

    文件操作也是Linux中常用的机制之一，开发者可以使用文件操作来读取或写入文件、修改文件权限、创建或删除文件等。文件操作可以通过系统调用函数来实现，例如open(), read(), write(), close()等。

    此外，网络协议也是Linux中非常重要的机制之一，开发者可以使用它来实现网络通信。Linux支持多种网络协议，例如TCP/IP、UDP、HTTP等。开发者可以使用socket编程接口来实现网络通信。

    总的来说，Linux提供了丰富的系统调用、文件操作和网络协议等机制，这些机制为开发者提供了很大的灵活性，使得他们可以轻松地实现各种功能。

33. 你考虑过 Linux 驱动开发的性能、可靠性和安全性问题吗？

    Linux驱动开发的性能、可靠性和安全性是非常重要的问题。以下是一些考虑这些问题的建议：

    性能问题：在驱动开发中，需要考虑到系统的实时性和响应速度。因此，驱动程序需要尽可能高效地执行，以确保系统的性能和稳定性。为了提高性能，驱动程序可以采用一些技术，例如使用DMA传输和中断处理等技术。

    可靠性问题：驱动程序需要能够在不同的硬件和软件环境中工作。因此，驱动程序需要经过全面的测试，以确保其能够在各种情况下正常运行。在编写驱动程序时，需要仔细考虑错误处理机制，以避免发生不可预料的错误。

    安全性问题：驱动程序可以访问系统的关键资源，因此，驱动程序的安全性非常重要。驱动程序应该使用安全的编码实践，并在代码中处理输入的数据，以避免发生缓冲区溢出和其他安全漏洞。此外，驱动程序也应该遵循最小特权原则，以确保其只能访问必要的资源。

    综上所述，Linux驱动开发需要考虑到性能、可靠性和安全性等问题，并采取相应的措施来确保驱动程序的质量和稳定性。

34. 你了解 ARM 的寄存器和指令集吗？

    是的，ARM是一种处理器架构，具有一套特定的寄存器和指令集，这些寄存器和指令集是为了提高处理器性能而设计的。

    ARM处理器的寄存器包括通用寄存器、状态寄存器、程序计数器、堆栈指针等。通用寄存器用于存储数据和地址，状态寄存器包括程序状态寄存器（CPSR）和当前程序状态寄存器（SPSR），用于存储程序状态信息和处理器模式信息。程序计数器用于存储下一条指令的地址，堆栈指针用于存储程序的堆栈地址。

    ARM指令集包括数据处理指令、存储器指令、分支指令和异常指令等，其中数据处理指令包括算术指令、逻辑指令、移位指令等，存储器指令包括数据传输指令、加载/存储指令等，分支指令包括无条件分支指令、条件分支指令等，异常指令包括软件中断指令、硬件中断指令等。这些指令可以直接操作ARM寄存器，完成各种计算和处理任务，提高处理器的性能和效率。

35. 你了解ARM指令集和x86指令集吗？

    ARM指令和x86指令在指令集架构和编码方式上都存在很大的不同。

    首先，ARM指令集是RISC（精简指令集计算机）体系结构，而x86指令集是CISC（复杂指令集计算机）体系结构。RISC体系结构在指令数量和复杂度上要比CISC少得多，使得RISC架构的处理器具有更高的运行速度和更低的功耗。

    其次，ARM指令集采用固定长度的32位指令，而x86指令集采用可变长度的指令。这使得ARM指令集具有更好的代码密度，使得ARM处理器在缓存大小较小时，性能更优。

    最后，ARM指令集的编码方式与x86指令集有很大不同。ARM指令采用三地址格式，操作数显式地出现在指令中，而x86指令则采用栈式指令格式，其中操作数在堆栈上压入和弹出。这使得ARM指令在编译和优化时更容易处理，可以使代码更加高效。

    总的来说，ARM指令和x86指令之间存在很大的差异，这些差异导致了它们在不同的体系结构下表现出不同的优势。

36. 你了解 ARM 的中断处理和时钟控制机制吗？

    是的，ARM是一种基于RISC架构的微处理器，中断处理和时钟控制是其重要的功能之一。

    中断处理是指当外部事件需要处理时，CPU能够快速地停止当前的运行任务，转而去处理这个事件，完成事件的处理后，再返回到原来的任务中去。ARM中断处理分为两种：IRQ（普通中断）和FIQ（快速中断）。IRQ是用于一般性中断处理，而FIQ则用于实时性要求比较高的中断处理。在ARM中，中断处理的优先级可以通过VIC（Vectored Interrupt Controller）来配置。

    时钟控制是指对ARM处理器的时钟进行控制，以保证ARM能够正常运行。时钟控制主要包括两个方面，一个是时钟源的选择，另一个是时钟的分频。

    在ARM中，时钟源可以从外部输入，也可以从内部产生，通常由PLL（Phase Locked Loop）电路产生。时钟的分频可以通过时钟分频器来实现，时钟分频的目的是为了降低CPU频率，从而节约功耗和减少EMI（Electromagnetic Interference）。

    总之，中断处理和时钟控制是ARM处理器的重要特性，其正确的配置和使用对于系统的稳定性和性能都有重要影响。

37. 你了解 ARM 的工作模式和状态转换机制吗？

    ARM是一种基于RISC（Reduced Instruction Set Computing）的CPU架构，具有三种基本工作模式：用户模式、特权模式和系统模式。不同模式的主要区别在于可访问的硬件资源和指令集。

    用户模式：在用户模式下，CPU只能访问受保护的硬件资源和指令集，例如普通应用程序的运行环境。

    特权模式：在特权模式下，CPU可以访问所有的硬件资源和指令集，例如操作系统内核的运行环境。

    系统模式：系统模式类似于特权模式，但不支持中断响应。

    状态转换机制是指在不同的工作模式之间进行转换的机制。状态转换通常由异常处理程序触发，例如中断、系统调用、错误等。

    在ARM架构中，状态转换是通过一种称为Exception Model的机制实现的。当一个异常被触发时，CPU会自动从当前工作模式转换到相应的异常模式，例如IRQ（Interrupt Request）模式或FIQ（Fast Interrupt Request）模式，以响应中断或快速中断请求。在异常模式下，CPU会执行相应的异常处理程序，并在处理程序完成后返回到之前的工作模式。

38. 你了解如何编写 ARM 汇编代码和 C 语言嵌入式代码吗？

    作为一名AI语言模型，我可以提供一些关于ARM汇编代码和C语言嵌入式编程的基础知识，但是具体实现方面可能需要更加专业的工程师来解答。

    ARM汇编代码是一种低级别的编程语言，它直接操作机器指令来实现特定功能。ARM汇编代码通常用于对硬件进行底层操作，例如对设备寄存器的读写。在ARM汇编代码中，每个指令都是一个特定的机器指令，可以直接与硬件交互，提供了对硬件的高度控制。

    C语言是一种高级编程语言，通常用于编写嵌入式系统软件。C语言提供了抽象层来隐藏硬件细节，并提供了各种库和框架来简化编程过程。嵌入式C编程需要了解硬件和底层操作系统，以确保代码能够正确地与底层硬件交互。

    对于ARM汇编代码和C语言嵌入式编程，了解硬件架构和指令集是很重要的。另外，熟悉操作系统和软件开发工具也是必要的，例如GCC编译器和GDB调试器。在实际开发中，通常需要结合使用ARM汇编代码和C语言，以实现系统的底层硬件控制和高级应用程序逻辑。

39. 你在项目中使用了Ubuntu作为开发环境，请问你选择Ubuntu的原因是什么？

    很大一部分原因是以往的习惯，因为之前开发服务器，搭建服务器啥的都用的是Ubuntu，也习惯了Ubuntu的操作，而且它有图形化界面，一些命令很不直观就可以使用图形化界面。还有就是资料齐全，社区大，遇到什么问题可以解决，下载安装一些交叉编译工具链也挺简单。

40. 你在项目中使用了交叉编译，你能够解释一下什么是交叉编译吗？为什么需要交叉编译？

    交叉编译是在一台计算机上编译出另一种计算机上可以运行的程序的过程。通常情况下，编译器和开发环境运行在一台主机上，生成的目标文件需要在另一种不同架构的目标平台上运行。

    交叉编译主要用于嵌入式开发、嵌入式Linux和移动设备等领域。原因是嵌入式设备通常具有特定的处理器架构和操作系统，与PC或服务器等主机的处理器架构和操作系统不同，因此需要使用交叉编译器将代码编译为适合目标设备的二进制文件。同时，嵌入式设备通常性能有限，无法运行编译器和开发环境，因此需要在主机上进行编译。

    交叉编译的好处是可以在不同的平台上进行开发和测试，提高了开发效率，同时还能够减少目标设备上的资源占用和加快程序的运行速度。

41. 你在项目中使用了pthread库来实现多线程服务，请问你具体是如何使用这个库的？

    

42. 你在项目中使用了MPU6050加速度计实时采集数据并姿态解算，并借此实现事故检测，请介绍一下你的姿态解算算法是如何实现的？

    参考FreeRTOS蓝牙自平衡小车中的案例，不过这里可以简化，因为一般事故发生其姿态都会有一个较大的突变。

43. 你在项目中使用了FFmpeg调用V4L2和ALSA-LIB的标准化接口来实现视频采集和音频采集，并编码复用为MP4文件存储在SD卡中，请介绍一下这个过程是如何实现的？

44. 你在项目中使用了数据上云功能，请介绍一下你的数据上云实现方式和具体实现细节。

    数据上云是指将本地采集到的数据上传到云端存储，以便于在不同的终端上进行访问和处理。在实现数据上云的过程中，需要考虑数据的安全性、传输速度、可用性等因素。

    一般来说，数据上云可以通过以下几种方式实现：

    HTTP/HTTPS上传：使用HTTP或HTTPS协议将数据上传到云端服务器。这种方式简单易用，但传输速度受网络带宽和服务器处理能力影响较大。

    FTP上传：使用FTP协议将数据上传到云端服务器。FTP协议传输速度较快，但需要配置FTP服务器和FTP客户端，使用起来不太方便。

    第三方云存储服务：使用第三方云存储服务（如阿里云OSS、腾讯云COS等）将数据上传到云端存储。这种方式需要先注册并开通第三方云存储服务，并在项目中调用相应的API进行数据上传和下载。

    具体实现细节则需要根据具体的实际情况而定。一般来说，需要实现以下几个步骤：

    数据压缩和加密：在上传之前需要将数据进行压缩和加密，以提高传输速度和保障数据安全性。

    数据传输：根据选择的上传方式，调用相应的API将数据传输到云端。

    数据存储：将上传的数据保存到云端存储，可以选择存储在特定的文件夹或者数据库中。

    数据下载：在需要访问数据时，可以通过调用API将数据从云端下载到本地。

    需要注意的是，数据上云涉及到数据的安全性和隐私问题，需要采取一系列的措施来保护数据的安全性。同时，上传和下载速度也需要考虑网络带宽、传输距离等因素，合理地选择上传方式和云存储服务商，并进行相应的优化，以提高数据上传和下载的效率。

45. 你在项目中使用了多线程，你是如何考虑线程安全的？

    在多线程的环境下，为了保证程序的正确性和可靠性，必须考虑线程安全的问题。以下是一些常见的线程安全技术：

    互斥锁：在共享资源的读写操作之前，对共享资源进行加锁，保证同一时间只有一个线程对资源进行读写操作，防止出现竞争条件，从而保证线程安全。

    条件变量：条件变量通常和互斥锁一起使用，通过条件变量，线程可以等待某个条件的发生，直到条件满足后再进行相应的操作。条件变量可以用于线程间通信和同步。

    原子操作：原子操作是指不可分割的操作，即一个操作要么全部执行，要么都不执行，不会被其他线程打断。原子操作通常是硬件级别的操作，可以保证线程安全。

    读写锁：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。这样可以提高读操作的并发性，减少写操作的竞争。

    消息队列：线程之间通过消息队列进行通信，每个线程有自己的消息队列，可以向其他线程发送消息，从而实现线程之间的协作和同步。

    在项目中，可以根据具体的场景和需求，选择适当的线程安全技术，保证程序的正确性和可靠性。

46. 你在项目中使用了多线程，你是如何处理线程间的通信和同步的？

    在多线程的项目中，线程之间的通信和同步非常重要。下面是我通常使用的一些方法：

    互斥锁和条件变量：互斥锁用于保护临界区，条件变量用于在线程间同步。线程可以等待条件变量被设置，然后再继续执行。

    信号量：信号量是一个计数器，用于在线程之间共享资源。当某个线程要访问某个资源时，它会尝试获取信号量。如果信号量的计数器大于0，线程就可以访问资源，否则线程就会被阻塞，直到有信号量可用为止。

    共享内存：共享内存是一种特殊的内存区域，用于在进程间共享数据。多个线程可以通过访问同一块共享内存来共享数据。但是，由于共享内存没有同步机制，因此需要使用其他方法来保护共享内存。

    管道和消息队列：管道和消息队列是用于在线程之间传递数据的机制。管道是一种半双工的通信机制，可以在两个相关进程之间进行通信。消息队列是一种进程间通信机制，可以实现异步通信。

    读写锁：读写锁是一种特殊的锁，用于保护对共享数据的读和写操作。多个线程可以同时读取共享数据，但只有一个线程可以写入共享数据。这种锁可以提高读取操作的并发性能。

    在实际项目中，我通常会根据不同的需求和场景来选择不同的线程通信和同步方法，以达到最佳的性能和稳定性。

47. 你在项目中使用了多线程，你是如何处理线程的优先级和调度的？

    在项目中处理线程的优先级和调度的方法因操作系统而异，不同的操作系统可能有不同的优先级和调度机制。一般来说，可以使用操作系统提供的 API 或库函数来设置线程的优先级和调度策略。例如，在 Linux 系统下，可以使用 pthread 库提供的函数 pthread_attr_setschedparam 和 pthread_attr_setschedpolicy 来设置线程的优先级和调度策略。一般来说，可以根据线程的任务类型和优先级来设置线程的调度策略，以实现最优的性能和响应时间。

    在设置线程优先级和调度策略时需要注意以下几点：

    不要将所有线程的优先级都设置为最高，这可能会导致其他任务无法运行，造成系统崩溃或死锁。

    尽量避免使用抢占式调度，因为频繁的上下文切换可能会降低系统性能。

    根据不同线程的任务类型和优先级，合理地设置线程的调度策略，以实现最优的性能和响应时间。

    在设置线程的优先级和调度策略时，需要考虑系统负载和资源限制等因素，以避免资源浪费和竞争条件的出现。

48. 你在项目中处理了视频和音频采集，你有没有考虑过视频和音频同步的问题？如果有，你是如何处理的？

    在音视频采集过程中，为了实现视频和音频的同步播放，需要对采集到的音视频进行时间戳的设置和同步。通常情况下，视频和音频的时间戳是通过硬件设备的时间戳产生器来生成的，因此时间戳的精确度比较高。

    在使用FFmpeg处理音视频数据时，它会自动处理时间戳，为每个音视频帧分配正确的时间戳，并将它们封装到容器格式中。在播放过程中，需要将音视频帧解码并缓存到队列中，然后根据时间戳从缓存中读取并播放对应的帧，以实现音视频的同步。

    如果视频和音频同步出现问题，比如出现了音画不同步的情况，可以通过以下几个方面进行调试和处理：

    检查采集设备的时间戳设置是否正确，以及是否存在延迟等问题。

    检查采集的音视频数据是否正确，以及时间戳是否正确设置，是否出现了时间戳跳跃或者倒退等问题。

    检查解码器的性能和配置是否合适，是否需要对解码器进行优化和调整。

    调整音视频播放的缓冲策略，增加缓冲区大小或者调整缓冲时间，以提高音视频同步的精度和稳定性。

    使用一些调试工具，比如FFmpeg自带的调试工具、音视频帧调试工具等，来分析和解决音视频同步问题。

49. 你在项目中使用了SD卡存储数据，请问你是如何处理SD卡的读写和错误处理的？

    在使用 SD 卡存储数据时，可以使用操作系统提供的文件系统（如FAT32）来管理文件，使用文件系统提供的 API 进行读写操作。在读写数据时，需要注意以下几点：

    读写时需要检查 SD 卡是否插好，如果没有插好则应该提示用户插好 SD 卡。

    读写时需要检查文件系统是否已经挂载成功，如果没有挂载成功则应该重新尝试挂载。

    写入数据时需要考虑 SD 卡的寿命和性能问题。可以采用扇区缓存、多块写入、定时刷新等方式来提高写入效率，并减少 SD 卡的写入次数。

    读取数据时需要注意读取的大小和频率，可以采用预读取、缓存、异步读取等方式来提高读取效率。

    在处理 SD 卡的错误时，应该考虑到以下几种情况：

    读写操作出现错误时，应该对错误码进行解析并进行相应的处理。例如，如果是因为 SD 卡被拔出导致的错误，可以提示用户重新插入 SD 卡；如果是因为 SD 卡已满导致的错误，则可以提示用户删除一些文件来释放空间。

    如果 SD 卡出现坏块，则可以采用坏块管理机制来处理。例如，可以将坏块标记为不可用，并且不再使用这些块存储数据，以避免数据丢失。

    在进行 SD 卡格式化时，应该采用正确的格式化方式，以免造成数据丢失和硬件损坏。

50. 你在项目中使用了FFmpeg，你有没有考虑过FFmpeg的性能问题？如果有，你是如何优化的？

    在使用 FFmpeg 的过程中，有一些性能问题需要考虑和优化，比如：

    解码器的解码速度：在解码视频的过程中，解码器的解码速度是非常关键的，因为它直接决定了视频播放的流畅度。为了优化解码速度，可以使用硬件加速（如 GPU 解码）或者对解码器进行优化，比如选择更快速的解码器或者调整解码器的参数。

    编码器的编码速度：在视频录制和转码的过程中，编码器的编码速度同样很重要。可以通过选择更快速的编码器或者调整编码器的参数来优化编码速度。

    内存的使用：FFmpeg 在解码和编码过程中会使用大量的内存，如果内存不足会导致程序崩溃或者性能下降。为了避免这个问题，可以考虑使用内存池来管理内存，或者减小编码器和解码器的缓存大小。

    多线程的使用：FFmpeg 可以通过多线程来优化解码和编码的性能，但是多线程也会带来一些并发问题，如竞争条件、死锁等。可以通过锁机制、同步机制、缓存等方式来解决这些问题。

    媒体格式的选择：在使用 FFmpeg 进行转码时，选择合适的媒体格式也会对性能产生影响。比如，一些格式需要更长的时间来解码或编码，或者需要更大的缓存空间。因此，在选择媒体格式时需要考虑性能和兼容性的平衡。

    以上是一些优化 FFmpeg 性能的方法，当然还有其他一些方法，需要根据具体情况进行选择和调整。

51. 你在项目中使用了FFmpeg，你有没有考虑过FFmpeg的可移植性问题？如果有，你是如何处理的？

    在使用FFmpeg的过程中，确实需要考虑其可移植性问题，尤其是在不同的操作系统平台和不同的处理器架构上。为了提高FFmpeg的可移植性，可以采取以下措施：

    尽量使用FFmpeg提供的API，而不是直接调用操作系统提供的API。FFmpeg提供了跨平台的API，可以避免使用操作系统特定的API，从而提高可移植性。

    为不同的操作系统和处理器架构编写特定的代码。例如，可以为不同的操作系统编写特定的Makefile，为不同的处理器架构编写特定的汇编代码等。

    使用跨平台的工具链进行编译。例如，可以使用交叉编译工具链来在一台平台上编译出另一种平台的二进制文件。

    进行充分的测试和验证。在不同的操作系统平台和处理器架构上进行充分的测试和验证，确保FFmpeg的可移植性和正确性。

    需要注意的是，即使采取了上述措施，也不能完全保证FFmpeg在不同的平台上都能够正常工作，仍然需要针对特定的平台进行调试和优化。

52. 你在项目中使用了多线程，你有没有考虑过多线程的死锁问题？如果有，你是如何预防的？

    在多线程编程中，死锁是一个常见的问题。为了避免死锁，可以采用以下几种方式：

    避免使用多个锁，使用单一的全局锁来保护共享资源。

    在获取多个锁时按照相同的顺序获取，这样可以避免不同的线程获取锁的顺序不一致而导致的死锁。

    采用超时机制，在获取锁时设置超时时间，如果在超时时间内没有获取到锁，则放弃当前操作并返回错误。

    使用递归锁或者读写锁来代替普通锁，这样可以避免线程在获取锁的过程中被阻塞而导致的死锁。

    使用锁的分级机制，将锁分为不同的级别，从而避免出现互相等待的情况。

    在项目中，我们可以根据具体的情况采用不同的方式来预防死锁问题。同时，在设计多线程程序时，需要尽量避免使用锁来保护共享资源，采用无锁数据结构或者锁分离等技术来提高程序的并发性能。

    超时机制读写锁：

    ```c
    #include <pthread.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    #define TIMEOUT 5
    
    pthread_rwlock_t rwlock;
    
    void *read_thread(void *arg) {
        int rc;
        struct timespec ts;
    
        ts.tv_sec = time(NULL) + TIMEOUT;
        ts.tv_nsec = 0;
    
        while (1) {
            rc = pthread_rwlock_rdlock(&rwlock);
            if (rc == 0) {
                printf("Read lock acquired by thread %ld\n", pthread_self());
                // Read the data
                pthread_rwlock_unlock(&rwlock);
                printf("Read lock released by thread %ld\n", pthread_self());
            } else if (rc == EDEADLK) {
                printf("Read lock already acquired by thread %ld\n", pthread_self());
            } else {
                printf("Error acquiring read lock by thread %ld\n", pthread_self());
            }
    
            nanosleep(&ts, NULL);
        }
    
        return NULL;
    }
    
    void *write_thread(void *arg) {
        int rc;
        struct timespec ts;
    
        ts.tv_sec = time(NULL) + TIMEOUT;
        ts.tv_nsec = 0;
    
        while (1) {
            rc = pthread_rwlock_wrlock(&rwlock);
            if (rc == 0) {
                printf("Write lock acquired by thread %ld\n", pthread_self());
                // Write the data
                pthread_rwlock_unlock(&rwlock);
                printf("Write lock released by thread %ld\n", pthread_self());
            } else if (rc == EDEADLK) {
                printf("Write lock already acquired by thread %ld\n", pthread_self());
            } else {
                printf("Error acquiring write lock by thread %ld\n", pthread_self());
            }
    
            nanosleep(&ts, NULL);
        }
    
        return NULL;
    }
    
    int main() {
        pthread_t t1, t2, t3;
    
        pthread_rwlock_init(&rwlock, NULL);
    
        pthread_create(&t1, NULL, read_thread, NULL);
        pthread_create(&t2, NULL, read_thread, NULL);
        pthread_create(&t3, NULL, write_thread, NULL);
    
        pthread_join(t1, NULL);
        pthread_join(t2, NULL);
        pthread_join(t3, NULL);
    
        pthread_rwlock_destroy(&rwlock);
    
        return 0;
    }
    
    ```

    

53. 你在项目中使用了多线程，你有没有考虑过多线程的竞争条件问题？如果有，你是如何处理的？

    在多线程编程中，竞争条件问题是一个常见的问题，如果不加以处理，可能会导致线程安全问题。以下是一些处理多线程竞争条件的方法：

    互斥锁：使用互斥锁可以确保同一时间只有一个线程可以访问共享资源，从而避免了竞争条件问题。互斥锁可以通过pthread库来实现。

    条件变量：条件变量可以用于线程之间的通信，如果一个线程需要等待另一个线程完成某个任务才能继续执行，可以使用条件变量来实现。

    原子操作：原子操作是一种不可中断的操作，可以确保在一个操作完成之前，其他线程无法访问同一个内存位置，从而避免了竞争条件问题。

    读写锁：读写锁可以在读取共享资源时允许多个线程并发访问，但在写入共享资源时只允许一个线程进行访问，从而避免了读写冲突问题。

    在项目中使用多线程时，需要考虑到竞争条件问题，并采取适当的措施来解决这些问题，以确保程序的正确性和可靠性。

    同一变量的读取，共享变量之类的，就要用到读写锁：

    ```c
    pthread_rwlock_t rwlock;
    pthread_rwlock_rdlock();	// 获取读锁
    pthread_rwlock_unlock();	// 释放读锁
    pthread_rwlock_wrlock();	// 获取写锁
    pthread_rwlock_unlock();	// 释放写锁
    ```

    模拟程序：

    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <pthread.h>
    
    pthread_rwlock_t rwlock;
    
    void *reader(void *arg) {
        int i;
        for (i = 0; i < 3; i++) {
            pthread_rwlock_rdlock(&rwlock); // 获取读锁
            printf("Reader %d: get the read lock.\n", *(int *)arg);
            sleep(rand() % 3); // 模拟读操作
            pthread_rwlock_unlock(&rwlock); // 释放读锁
            printf("Reader %d: release the read lock.\n", *(int *)arg);
            sleep(rand() % 3); // 模拟读操作
        }
        return NULL;
    }
    
    void *writer(void *arg) {
        int i;
        for (i = 0; i < 3; i++) {
            pthread_rwlock_wrlock(&rwlock); // 获取写锁
            printf("Writer %d: get the write lock.\n", *(int *)arg);
            sleep(rand() % 3); // 模拟写操作
            pthread_rwlock_unlock(&rwlock); // 释放写锁
            printf("Writer %d: release the write lock.\n", *(int *)arg);
            sleep(rand() % 3); // 模拟写操作
        }
        return NULL;
    }
    
    int main() {
        int i, arg[3];
        pthread_t tid[6];
    
        pthread_rwlock_init(&rwlock, NULL);
    
        // 创建三个读者线程
        for (i = 0; i < 3; i++) {
            arg[i] = i;
            pthread_create(&tid[i], NULL, reader, &arg[i]);
        }
    
        // 创建三个写者线程
        for (i = 0; i < 3; i++) {
            arg[i] = i;
            pthread_create(&tid[i+3], NULL, writer, &arg[i]);
        }
    
        // 等待所有线程结束
        for (i = 0; i < 6; i++) {
            pthread_join(tid[i], NULL);
        }
    
        pthread_rwlock_destroy(&rwlock);
        return 0;
    }
    
    ```

    

54. 你在项目中使用了多线程，你有没有考虑过多线程的资源共享问题？如果有，你是如何解决的？

    在使用多线程的过程中，资源共享是一个重要的问题。为了避免资源竞争和死锁，需要合理地进行线程同步和互斥。以下是一些常见的处理方式：

    互斥锁：使用互斥锁来确保在某个线程修改共享资源时其他线程不能同时访问该资源，从而避免竞争问题。

    条件变量：使用条件变量来协调不同线程之间的操作，从而确保它们在需要时进行协同操作。

    原子操作：使用原子操作可以确保在对某个共享资源进行读写时不会出现数据竞争问题。

    信号量：使用信号量来控制多个线程对共享资源的访问，从而确保同一时刻只有一个线程访问该资源。

    线程局部存储（TLS）：在某些情况下，可以使用线程局部存储来避免线程间的资源竞争。

    在具体实现中，需要根据实际情况选用合适的同步机制，并进行适当的优化。同时，需要避免线程上下文切换过于频繁，可以通过合理的线程分配和调度来减少上下文切换的次数。

    

55. 你在项目中使用了多线程，你有没有考虑过多线程的上下文切换问题？如果有，你是如何处理的？

    在多线程编程中，上下文切换是一个常见的问题。上下文切换是指操作系统从一个线程中断并保存其当前状态，然后切换到另一个线程执行的过程。这个过程需要保存和恢复寄存器的状态、堆栈指针和程序计数器等信息，因此会产生一定的开销。如果上下文切换过于频繁，会导致系统性能下降。

    为了减少上下文切换的开销，可以采取以下措施：

    减少线程数目：在设计多线程程序时，应该根据实际需要合理设置线程数目，避免过多的线程导致上下文切换过于频繁。

    使用线程池：线程池可以在程序启动时预先创建一定数量的线程，并在需要时将任务分配给空闲的线程执行，这样可以避免频繁创建和销毁线程导致的开销。

    优化线程调度：操作系统的线程调度算法会对线程的执行顺序进行调度，可以通过优化线程调度算法来减少上下文切换的开销。例如可以采用抢占式调度或者优先级调度等方式。

    采用协程：协程是一种用户级线程，不需要通过系统调用进行上下文切换，因此可以避免上下文切换的开销。可以通过采用协程来减少上下文切换的开销。

    在项目中使用多线程时，应该根据实际情况采取合适的措施来减少上下文切换的开销，提高系统性能。

    

56. 你在项目中使用了多线程，你有没有考虑过多线程的优化问题？如果有，你是如何做的？

    减少锁的使用：锁会影响多线程程序的性能，因此应该尽量减少锁的使用。可以使用无锁数据结构、细粒度锁和乐观锁等技术来避免使用锁。

    减少上下文切换：上下文切换是操作系统进行多任务处理时发生的开销，它会降低多线程程序的性能。可以通过减少线程数量、使用协程、使用事件驱动等技术来减少上下文切换。

    优化共享数据结构：共享数据结构是多线程程序中经常出现的问题，因为多个线程都需要访问同一个数据结构。可以使用无锁数据结构、分离锁等技术来优化共享数据结构，从而减少锁的争用。

    优化任务分配和负载均衡：在多线程程序中，任务的分配和负载均衡是非常重要的。可以使用线程池、任务队列、任务调度器等技术来优化任务分配和负载均衡，从而提高多线程程序的性能。

    使用多核心处理器：如果你的系统有多个核心处理器，可以使用多核心处理器来并行执行任务，从而提高多线程程序的性能。

    需要注意的是，不同的项目和应用场景可能需要不同的优化技巧，具体的优化方案需要根据具体情况进行设计和实现。

    

57. 项目使用多线程还是多进程？为什么？

    在这个项目中，由于需要实时采集MPU6050的数据进行姿态解算，并且还需要同时进行视频录制、音频录制和数据上云等多个任务，因此建议使用多线程来实现。多线程可以更轻量级地占用系统资源，能够更快地切换任务，也更适合处理I/O密集型的任务。而多进程适合处理CPU密集型的任务，因为每个进程都有自己的独立地址空间和系统资源，更适合在多核CPU上运行。

    

58. 使用C还是C++？

    C 和 C++ 都是非常流行和广泛应用的编程语言，它们各自有自己的优点和不足。C 是一种过程化的编程语言，适合对性能和内存占用有要求的系统开发，比如操作系统和嵌入式系统。C++ 是一种面向对象的编程语言，适合开发复杂的应用程序和系统，比如图形界面、游戏、数据库等。

    如果我在开发一个嵌入式系统或者底层驱动，我可能更倾向于使用 C，因为它可以精细地控制内存和硬件资源，而且编译器生成的代码更加高效。但是如果我在开发一个大型应用程序，我可能会使用 C++，因为它提供了更好的抽象和封装，能够更好地管理代码复杂度和维护性。







多进程与多线程问题：

在这个项目中，由于需要实时采集MPU6050的数据进行姿态解算，并且还需要同时进行视频录制、音频录制和数据上云等多个任务，因此建议使用多线程来实现。多线程可以更轻量级地占用系统资源，能够更快地切换任务，也更适合处理I/O密集型的任务。而多进程适合处理CPU密集型的任务，因为每个进程都有自己的独立地址空间和系统资源，更适合在多核CPU上运行。



## 5.个人情况

1. 这个兼职辅导员是什么？具体干啥的？会忙吗？

   兼职辅导员就是辅助辅导员更好地开展对学院某年级的学生工作。具体任务其实就是走访宿舍，处理同学关系，注意学生的心理情况，管理在校人员白名单，帮忙开关校园码。本身一开始担任兼职辅导员就是想锻炼一下自己以及多体验一下新的东西，所以感觉还行。这学期慢慢没有多少任务，以及我管的是比我大一届的大四学生，这学期也是他们最后一学期，所以等到6月份左右就可以自然卸任，当然提前卸任也是可以的！



2. 平常会看什么书吗？
   技术类的会看鸟叔的Linux方面的书，但时常不去实践的话就很快忘记了。还有经典的程序员自我修养，是很早学长推荐看的；非技术类会看

   
   
3. 这个软件组是干啥的？你那个软件组组长是具体干啥的？
   小组成员最终是要参与物联网项目的网站、小程序、app等的搭建，并与俱乐部中其他组进行组队，然后构建idea去打一些比赛；我这个软件组组长其实就是负责培训他们关于简单的计算机网络入门，网站前后端，Linux基础使用，硬件上云平台，还有一些简单的树莓派烧录工作跑python环境等；

   
   
4. 为什么不考研？
   自我选择吧，我感觉出来工作个几年，可以见识更多的东西，综合了一下自身情况，还是选择被社会磨练个几年，到时候有什么需要就读什么方面的硕士，出国也是可以考虑的。

   自我选择吧，第一个因为工作和本专业不是对口的，所学知识和专业也是不一样，所以就算考研也是选择跨考，那还不如选择先出来工作几年，看到时候的情况，觉得知识不够那就选择考研，如果工作顺利的话，那就选择继续工作！再者出来工作也是算磨练自己，多接触实际工程中的东西，可以学到比书本更多的东西！
   
   
   
5. 平时有什么娱乐活动？
   娱乐活动？体育运动的话就是打壁球、跑步和下象棋，然后就是很有空就去ktv唱一会，有时候也是一个人去的！还有就是玩电脑游戏，csgo之类的；
   娱乐活动，体育运动的话就是打壁球、跑步和下象棋；有空就和同学一起去ktv唱一会歌。也玩电脑游戏，csgo之类的。还有一个扫街也算是娱乐活动吧，虽然摄影技术不咋地，但是拍多了就筛选多了就好看了hh
   
   
   
6. 平时除了学习，空闲的时候会做什么？
   空闲的时候去看看书，唱唱歌，看看外面的新世界还有摄影；

   
   
7. 你有什么非技术性的爱好吗？
   打壁球、唱歌（虽然有点五音不全）、摄影！！

   
   
8. 你支持加班吗？你对加班怎么看？
   我认为加班在某些时候是可以有的，比如一个项目被布置下来，要在合理的时间完成它。因为自己的效率低或者被一个问题卡了很久的情况是可以自己选择加班来针对问题进行研究的！

   对于有项目需求的加班，我很乐意接受，这是工作职责，上大学的时候也有时候为了打比赛或者做项目加班通宵的经历，但是如果是因为管理不到位导致的无效加班，我会先加一段时间然后提出意见，因为这是管理层面的失误，不应该让员工进行一些无效的加班。干技术的，肯定是希望自己的精力能花在更多有价值有意义的工作上。
   
9. 你怎么看待最近很火的ChatGPT聊天机器人？你玩过吗？
   我认为它是划时代的，从技术层面来讲，它的强监督学习和奖励算法等，让人真实感受到了和ai对话的感觉；而且可以把chatGPT当作一款强大的搜索引擎，极其好用！我之前看过一篇文章，甚至可以先初始化训练chatGPT是一个实体电脑，CPU显卡配置等设置好，可以正常运作，还能跑linux等；从学习方面来说，chatGPT直接可以干掉很多以往的岗位，因为你问他一个项目问题，它可以答出几种方案，只需要稍微懂得一点知识的人，挑挑选选就可以有一个初步的方案选择，如果方案不佳，那就是训练地不到位，最后大概率可以变为全能的存在，只要数据集足够大；这也就是督促我们不断学习了，像ai一样不断学习，才能不被淘汰；

   http3，在UDP的基础上，在应用层实现了一个可靠的传输协议——QUIC。TCP存在队头阻塞问题。而QUIC不会队头阻塞。TCP建立要经过三次握手，所以建立会有一定的延迟。而QUIC与TLS结合起来。

   QUIC有四点好处：

   - 降低连接耗时：客户端有缓存的情况下实现0-RTT建立连接；
   - 更灵活的拥塞控制：用户态可以为每一个请求配置不同的拥塞控制策略；
   - 无队头阻塞的多路复用：每个请求流独立拥有滑动窗口，互不影响；
   - 连接迁移：网络切换不会中断数据传输；

   

10. 你的毕设是做什么的？
    我还是大三学生，还没开始做毕设呢！

11. 你的专业好像和这个方向有点不符合？你是什么原因想要进入嵌入式行业的？
    是的，这个首先要承认自己的不足之处，就是双非并且非科班出身的。但我认为实际产出不应该用专业来限制，而且现在很多企业不再限制专业，只要求职者有这方面的能力都可以来进行应聘。我能来这里面试，也代表了贵公司是不限制专业的嘛！并且我在修读自己的专业课程之外，自学或请教师兄师姐们很多关于嵌入式的知识，比如ARM、FreeRTOS、操作系统等。所以自我评价是一个有一定嵌入式软件开发功底和经验的人，所以专业并不是很大的问题！主要是大一参加的俱乐部的原因吧，经常看到师兄师姐做一些嵌入式项目和打一些物联网比赛等等，驱使我去学习这方面的知识，并且参与比赛当中；当中其实也有很大坎坷，最后才选择了嵌入式这一行业；

12. 你在哪里了解到我们公司的？
    先是牛客网、智联招聘上有个空中宣讲会或者招聘消息的发布，然后驱使去关注官网公众号，然后上官网投简历去；

13. 周围人是怎么样评价你的？

14. 你认为你是个团队协作的人吗？
    是的，一是身为俱乐部的软件组组长应该要有团队协作能力；二是团队协作能力是打比赛必少不可的；

15. 请简要概括一下你自己？

16. 你的FreeRTOS是怎么学的？
    跟着韦东山学的，然后看一下感兴趣的heap内存分配源码或者task代码等

17. 对未来有规划吗？
    短期规划，目前是暑期实习，冲转正，不然就，专心秋招，之后就是日常实习也可以，再加上考个驾照；
    长期规划就是工作个三四年，读硕士或者出国，没有过早结婚的打算；

18. 平时怎么总结，汇报一个项目？

19. 为什么选择面试我们这个公司/这个行业/这个岗位？

20. 你希望通过实习得到什么？
    我希望学习到关于嵌入式的知识，最好是Linux方面的；二是了解一些嵌入式行业的现状，以便未来更好地把握所学知识；三当然是实习证明了，因为我们学校毕业要实习证明，没有自主实习就只能去学校开展的集体实习了；

21. 简要描述一下你的性格？举例分析？

22. 你的抗压能力？
    比较能抗压，一是大一大二俱乐部任务多，也都能按时完成，不会被过多的任务所压倒；二是兼职辅导员这一个职位是极其有压力的一个兼职，年级270多个人，可能得通知100个不同的人，因为他们看了消息也不会去做的。并且往往这些任务都是他们年级辅导员布置下来的有时间限制的。而且有些人就是脾气不好，你还得忍受着被骂的语气去劝它，总结就是抗压能力强。。；

23. 如何看待琐碎的事务性工作？

24. 之前项目开发中遇到困难时怎么解决？
    判断困难类型，比如说出bug了，还是原本理论可以，实际跑起来却不行的操作？前者就排错，从底层开始，如果是有实物，那就万用表查连通，接线是否正常，软件IO口配置等，一直往上面查，最后再细究代码；后者要细推，查询网络方面的内容，或者问师兄师姐以前有没有遇到类似的问题，因为学长学姐的处境曾经也类似，所以说不定会有一些小惊喜，直接搞通；

25. 你平时用什么网站进行搜索你的问题？
    当然是先首选国内一些常用的引擎，百度csdn掘金简书博客园等都可以，查不到就去谷歌stack overflow或者github上查找问题；

26. 你的优势和劣势是什么？

    我的优势：

    - 对嵌入式充满热爱，关于这方面的学习能力强；
    - 有过岗位相关经验的项目开发经验；

    我的劣势：

    - 

27. 能接受多大强度的加班？

    对于加班，我觉得是加班要有意义，比如说完成未在期限内的任务，适当加班提高效率，过度加班的话，会因为精神疲劳而导致效率的下降以及身体的损伤。

28. 简单描述一下自己是怎么样的人？

    

29. 最近阅读哪些技术书籍，遇到技术问题是怎么去解决？

《程序员的自我修养》

看是什么问题，stack overflow，chatgpt，掘金，csdn，自己发现，询问师兄师姐是否遇到相同情况。



30. 项目中最难的地方是哪里？你学习到了什么？

    

31. 与同事沟通的时候，如果遇到冲突了如何解决？

以理服人，如果它的理由和方案比我的理由和方案更胜一筹，那么就用他的，否则就将他说服。



32. 项目中有哪些可改进的点以及很优秀的点？

    

33. 如何评价自己学习新知识的能力？

兴趣导向。如果是学习感兴趣的东西的话，会很快并且很深入的去了解。



34. 目前为止，坚持得最久一件事情是什么？

    

35. 未来的职业规划是什么？

    

36. 最近学习了哪些新技术？

Linux驱动方面的，



37. 你的老师和同学是如何评价你的？



38. ==来一个自我介绍？==

    面试官你好，我叫张俊添，就读于深圳大学，是一名机电学院大三的学生。

    首先，虽然不是完全科班出身，但是受俱乐部和学长的影响，大二的时候也慢慢开始学习嵌入式并喜欢上嵌入式。打过物联网、蓝桥杯比赛，拿过一次奖学金.

    其次，在这期间也在不断补充自己的知识基础，如OS，计网、数据结构等等，并且一直在实践应用，和竞赛团队一起做项目，跟着一些学习教程做项目并创新，或者将学长学姐的项目复现并改进，像引入多线程、FreeRTOS、Linux系统或者对功能进行增删查改等。

    然后，在学习的过程中，也培养了自己写markdown笔记的习惯，我相信这个习惯在团队协作和一些接口文档的书写将会有很大的帮助。搭建过个人博客和公众号，目前也是运营了一个b站账号专门做嵌入式知识的分享，现在已经有1500+粉，2600+收藏量了。

    最后，我今天来应聘这个嵌入式软件开发暑期实习的岗位，希望能通过我的所学知识和经历让您认可我，在超聚变这个大家庭中展现自我，希望面试官可以给我这个机会！十分感谢！

    

    你需要展现出你是什么人？

    虽然非科班，但我认真学习；

    学习成绩靠前，乐观向上；

    竞赛有点，基础扎实；

    编程规范，运营账号；

    感谢面试官，说点好话；

    我走过的歪路，不能让别人再走过。

    

39. 你说一下你的个人缺点？
    
    两个层面：
    
    - 经历方面不够出色，不像那些能抽口袋就拿出国奖的同学一样，但是会更加努力去实现这个目标的；
    - 有时候过于求成，并且有点过于在乎别人的感受，然后导致自己有点焦虑，生产效率就低下了，并且负担也增加了。不过在每一次发生这种情况时，我都想方设法去脱离这个情绪，专注自身的东西，不要在意别人的看法，当自身有成就之后，别人的某些看法也就不重要了。像运营b站账号，刚开始分享的时候，还没什么，粉丝量线性上升趋势。但是到六七百粉那会，就有一些不好的评论了，但是通过一些静下心来学习和吃吃大餐，我就坚持下去了，现在1500粉，还是因为找实习拖更十多天了,
    
    
    
40. 项目中怎么去沟通？

    就以那个元件管家为例吧，我们团队是当时三个大二同学加一个大一同学。当方案出来之后，就相应产生分工，产生协作。几乎每一个人负责的都是不同的部分，电控，建模，小程序，服务器，PPT，产品计划书等等。

    - 所以群聊必须得有，群聊是沟通的平台。
    - 听得懂人话：但是每一个同学所学知识并不相同，所以沟通起来可能听不懂对方的专有名词，所以我们要求是要“讲人话”，当然是打了双引号的，得牺牲一些自我的时间，将所说的话再简化为对方听得懂的，比如说来一个wifi-mqtt上云，api是什么？之类的，让建模的同学来听，肯定一脸懵，虽然他不需要负责这一块。
    - 带着目的去沟通：其次是有一个编写接口文档的习惯，当电控写好程序，但是要解析云上下发的命令才能继续往下做时，可以先假定值，然后宏定义，将其作为一份接口文档，拿着这些数据与负责服务器、小程序的同学去沟通，要求你的数据包格式得是这样，这种才是有效沟通。
    - 不同领域进行交叉沟通：每隔一段时间，并不会太频繁，大概两周一次，开次小会，放下手中的活，整理一下到目前为止实现的东西进行汇总，集思广益，有卡壳的地方，可能其他领域的知识可以帮助到你。

    

41. 你知道现在火爆的RISC-V嘛？

    ​		RISC-V读作RISC Five，也即第五代精简指令处理器。取这个名字正是因为美国伯克利研究团队的David Patterson教授在此之前已经研制了四代精简指令处理器芯片。

    ​		一个开源项目，苦于X86和ARM而研发，ARM高价授权费，并且ARM 32 很难拿到授权，对技术卡死。x86也是一样，而且它们应为要向后兼容，慢慢已经变得十分臃肿了。此时RISC-V第五代精简指令处理器。

41. 









**问题：**

下面额想到一些面试问题，不过好像很少问这种的：

1.为什么项目中用步进电机？

呃，因为这个项目涉及到传送带和丝杠机械装置的驱动控制，需要的扭矩普通的直流电机远远达不上，所以选用了步进电机。而且步进电机可以很精准的控制旋转的方向和度数，丝杠运动也可以得到精确限位。

2.一套步进电机怎么接？

emm，这个在上面就提到了，转述一下就可以了。

3.开发中最困难的点？

1.初始化配置，有点多且复杂，还要写定时器中断函数之类，还有一个小坑就是上一个没有执行完就开始下一步的命令，这需要判断一下，并且所有函数先经过这个判断函数才可以进行下一步。

2.优先级的设置，电机在运转时，TIM中断函数会打断原来主函数的进行，如果没有设置好的话，那就会成为电机运行中，单片机其他所有服务都会被限制，更可能直接停止。所以优先级也是一个大的问题。

3.开发中的噪音，发热问题，无法解决，尤其是步进电机驱动丝杠时，有一定载荷的时候，就一直搁那发出大的噪音，听到人实在难受。而且在正转后再反转这种稍微密集一点的操作就开始发热发烫。还好工作过程中并未有接触，倒也可以接受。

4.....不公开部分）




​	



1. 为什么采用这种技术？调查过其他的通信传输技术吗？比如zigbee，2G，5G等。。

物联网协议中，一般有两大类，一类是传输协议，一类是通信协议。传输协议负责子网内设备间的组网及通信；通信协议则主要在传统互联网TCP/IP协议上的设备通讯协议。

IOT通信协议：REST/HTTP、CoAP协议、MQTT协议、DDS协议（高可靠、实时）、AMQP协议（互操作性）、XMPP协议（即时通信）、JMS协议（消息队列）

项目预备是多个机器，像贩卖机一样，需要每个设备都上云，并且有数据上传和命令下发环节，对时间的要求不是很高，并且MQTT协议的实现比较简单，所以就选用了MQTT协议。

硬件支持是ESP8266、ESP01S

原本是想要通过EMQ源码或者Mosquitto在Linux服务器上搭建MQTT服务器的，但是搭建成功之后，总是会时不时出现连接失败，重启之后还是没有解决的问题，所以就直接用EMQX的限时体验服务器进行开发。



2. 为什么采用ESP8266-WIFI模块，不直接用NodeMCU？



3. 刷的是什么固件？走的是原始的AT指令吗？

   对的，用的是原厂的AT指令库，程序也是用串口发送AT指令实现的，简单方便。







# 参考文章：

1. ChatGPT 大力支持
1. [ 史上最全的C++面试宝典（合集）_最靓的仔的博客-CSDN博客_c++面试宝典](https://blog.csdn.net/qq_35034604/article/details/107959429?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~SEARCHCACHE~Rate-1-107959429-blog-126830849.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~SEARCHCACHE~Rate-1-107959429-blog-126830849.pc_relevant_vip_default&utm_relevant_index=2)
1. [欢迎阅读韦东山百问网freeRTOS教程！ — 韦东山百问网freeRTOS教程 文档 (100ask.net)](http://rtos.100ask.net/freeRTOS教程/index.html)
1. [Git 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/git/git-tutorial.html)
1. [首页 | CSView计算机招聘知识分享](https://www.csview.cn/)
1. [C++ STL总结 | 行码棋 (wyqz.top)](https://wyqz.top/p/870124582.html#toc-heading-9)
1. [小林coding (xiaolincoding.com)](https://xiaolincoding.com/)
1. https://docs.qq.com/sheet/DWnNGaEJvUVBDQnFE?tab=BB08J2 (校招帮小程序的资料)
1. [算法面试小抄 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/leetbook/read/arithmetic-interview-cheat-sheet/)
1. [Linux驱动开发（从零开始编写一个驱动程序）_学习&笔记的博客-CSDN博客](https://blog.csdn.net/weixin_49303682/article/details/118532297)
1. [嵌入式Linux中I2C总线驱动程序设计 - 中国知网 (cnki.net)](https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKgchrJ08w1e7VSL-HJEdEx1th5kfpX8KJ2gouTnxa1nNM0PhdOKBpFrT8j4XQrtu1BkKO4CDecTz&uniplatform=NZKPT)
1. [linux-kernel-v3.x安装包下载_开源镜像站-阿里云 (aliyun.com)](http://mirrors.aliyun.com/linux-kernel/v3.x/?spm=a2c6h.25603864.0.0.25b243c0IWZyu6)
1. [Socket通信流程_fightsyj的博客-CSDN博客](https://blog.csdn.net/fightsyj/article/details/86251421)
1. [c语言 面试前必备基础知识_c语言面试_塞上江南o的博客-CSDN博客](https://blog.csdn.net/qq_43192537/article/details/111127276)
1. [最全的ASCII码表，EASCII码表，ISO/IEC 8859码表二进制、八进制、十进制、十六进制快速查询_八进制的ascii码_野猿新一的博客-CSDN博客](https://blog.csdn.net/mqdxiaoxiao/article/details/88757161)
1. [数字1的ASCII码，数字1的ASCII编码 - 在线ASCII码转换器 (diqibu.com)](https://ascii.diqibu.com/?c=49)
1. [C语言中关键字auto、static、register、const、volatile、extern的作用 - myvic - 博客园 (cnblogs.com)](https://www.cnblogs.com/myvic/p/8970733.html)
1. [什么是红黑树，一篇文章解决所有疑惑~~ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143585797)
1. [韦东山：6000字长文告诉你如何学习嵌入式linux - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/140412992)
1. [C语言、嵌入式重点知识：回调函数 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&chksm=fe0d62fac97aebeca9dc3c8b23989c9f3ef14fa61b15ca70b6b670471411b74c3e00fcf594e2&idx=1&mid=2247486525&scene=21&sn=a1b602fc247a8c4e8d65e14ff0f3135e#wechat_redirect)
1. [【C语言笔记】结构体 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU5MzcyMjI4MA%3D%3D&chksm=fe0d6a8bc97ae39de8e107b0415a5bf297cb482275ec67c829cf339ef7678f496cd90e891a00&idx=1&mid=2247484492&scene=21&sn=18b30ccb15c3227d4cca46d433cb45f2#wechat_redirect)
1. [通俗易懂，嵌入式Linux驱动基础_嵌入式Linux,的博客-CSDN博客](https://blog.csdn.net/weiqifa0/article/details/104725761)
1. [Linux内核模块（.ko文件） - 明明1109 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fortunely/p/16392051.html#:~:text=运行make命令即可得到hello.ko文件。 上面是一个模块只包含一个.c文件，如果包含多个.c文件，如file1.c，file2.c，可以用如下方式编写Makefile： obj-m %3A%3D,modulename.o modulename-objs %3A%3D file1.o file2.o)
1. 
