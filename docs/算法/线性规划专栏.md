## dp动态规划学习



动态规划，英语 **Dynamic programming** ，简称 **DP**

动态规划解决的是 **最优子结构**、**重复子问题** 

考虑能否将问题规模减小，找出状态转移方程

标志点：子问题有无重复出现？

| 算法       | 分治       | 动态规划   | 贪心     |
| ---------- | ---------- | ---------- | -------- |
| 适用类型   | 通用       | 优化       | 优化     |
| 子问题     | 每个都不同 | 有很多重复 | 只有一个 |
| 最优子结构 | 没有要求   | 必须满足   | 必须满足 |
| 子问题数   | 全部都要解 | 全部都要解 | 只解一个 |



- 递归

- 自顶向下（记忆化递归），问题规模减少的过程
- 自底向上（迭代），问题规模增加的过程





## 线性动态规划

关键点：**状态定义**、**状态转移**、**初始化**、**边界条件**



### 单串问题

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        //dp做法
        int n=nums.size();
        if(n==0){return 0;}
        vector<int> dp(n,1);
        for(int i=0;i<n;++i){
            for(int j=0;j<i;++j){
                if(nums[j]<nums[i]){
                    dp[i]=max(dp[i],dp[j]+1);
                }
            }
        }
        return *max_element(dp.begin(),dp.end());
    }
};
```

 

### [1.爬楼梯 ](https://leetcode.cn/problems/climbing-stairs/)

递归

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n==1)return 1;
        else if(n==2)return 2;
        return climbStairs(n-1)+climbStairs(n-2);
    }
};
```



dp数组递推

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n<=1)return n;
        int dp[n+1];
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
};
```



优化变量递推

```c++
class Solution {
public:
    int climbStairs(int n) {
        int f1 = 0,f2=0,f3=1;
        for(int i=0;i<n;++i){
            f2  = f1;
            f1  = f3;
            f3  = f2 + f1;
        }
        return f3;
    }
};
```



### [2.青蛙跳台阶问题 ](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

```c++
class Solution {
    #define MOD 1000000007
public:
    int numWays(int n) {
        if(n<=1)return 1;
        int dp[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++)dp[i] = (dp[i-1]+dp[i-2])%MOD;
        return dp[n];
    }
};
```



### [3. 将数字变成 0 的操作次数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/)

```c++
class Solution {
    // #define INMAX 1000001
    // int dp[INMAX];
public:
    int numberOfSteps(int num) {
        int res = 0;
        while(num!=0){
            if(num%2==0)num=num/2;
            else num=num-1;
            res++;
        }
        return res;

        //  强行动态规划
        // dp[0]=0;
        // for(int i=1;i<=num;i++){
        //     if(i%2==0)dp[i]=dp[i/2]+1;
        //     else dp[i]=dp[i-1]+1;
        // }
        // return dp[num];
    }
};
```





### [4.爬楼梯的最少成本](https://leetcode.cn/problems/GzCJIP/)

```c++
class Solution {
    #define maxlen 1001
    int dp[maxlen];
public:
    // 本质还是斐波那契数列
    int minCostClimbingStairs(vector<int>& cost) {
        dp[1]=0;
        dp[2]=0;
        for(int i=2;i<=cost.size();i++){
            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.size()];
    }
};
```



### [5.使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```c++
class Solution {
    #define INMAX 1001
    int dp[INMAX];
public:
    int minCostClimbingStairs(vector<int>& cost) {
        dp[0]=dp[1]=0;
        int n=cost.size();
        for(int i=2;i<=n;i++)dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        return dp[n];
    }
};
```



### [6.打家劫舍](https://leetcode.cn/problems/house-robber/)

```c++
class Solution {
    #define INMAX 110
    int dp[INMAX];
public:
    int rob(vector<int>& nums) {
        int n = nums.size()-1;
        if(n<=0)return nums[0];
        dp[0]=nums[0];
        dp[1]=max(nums[0],nums[1]);
        for(int i=2;i<=n;i++)dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        return dp[n];
    }
};
```

cursor版本：

```c++
int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return 0;
    }
    vector<int> dp(n+1);
    dp[0] = 0;
    dp[1] = nums[0];
    for (int i = 2; i <= n; i++) {
        dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]);
    }
    return dp[n];
}
```



### [7.打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

```c++
class Solution {
    #define INMAX 110
    int dp[INMAX][2];
    // dp[i][0]表示前i个元素且第0个元素不选的情况下，前面i个元素的最大金额
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n==1)return nums[0];
        else if(n==2)return max(nums[0],nums[1]);
        // 分两种情况，一种是第0个元素选择了的情况，那么最后一个就不能选；
        // 第二种情况是第0个元素没有选择，则最后一个元素可以选；
        dp[0][0]=0;
        dp[0][1]=nums[0];
        
        dp[1][0]=nums[1];
        dp[1][1]=nums[0];

        for(int i=2;i<n;i++){
            for(int j=0;j<2;j++){
                // 特殊判断，当到最后一个元素时，且第一个元素选择了，则最后一个不能选，故金额数仍为前一个dp
                if(i==n-1&&j==1)dp[i][j]=dp[i-1][j];
                // 正常执行两次即可
                else dp[i][j]=max(dp[i-1][j],dp[i-2][j]+nums[i]);
            }
        }
        return max(dp[n-1][0],dp[n-1][1]);
    }
};
```



cursor版本：

```c++
int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return nums[0];
    }
    vector<int> dp1(n+1);
    dp1[0] = 0;
    dp1[1] = nums[0];
    for (int i = 2; i < n; i++) {
        dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i-1]);
    }
    vector<int> dp2(n+1);
    dp2[0] = 0;
    dp2[1] = nums[1];
    for (int i = 2; i <= n; i++) {
        dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i-1]);
    }
    return max(dp1[n-1], dp2[n]);
}
```





### [8.解码方法](https://leetcode.cn/problems/decode-ways/)



```c++
class Solution {
    #define maxn 110
    int dp[maxn];
public:
    int numDecodings(string s) {
        int len = s.length();
        dp[0]=(s[0]=='0')?0:1;
        for(int i=1;i<len;++i){
            dp[i]=0;
            if(s[i]!='0')dp[i]+=dp[i-1];
            if(s[i-1]=='1'||s[i-1]=='2'){
                int val = (s[i-1]-'0')*10 + s[i]-'0';
                if(val<=26){
                    if(i==1)dp[i]++;
                    else dp[i]+=dp[i-2];
                }
            }
        }
        return dp[len-1];
    }
};
```



### [9.获取生成数组中的最大值](https://leetcode.cn/problems/get-maximum-in-generated-array/)

```c++
class Solution {
    #define maxn 110
    int nums[maxn];
public:
    int getMaximumGenerated(int n) {
        nums[0]=0;
        nums[1]=1;
        for(int i=0;i<=n;++i){
            if(2<=2*i&&2*i<=n)nums[2*i] = nums[i];
            if(2<=(2*i+1)&&(2*i+1)<= n)nums[2*i+1] = nums[i]+nums[i+1];
        }
        int res = 0;
        for(int i=0;i<=n;++i){
            res = max(res,nums[i]);
        }
        return res;
    }
};
```



### [10.分隔数组以得到最大和](https://leetcode.cn/problems/partition-array-for-maximum-sum/)

```c++
class Solution {
    #define maxn 510
    int dp[maxn];
public:
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        // 对于第i个元素来说，应该是第j个元素分隔后一位开始乘以最大值，dp[i]=dp[j]+cnt*maxv;
        // cnt<=k;
        int maxv,cnt;
        int n = arr.size();
        for(int i=0;i<n;++i){
            maxv=0;
            dp[i]=0;
            cnt=0;
            for(int j=i;j>=0;--j){
                maxv = max(maxv,arr[j]);
                ++cnt;
                if(cnt>k)break;
                if(j)dp[i]=max(dp[i],dp[j-1]+cnt*maxv);
                else dp[i]=max(dp[i],cnt*maxv);
            }
        }
        return dp[n-1];
    }
};
```



### [11.单词拆分](https://leetcode.cn/problems/word-break/)

```c++
// 看不懂
```





### [12.哪种连续子字符串更长](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

```c++
class Solution {
public:
    bool checkZeroOnes(string s) {
        int len = s.length();
        int oneLen=0;
        int zeroLen=0;
        int i=0;
        while(i<len){
            int oneNow=0;
            int zeroNow=0;
            while(s[i]=='0')zeroNow++,i++;
            while(s[i]=='1')oneNow++,i++;
            oneLen=max(oneLen,oneNow);
            zeroLen=max(zeroLen,zeroNow);
        }
        return oneLen>zeroLen;
    }
};
```

不用动态规划更好，这道题

```c++
class Solution {
    #define maxn 110
    int dp[2][maxn];
    int maxv[2];
public:
    bool checkZeroOnes(string s) {
        int n = s.size();
        memset(dp,0,sizeof(dp));
        maxv[0]=maxv[1]=0;
        dp[ s[0] - '0' ][0]=1;
        maxv[ s[0] - '0' ]=1;
        for(int i=1;i<n;++i){
            if(s[i]==s[i-1]){
                dp[s[i]-'0'][i]=dp[s[i]-'0'][i-1]+1;
            }
            else dp[s[i]-'0'][i]=1;
            maxv[0]=max(maxv[0],dp[0][i]);
            maxv[1]=max(maxv[1],dp[1][i]);
        }
        return maxv[1]>maxv[0];
    }
};
```



### [13.寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

```c++
// 不用动态规划更好
```





### [14.统计全为 1 的正方形子矩阵](https://leetcode.cn/problems/count-square-submatrices-with-all-ones/)

```c++

```



