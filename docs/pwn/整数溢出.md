# 整数溢出

一整个工程可能存在无数的数值处理边界，不可能保证其所有的安全









## 上界溢出

上界溢出有两种情况，一种是 `0x7fff + 1`， 另一种是 `0xffff + 1`。



这种上界溢出对无符号整型就没有影响，

但是在有符号短整型中，`0x7fff` 表示的是 `32767`，但是 `0x8000` 表示的是 `-32768`，

用数学表达式来表示就是在有符号短整型中 `32767+1 == -32768`。



在有符号短整型中，`0xffff==-1，-1 + 1 == 0`，从有符号看这种计算没问题。

但是在无符号短整型中，`0xffff == 65535, 65535 + 1 == 0`。



## 下界溢出

第一种是 `sub 0x0000, 1 == 0xffff`，

对于有符号来说 `0 - 1 == -1` 没问题，

但是对于无符号来说就成了 `0 - 1 == 65535`。



第二种是 `sub 0x8000, 1 == 0x7fff`，

对于无符号来说是 `32768 - 1 == 32767` 是正确的，

但是对于有符号来说就变成了 `-32768 - 1 = 32767`。





## 浮点数

理论上只有尾数是0或5的小数，才可以理论上被精确表示



浮点数，用三元组表示{Sign,Exponent,Significance}

其中Exponent，主要是移码，全为0表示十进制数0；全为1表示正/负无穷



数据底层

```
8.25  -->  1000.01  -->   1.00001    --->  0b 1000 0010 0000 1000 0000 0000 0000 000
|小数 |     |二进制  |         |存储|           |实际存储|
```



## 下标溢出越界

给定一个数字，没有规定上下界，可以访问线性地址上的内容





## 溢出诱因

存储、运算、条件判断



例如，atoi、strlen，被模、被截断







## 例子：



整型溢出：

- 以 32 位有符号整数为例
  - 假设在 C 或 C++ 语言中，有一个 32 位有符号整数变量`int num = 2147483647`（这是 32 位有符号整数的最大值），如果执行`num = num + 1`操作，就会发生溢出。在有符号整数的二进制补码表示中，`2147483647`的二进制表示为`01111111111111111111111111111111`，加`1`后变为`10000000000000000000000000000000`，这个值在有符号整数表示中是`-2147483648`，而在无符号整数表示中就是`0x80000000`（如果将其看作无符号数）。
  - 这里，从 2147483646（二进制表示为`01111111111111111111111111111110`）开始，加 1 后得到 2147483647（二进制表示为`01111111111111111111111111111111`），转换为无符号整数后就是 0x7FFFFFFF。



1. 有符号整数的表示与范围
   - 在计算机中，对于有符号整数（以 32 位为例），通常采用二进制补码表示。32 位有符号整数的范围是 到 ，即 - 2147483648 到 2147483647。其最高位（最左边的位）是符号位，0 表示正数，1 表示负数。
   - 例如，对于正数，如最大的正数 2147483647，它的二进制表示为 。而对于负数 - 1，它的二进制补码表示为 。
2. 整数溢出的概念
   - 当进行算术运算时，如果结果超出了这个有符号整数的范围，就会发生整数溢出。溢出后的结果会根据二进制补码的规则重新解释。
   - 例如，当最大值 2147483647（二进制为 ）加 1 时，结果的二进制表示为 ，这个值在有符号整数表示中是 - 2147483648。
3. 转换为无符号整数的过程
   - 当把一个有符号整数转换为无符号整数时，计算机不再考虑符号位。以 32 位为例，无符号整数的范围是 到 ，即 0 到 4294967295。
   - 假设我们有一个有符号整数，它的值是接近最大值的一个数，比如 2147483646（二进制为 ），当这个数加 1 后，得到 2147483647（二进制为 ）。
   - 当把这个有符号整数 2147483647 转换为无符号整数时，由于无符号整数不考虑符号位，它的值就是二进制表示对应的无符号整数的值，即 对应的十进制无符号整数为 2147483647，十六进制表示为 0x7FFFFFFF。
   - 简单来说，从数学角度看，就是先根据有符号整数的二进制补码运算规则进行算术运算（可能导致溢出），然后在转换为无符号整数时，把原来的二进制表示按照无符号整数的范围和规则重新解释，计算出对应的无符号整数的值。



1. 如何 “溢出” 到 - 1（从概念角度）
   - 在正常的无符号整数运算中，不会直接溢出到 - 1，因为无符号整数不包含负数。但是如果从二进制位的角度以及和有符号整数的对比来理解，可以这样看：
   - 当一个 32 位无符号整数进行加法运算并不断增加时，例如从 0 开始不断加 1，当加到最大值 4294967295（二进制表示为`11111111111111111111111111111111`）后，如果再增加 1，由于无符号整数的溢出特性，结果会变为 0（二进制表示重新从`00000000000000000000000000000000`开始），这就好像是一个 “循环”。
   - 现在，如果我们把这个二进制位模式`11111111111111111111111111111111`看作是有符号整数的二进制补码表示，那么它代表的就是 - 1。在有符号整数的二进制补码表示中，最高位为 1 表示负数，这个二进制数通过补码转换规则可以得到 - 1 这个值。





==计算机中有 4 种溢出情况，以 32 位整数为例。==

① 无符号上溢：无符号数 0xffffffff 加 1 会变成 0。

② 无符号下溢：无符号数 0 减去 1 会变成 0xffffffff,即-1。

③ 有符号上溢：有符号正数 0x7fffffff 加 1 变成 0x80000000, 即从 2147483647 变成了-2147483648。

④ 有符号下溢：有符号负数 0x80000000 减去 1 变成 0x7fffffff,即从-2147483648 变成了 2147483647。

一个经典的整数溢出例子就是 c 语言的 abs 函数，int abs(int x)，该函数返回 x 的绝对值。但当 abs()函数的参数是 0x80000000 即-2147483648 的时候，它本来应该返回2147483648，但正整数的范围是 0-2147483647，所以他返回的仍然是个负数，即本身-2147483648。