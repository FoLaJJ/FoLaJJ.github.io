# ELF文件



## 编译原理



编译过程大概可以分为下面5个步骤：

- 词法分析：输出有意义的词素
- 语法分析：根据词法单元的第一个分量构建树型的中间表示形式，语法树
- 语义分析：检测源程序是否满足语言定义的语义约束，收集类型信息，生成代码、类型检查、类型转换
- 中间代码生成和优化：生成类机器语言的中间表示，三地址码
- 代码生成和优化：中间表示形式映射到目标机器语言



具体到GCC编译过程主要是四阶段：

- 预处理(Preprocess)，就是处理预处理指令、注释、行号、文件名标识等等
- 编译(Compile)，翻译成汇编代码
- 汇编(Assemble)，将汇编代码按照对照表进行翻译成对应的机器码
- 链接(Link)，动态或者静态链接，程序所需要的链接库，主要包括地址、空间分配、符号绑定、重定位



GCC编译过程使用的工具链为`ccl`、 `as`、 `collect2` 这三个工具



- `ccl`编译器，对应预处理和编译，将`hello.c` 编译为`hello.s` 
- `as` 汇编器，将`hello.s` 汇编成`hello.o` 目标文件
- `collect2` 是`ld`命令的封装，将C语言运行是时的库(CRT)中的目标文件以及所需要的动态链接库链接到可执行文件中





## Unix-ELF



ELF文件主要有四种类型：

- `.exec` 可执行文件，就是程序
- `.rel` 可重定位文件，`.o` 文件，PIC，尚未链接的文件
- `.dyn` 共享目标文件，动态链接库文件
- `core dump` 核心转储文件，进程意外终止是的进程地址空间的转储





狭义的来说，常说的ELF文件都是指第一种的可执行文件



## ELF文件结构

ELF文件头

在Linux可以使用该指令进行查看

```
readelf -h file
```

头部为 `7f 45 4c 46`



系统将目标文件分为很多节，可是使用`-S` 进行查看

```
readelf -S file
```





下面给出ELF文件中常见的节

| 节名                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| `.comment`            | 版本控制信息，如编译器的版本                                 |
| `.debug_XXX`          | DWARF格式的调试信息                                          |
| `.strtab`             | 字符串表                                                     |
| `.shstrtab`           | 节名的字符串表                                               |
| `.symtab`             | 符号表                                                       |
| `.dynamic`            | `ld.so`使用的动态链接库                                      |
| `.dynstr`             | 动态链接的字符串表                                           |
| `.dynsym`             | 动态链接的符号表                                             |
| `.got`                | 全局偏移量表(global offset table)，用于保存全局变量引用的地址 |
| `.got.plt`            | 全局偏移量表，用于保存函数引用的地址                         |
| `.plt`                | 过程链接表(procedure linkage table)，用于延迟绑定            |
| `.hash`               | 符号哈希表                                                   |
| `.rela.dyn`           | 变量的动态重定位表                                           |
| `.rela.plt`           | 函数的动态重定位表                                           |
| `.rel.text/rela.text` | 静态重定位表                                                 |
| `.rel.XXX/rela.XXX`   | 其他节的静态重定位表                                         |
| `.note.XXX`           | 额外的编译信息                                               |
| `.eh_frame`           | 用于操作异常的`frame unwind` 信息                            |
| `.init/.fini`         | 程序初始化和终止的代码                                       |







## 静态链接



链接由链接器完成，分为

- 编译时链接，ct
- 加载时链接，lt
- 运行时链接，rt



一般后缀为`.a` 的文件就是静态链接库文件





## 动态链接

免去浪费磁盘和内存空间的问题

但是引入了PIC和延迟绑定





由于一个程序的数据段和代码段的相对距离总是保持不变的，所以指令和变量之间的距离是一个常量，于是引入GOT，位于数据段的开头，保存全局变量和库函数的引用，在加载的时候会进行重定位。

后面引入RELRO机制，将GOT分为GOT和GOT.PLT ，前者保存全局变量引用，内存中只读。后者保存函数引用，可读可写





## 延迟绑定

一个非常非常重要的机制

就是当函数第一次被调用，动态链接器才回去进行符号查找、重定位等操作

实现原理，利用plt和got来进行实现



plt段的PLT是一个数组，

- PLT[0]，跳转到动态链接库
- PLT[1]，调用系统启动函数`_libc_start_main()`
- PLT[2]，被调用的各个函数条目



.got.plt段的got也是一个数组

- GOT[0]，动态链接器在解析函数地址时候所需要的两个地址(.dynamic 和 relor 条目)
- GOT[1]，同GOT[0]
- GOT[2]，动态链接器`ld-linux.so`的入口
- GOT[3]，被调用的函数条目



调用`func`函数时：

```
call --> func@plt --> plt[0]=func@GOT --> push GOT[1] --> GOT[2] --> GOT[4]=func --> func
```



