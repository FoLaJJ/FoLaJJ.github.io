# 格式化字符串漏洞

​	格式化字符串漏洞通常出现在程序没有正确处理用户输入作为格式化字符串时。程序可能将用户输入作为参数传递给格式化函数，如 `printf`，导致恶意用户能够插入格式化字符来控制程序的行为。



`printf` 函数代表了一类的格式化字符串基本格式

```
%[parameter][flags][field width][.precision][length]type
```

- parameter，获取格式化字符串中的指定参数
- flags，取值可为0或多个，也可以是+空格#0
- field width给出显示数值的最小宽度
- precision指明输出的最大长度
- length指出浮点型参数或整形参数的长度
  - hh输出1byte
  - h输出2byte
  - l输出4byte
  - ll输出8byte
- type，转换说明
  - `x`：输出栈上的值（十六进制）
  - s：输出null结尾字符串直到精度规定的上限，输出栈上的字符串，==把栈上的数据作为地址解析，然后打印地址对应的数据== ， 泄露got表地址对应的真实函数地址
  - c：把int参数转换为unsigned char类型输出，格式化漏洞利用中使用其输出大量字符
  - p：void*型，输出对应变量的值
  - n：不输出字符，但是把已经成功输出的字符个数写入对应的整形指针所指的变量



**常见的格式化字符包括：**

- `%x`：输出栈上的值（十六进制），

- `%s`：输出栈上的字符串，==把栈上的数据作为地址解析，然后打印地址对应的数据== ， 泄露got表地址对应的真实函数地址

- `%n`：将当前输出的字符数写入指定的地址

- `%p`：输出指针值（通常是栈地址），==打印栈上数据==，暴露got表地址

- `%hhn`：写入一个字节，类似于 `%n`，但写入的是一个字节

  

## 转换说明深入

### %c

输出单个字符

```
printf("%c",65);

A
```



```
printf("%1000c");
printf("%1000c",65);

前者打印1000个空格，后者打印999个空格+A
```



`%d`和`%s`都类似



### %p

输出指针值

```
int a=0x12345678;

printf("%p",a);
printf("%p",&a);

前者将a的值以地址的形式输出，后者将a的地址输出
前者输出为0x12345678，后者则打印a的真实地址
```



`%n$x` 也可以泄露栈中数据



### %s

获取变量对应地址的数据，就是将栈中数据当作一个地址，获取这个地址中的数据，存在\x00截断

```
printf(s);

%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s

报错知道输入的数据是printf函数的第几个参数，然后构造%n$s,n为参数位置
```



然后实际中经常使用下面做法进行泄露got表地址

```
payload = p32(_libc_start_main_got) + '%n$s'
```



开启PIE就无法泄露具体地址的数据，所以使用`%n$p` 来泄露任意位置的数据



### %n

%n是把成功输出的字符个数写入对应的整型指针参数所指的变量

如：

```
printf("%100c%n\n",a,&a);

输出100个字符，然后将成功输出的字符个数写入a中
```



复杂点：

```
%Xc%Y$n
X是要写入的字符数
Y是指定的参数

将输出的字符数往指定参数中写入
```



其中：

- %n是一次性写入4字节
- %hn是一次性写入2字节
- %hhn是一次性写入1字节



### %a

double型16进制格式输出栈中变量，输出栈上方的数据。



`FORTIFY` 机制开启后：

- 无法使用`%n$p` 不连续打印
- `%n` 时程序会检查





## 简单格式化字符串的区别

### 32位

直接栈上一直往后找

```
AAAA.%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p
```



找到打印`0x41414141` 的位置就可以了

假设程序输出为：

```
AAAA.0x8048590.0x14.0xf7e9179b.0xffffcfae.0xffffd0ac.0x41414141.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

这样看就是数数，直接忽略AAAA，数多少个即可

```
%6$p
```



### 64位

前六个参数通过寄存器传参

```
rdi,rsi,rdx,rcx,r8,r9
```

后面的参数才使用栈来传参



如下：

```
%p.%p.%p

打印出rsi,rdx，rcx寄存器上的值,因为printf格式化字符串的地址本身存放在rdi
```

所以64位中，栈上的参数是从r9往后的

```
栈上的参数 : %6$p
```





### fmtarg利用

因为有可能格式化字符串用的参数在很远的地方，所以这里使用脚本进行输出



pwndbg工具里面就有fmtarg



步骤：

- gdb运行，在printf上打断点

- 然后

  ```
  fmtarg 0x地址
  ```

- 就得到结果了`("\%n$p")`



## 常见格式化字符串函数

```
scanf，sscanf
printf，fprintf，sprintf，snprintf，vsprintf，vsnprintf，vfprintf，vprintf
```





## 常见的攻击方式



### 栈上格式化







### 非栈上格式化





### 栈数据信息泄露

攻击者可以通过 `%x` 或 `%p` 等格式化字符，读取栈上的内容，从而泄露敏感信息，比如返回地址、函数指针、栈布局等。

例如，`printf(buffer)` 中，如果 `buffer` 是一个由攻击者控制的字符串，攻击者可以使用 `%x` 来打印栈上的数据，从而分析栈结构。

```
%<arg#>$<format>

%n$x

指定泄露格式化字符串后的第n个数据，以x的形式打印出来
```











### 写入内存

使用 `%n` 可以将已输出的字符数写入指定的内存地址。这使得攻击者能够覆盖特定的内存位置，常见的用途包括覆盖函数返回地址、改变程序的行为等。

例如，攻击者可以构造字符串：

```
AAAA %n
```

这会将输出的字符数（`AAAA` 产生 4 个字符）写入 `%n` 后面指定的地址。通过调整格式字符串中的字符数和 `%n` 的位置，攻击者可以将特定值写入关键内存位置，可能是函数的返回地址，从而实现代码执行控制。

### 控制程序流

通过写入返回地址或函数指针等关键内存位置，攻击者可以控制程序的执行流，通常是通过覆盖返回地址将控制权转移到攻击者指定的位置（如恶意代码）。



## 漏洞演示



假设有如下代码：

```c
#include <stdio.h>

void secret() {
    printf("You've triggered the secret function!\n");
}

void vulnerable_function(char *user_input) {
    printf(user_input);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);

    return 0;
}
```

假设攻击者输入如下格式化字符串：

```
AAAA %x %x %x %x
```

- 这会泄露栈上的数据（例如返回地址、局部变量等）。

如果攻击者知道栈上的结构，可以进一步构造 `%n` 来覆盖特定地址，控制程序流：

```
AAAA %x %x %x %x %n
```



## 防护措施

- **输入验证**：对用户输入的格式化字符串进行严格的验证，避免直接将用户输入传递给 `printf` 或类似函数。
- **使用安全函数**：避免使用不安全的格式化字符串函数，尽量使用 `snprintf`、`fprintf` 等函数，它们允许指定最大输出长度，防止缓冲区溢出。
- **栈保护**：启用栈保护（例如，使用 `-fstack-protector` 编译选项），可以帮助防止栈溢出和栈上的修改。
- **地址空间布局随机化（ASLR）**：启用 ASLR 使得攻击者难以预测栈和堆的内存地址，增加漏洞利用的难度。





## FORTIFY_SOURCE

1. 概述
   - 在 Pwn（二进制漏洞利用）场景中，`FORTIFY_SOURCE`是一个 GCC（GNU Compiler Collection）编译器的安全相关选项。当`FORTIFY_SOURCE = 0`时，表示关闭了 GCC 的某些安全加固机制。
2. FORTIFY_SOURCE 机制简介
   - 当`FORTIFY_SOURCE`开启（通常设为大于 0 的值，如`FORTIFY_SOURCE = 2`是比较常见的高安全级别设置），编译器会对一些可能存在缓冲区溢出风险的函数进行检查和加固。这些函数包括但不限于`strcpy`、`strcat`、`sprintf`等。
   - 例如，对于`strcpy`函数，编译器会在编译时添加额外的代码来检查目标缓冲区的大小，以防止缓冲区溢出。它会将目标缓冲区的大小作为一个参数传递给一个内部的检查函数，在运行时如果发现复制的数据长度可能超过缓冲区大小，就会提前终止程序并报错，从而增强程序的安全性。
3. 关闭后的影响（FORTIFY_SOURCE = 0）
   - 漏洞利用方面
     - 对于攻击者来说，关闭`FORTIFY_SOURCE`可能会使某些原本难以利用的漏洞变得容易利用。例如，如果一个程序存在缓冲区溢出漏洞，并且该程序是在`FORTIFY_SOURCE = 0`的情况下编译的，攻击者就可以更容易地构造恶意输入来覆盖栈上或堆上的数据结构，因为没有了编译器添加的缓冲区大小检查机制来阻止溢出。
   - 程序性能方面
     - 关闭这个选项可能会在一定程度上提高程序的性能。因为开启`FORTIFY_SOURCE`时，编译器会插入额外的检查代码，这些代码在运行时会消耗一定的时间和资源。当`FORTIFY_SOURCE = 0`时，就避免了这些额外的开销，不过这种性能提升通常是比较微小的，除非程序中大量使用了相关的可能存在风险的函数。