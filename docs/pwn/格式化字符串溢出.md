# 格式化字符串漏洞

## 作用：

- 泄露地址
- AWD的时候让对方的程序崩溃



前提知识：

- 大端存储：存储最高有效字节在最小的地址（网络传输文件存储常用）。

- 小端存储：存储最低有效字节在最小的地址（计算机内部存储）。



格式化字符串漏洞通常出现在程序没有正确处理用户输入作为格式化字符串时。程序可能将用户输入作为参数传递给格式化函数，如 `printf`，导致恶意用户能够插入格式化字符来控制程序的行为。

**常见的格式化字符包括：**

- `%x`：输出栈上的值（十六进制），
- `%s`：输出栈上的字符串，==把栈上的数据作为地址解析，然后打印地址对应的数据== ， 泄露got表地址对应的真实函数地址
- `%n`：将当前输出的字符数写入指定的地址
- `%p`：输出指针值（通常是栈地址），==打印栈上数据==，暴露got表地址
- `%hhn`：写入一个字节，类似于 `%n`，但写入的是一个字节





## 行为：



```
char c = 'a';
printf("%20c",c);
```

打印c，但是长度要是20，不足20就用空格来进行补偿







## 常见的攻击方式

### 栈数据信息泄露

攻击者可以通过 `%x` 或 `%p` 等格式化字符，读取栈上的内容，从而泄露敏感信息，比如返回地址、函数指针、栈布局等。

例如，`printf(buffer)` 中，如果 `buffer` 是一个由攻击者控制的字符串，攻击者可以使用 `%x` 来打印栈上的数据，从而分析栈结构。

```
%<arg#>$<format>

%n$x

指定泄露格式化字符串后的第n个数据，以x的形式打印出来
```



### 写入内存

使用 `%n` 可以将已输出的字符数写入指定的内存地址。这使得攻击者能够覆盖特定的内存位置，常见的用途包括覆盖函数返回地址、改变程序的行为等。

例如，攻击者可以构造字符串：

```
AAAA %n
```

这会将输出的字符数（`AAAA` 产生 4 个字符）写入 `%n` 后面指定的地址。通过调整格式字符串中的字符数和 `%n` 的位置，攻击者可以将特定值写入关键内存位置，可能是函数的返回地址，从而实现代码执行控制。

### 控制程序流

通过写入返回地址或函数指针等关键内存位置，攻击者可以控制程序的执行流，通常是通过覆盖返回地址将控制权转移到攻击者指定的位置（如恶意代码）。



## 漏洞演示



假设有如下代码：

```c
#include <stdio.h>

void secret() {
    printf("You've triggered the secret function!\n");
}

void vulnerable_function(char *user_input) {
    printf(user_input);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);

    return 0;
}
```

假设攻击者输入如下格式化字符串：

```
AAAA %x %x %x %x
```

- 这会泄露栈上的数据（例如返回地址、局部变量等）。

如果攻击者知道栈上的结构，可以进一步构造 `%n` 来覆盖特定地址，控制程序流：

```
AAAA %x %x %x %x %n
```



## 防护措施

- **输入验证**：对用户输入的格式化字符串进行严格的验证，避免直接将用户输入传递给 `printf` 或类似函数。
- **使用安全函数**：避免使用不安全的格式化字符串函数，尽量使用 `snprintf`、`fprintf` 等函数，它们允许指定最大输出长度，防止缓冲区溢出。
- **栈保护**：启用栈保护（例如，使用 `-fstack-protector` 编译选项），可以帮助防止栈溢出和栈上的修改。
- **地址空间布局随机化（ASLR）**：启用 ASLR 使得攻击者难以预测栈和堆的内存地址，增加漏洞利用的难度。





## FORTIFY_SOURCE

1. 概述
   - 在 Pwn（二进制漏洞利用）场景中，`FORTIFY_SOURCE`是一个 GCC（GNU Compiler Collection）编译器的安全相关选项。当`FORTIFY_SOURCE = 0`时，表示关闭了 GCC 的某些安全加固机制。
2. FORTIFY_SOURCE 机制简介
   - 当`FORTIFY_SOURCE`开启（通常设为大于 0 的值，如`FORTIFY_SOURCE = 2`是比较常见的高安全级别设置），编译器会对一些可能存在缓冲区溢出风险的函数进行检查和加固。这些函数包括但不限于`strcpy`、`strcat`、`sprintf`等。
   - 例如，对于`strcpy`函数，编译器会在编译时添加额外的代码来检查目标缓冲区的大小，以防止缓冲区溢出。它会将目标缓冲区的大小作为一个参数传递给一个内部的检查函数，在运行时如果发现复制的数据长度可能超过缓冲区大小，就会提前终止程序并报错，从而增强程序的安全性。
3. 关闭后的影响（FORTIFY_SOURCE = 0）
   - 漏洞利用方面
     - 对于攻击者来说，关闭`FORTIFY_SOURCE`可能会使某些原本难以利用的漏洞变得容易利用。例如，如果一个程序存在缓冲区溢出漏洞，并且该程序是在`FORTIFY_SOURCE = 0`的情况下编译的，攻击者就可以更容易地构造恶意输入来覆盖栈上或堆上的数据结构，因为没有了编译器添加的缓冲区大小检查机制来阻止溢出。
   - 程序性能方面
     - 关闭这个选项可能会在一定程度上提高程序的性能。因为开启`FORTIFY_SOURCE`时，编译器会插入额外的检查代码，这些代码在运行时会消耗一定的时间和资源。当`FORTIFY_SOURCE = 0`时，就避免了这些额外的开销，不过这种性能提升通常是比较微小的，除非程序中大量使用了相关的可能存在风险的函数。