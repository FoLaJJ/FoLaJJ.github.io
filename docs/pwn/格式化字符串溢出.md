# 格式化字符串漏洞



前提知识：

- 大端存储：存储最高有效字节在最小的地址（网络传输文件存储常用）。

- 小端存储：存储最低有效字节在最小的地址（计算机内部存储）。



格式化字符串漏洞通常出现在程序没有正确处理用户输入作为格式化字符串时。程序可能将用户输入作为参数传递给格式化函数，如 `printf`，导致恶意用户能够插入格式化字符来控制程序的行为。

**常见的格式化字符包括：**

- `%x`：输出栈上的值（十六进制）
- `%s`：输出栈上的字符串
- `%n`：将当前输出的字符数写入指定的地址
- `%p`：输出指针值（通常是栈地址）
- `%hhn`：写入一个字节，类似于 `%n`，但写入的是一个字节



## 常见的攻击方式

### 栈数据信息泄露

攻击者可以通过 `%x` 或 `%p` 等格式化字符，读取栈上的内容，从而泄露敏感信息，比如返回地址、函数指针、栈布局等。

例如，`printf(buffer)` 中，如果 `buffer` 是一个由攻击者控制的字符串，攻击者可以使用 `%x` 来打印栈上的数据，从而分析栈结构。

```
%<arg#>$<format>

%n$x

指定泄露格式化字符串后的第n个数据，以x的形式打印出来
```



### 写入内存

使用 `%n` 可以将已输出的字符数写入指定的内存地址。这使得攻击者能够覆盖特定的内存位置，常见的用途包括覆盖函数返回地址、改变程序的行为等。

例如，攻击者可以构造字符串：

```
AAAA %n
```

这会将输出的字符数（`AAAA` 产生 4 个字符）写入 `%n` 后面指定的地址。通过调整格式字符串中的字符数和 `%n` 的位置，攻击者可以将特定值写入关键内存位置，可能是函数的返回地址，从而实现代码执行控制。

### 控制程序流

通过写入返回地址或函数指针等关键内存位置，攻击者可以控制程序的执行流，通常是通过覆盖返回地址将控制权转移到攻击者指定的位置（如恶意代码）。



## 漏洞演示



假设有如下代码：

```c
#include <stdio.h>

void secret() {
    printf("You've triggered the secret function!\n");
}

void vulnerable_function(char *user_input) {
    printf(user_input);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }

    vulnerable_function(argv[1]);

    return 0;
}
```

假设攻击者输入如下格式化字符串：

```
AAAA %x %x %x %x
```

- 这会泄露栈上的数据（例如返回地址、局部变量等）。

如果攻击者知道栈上的结构，可以进一步构造 `%n` 来覆盖特定地址，控制程序流：

```
AAAA %x %x %x %x %n
```



## 防护措施

- **输入验证**：对用户输入的格式化字符串进行严格的验证，避免直接将用户输入传递给 `printf` 或类似函数。
- **使用安全函数**：避免使用不安全的格式化字符串函数，尽量使用 `snprintf`、`fprintf` 等函数，它们允许指定最大输出长度，防止缓冲区溢出。
- **栈保护**：启用栈保护（例如，使用 `-fstack-protector` 编译选项），可以帮助防止栈溢出和栈上的修改。
- **地址空间布局随机化（ASLR）**：启用 ASLR 使得攻击者难以预测栈和堆的内存地址，增加漏洞利用的难度。