# 大模型API本地应用开发

## V0初版完成了基础的连接和对话操作

```python
import os
from openai import OpenAI


# 构造 client
client = OpenAI(
    # api_key=os.environ.get("HUNYUAN_API_KEY"),  # 混元 API Key
    api_key="",
    base_url="https://api.hunyuan.cloud.tencent.com/v1",  # 混元 endpoint
)

# 调用混元 API 实现对话
def chat_with_hunyuan(prompt):
    try:
        response = client.chat.completions.create(
            model="hunyuan-pro",  # 模型名称（根据混元 API 的要求填写）
            messages=[
                {"role": "user", "content": prompt}  # 用户输入
            ],
            max_tokens=1000,  # 最大生成长度
            temperature=0.7,  # 控制生成结果的随机性
        )
        return response.choices[0].message.content  # 返回 AI 的回复
    except Exception as e:
        return f"调用 API 失败: {str(e)}"

# 主程序
def main():
    print("欢迎使用腾讯云混元对话程序！输入 'exit' 退出。")
    while True:
        user_input = input("你: ")
        if user_input.lower() == "exit":
            print("再见，感谢你的使用！")
            break

        # 调用混元 API 获取回复
        ai_response = chat_with_hunyuan(user_input)
        print(f"小小混元: {ai_response}")

if __name__ == "__main__":
    main()
```



## V1使用tkiner创建了图形界面

### 连接逻辑

`connectionHunyuan.py`

```python
import os
from openai import OpenAI

class HunyuanChat:
    def __init__(self):
        self.client = OpenAI(
            api_key="",
            base_url="https://api.hunyuan.cloud.tencent.com/v1",
        )
        self.conversation_history = []

    def chat(self, prompt):
        try:
            response = self.client.chat.completions.create(
                model="hunyuan-pro",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1000,
                temperature=0.7,
            )
            return response.choices[0].message.content
        except Exception as e:
            return f"调用 API 失败: {str(e)}"
```



### 界面逻辑

`chatGUI.py`

```python
import tkinter as tk
from tkinter import ttk, scrolledtext
import threading
from datetime import datetime
from connectionHuyuan import HunyuanChat


class HunyuanChatGUI:
    def __init__(self):
        self.chat_bot = HunyuanChat()  # 实例化核心对话类
        self.setup_window()
        self.create_widgets()
        self.setup_tags()  # 设置文本样式标签
        self.show_welcome_message()

    def setup_window(self):
        self.window = tk.Tk()
        self.window.title("腾讯混元AI助手")
        self.window.geometry("800x600")

        # 配置样式
        style = ttk.Style()
        style.configure("Send.TButton", font=('微软雅黑', 10))

    def create_widgets(self):
        # 创建聊天显示区域
        self.chat_display = scrolledtext.ScrolledText(
            self.window,
            wrap=tk.WORD,
            font=('微软雅黑', 10),
            bg='#f5f5f5'
        )
        self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        self.chat_display.config(state='disabled')

        # 创建底部输入框架
        input_frame = ttk.Frame(self.window)
        input_frame.pack(padx=10, pady=(0, 10), fill=tk.X)

        # 创建输入框
        self.input_box = ttk.Entry(
            input_frame,
            font=('微软雅黑', 10)
        )
        self.input_box.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        # 创建发送按钮
        self.send_button = ttk.Button(
            input_frame,
            text="发送",
            style="Send.TButton",
            command=self.send_message
        )
        self.send_button.pack(side=tk.RIGHT)

        # 绑定回车键发送消息
        self.input_box.bind('<Return>', lambda e: self.send_message())

    def setup_tags(self):
        # 设置各种文本样式标签
        self.chat_display.tag_configure("welcome_title",
                                        font=('微软雅黑', 14, 'bold'),
                                        foreground='#2C3E50',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_content",
                                        font=('微软雅黑', 10),
                                        foreground='#666666',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_divider",
                                        font=('微软雅黑', 10),
                                        foreground='#95A5A6',
                                        justify='center'
                                        )

    def show_welcome_message(self):
        self.chat_display.config(state='normal')

        # 添加装饰性分隔线
        self.chat_display.insert(tk.END, "\n" + "=" * 50 + "\n\n", "welcome_divider")

        # 添加标题
        self.chat_display.insert(tk.END, "欢迎使用腾讯混元AI助手\n\n", "welcome_title")

        # 添加内容
        welcome_content = """您可以在下方输入框中输入问题，按回车键或点击发送按钮与AI进行对话。祝您使用愉快！"""
        self.chat_display.insert(tk.END, welcome_content + "\n", "welcome_content")

        # 添加底部分隔线
        self.chat_display.insert(tk.END, "=" * 50 + "\n\n", "welcome_divider")

        self.chat_display.config(state='disabled')

    def append_message(self, role, message):
        self.chat_display.config(state='normal')
        timestamp = datetime.now().strftime('%H:%M:%S')

        if role == "user":
            self.chat_display.insert(tk.END, f"\n你 ({timestamp}):\n", "user")
        else:
            self.chat_display.insert(tk.END, f"\n小小混元 ({timestamp}):\n", "assistant")

        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)
        self.chat_display.config(state='disabled')

    def send_message(self):
        user_input = self.input_box.get().strip()
        if not user_input:
            return

        # 清空输入框
        self.input_box.delete(0, tk.END)

        # 显示用户输入
        self.append_message("user", user_input)

        # 禁用发送按钮，防止重复发送
        self.send_button.config(state='disabled')
        self.input_box.config(state='disabled')

        # 在新线程中处理API请求
        def process_response():
            response = self.chat_bot.chat(user_input)

            # 在主线程中更新UI
            self.window.after(0, lambda: self.append_message("assistant", response))
            self.window.after(0, lambda: self.send_button.config(state='normal'))
            self.window.after(0, lambda: self.input_box.config(state='normal'))
            self.window.after(0, lambda: self.input_box.focus())

        threading.Thread(target=process_response, daemon=True).start()

    def run(self):
        self.window.mainloop()
```



### 启动函数

`main.py`

```python
from chatGUI import HunyuanChatGUI

def main():
    try:
        app = HunyuanChatGUI()
        app.run()
    except Exception as e:
        print(f"程序运行出错: {str(e)}")

if __name__ == "__main__":
    main()
```





## V2傻瓜版预制命令

### 启动函数

`main.py`

```python
from chatGUI import HunyuanChatGUI

def main():
    try:
        app = HunyuanChatGUI()
        app.run()
    except Exception as e:
        print(f"程序运行出错: {str(e)}")

if __name__ == "__main__":
    main()
```



### 连接逻辑

`connectionHuyuan.py`

```python
from openai import OpenAI
from systemCommands import SystemCommandExecutor
from commandInterpreter import CommandInterpreter


class HunyuanChat:
    def __init__(self):
        self.client = OpenAI(
            api_key="",
            base_url="https://api.hunyuan.cloud.tencent.com/v1",
        )
        self.command_executor = SystemCommandExecutor()
        self.command_interpreter = CommandInterpreter()
        self.system_prompt = """你是一个可以执行系统命令的助手。
                   当用户询问网络相关的问题时，你需要判断是否需要执行系统命令：
                   - 如果用户想测试某个网站或IP是否可以访问，返回：{"command": "ping", "params": "目标主机"}
                   - 如果用户想查看局域网内存活主机，返回：{"command": "network_scan", "params": ""}
                   - 如果用户想查看本机IP地址或网络配置，返回：{"command": "ipconfig", "params": ""}
                   请直接返回命令JSON，不要包含其他解释性文字。如果不需要执行命令，再正常回答。
                   示例：
                   用户：帮我看看百度能不能访问
                   返回：{"command": "ping", "params": "www.baidu.com"}
                   用户：我想看看我的IP地址
                   返回：{"command": "ipconfig", "params": ""}
                   """

    def chat(self, prompt: str) -> str:
        try:
            messages = [
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": prompt}
            ]

            response = self.client.chat.completions.create(
                model="hunyuan-pro",
                messages=messages,
                max_tokens=1000,
                temperature=0.7,
            )

            response_text = response.choices[0].message.content
            is_command, command_data, _ = self.command_interpreter.parse_response(response_text)

            if is_command and command_data:
                # 根据命令类型添加友好的提示信息
                command_type = command_data['command']
                if command_type == 'ping':
                    intro = f"正在测试 {command_data['params']} 的连通性...\n"
                elif command_type == 'network_scan':
                    intro = "正在扫描局域网内的存活主机...\n"
                elif command_type == 'ipconfig':
                    intro = "正在获取网络配置信息...\n"
                else:
                    intro = "正在执行命令...\n"

                result = self.command_executor.execute_command(
                    command_data['command'],
                    command_data['params']
                )
                return f"{intro}\n{result}"

            return response_text

        except Exception as e:
            return f"调用 API 失败: {str(e)}"
```



### 命令执行逻辑

`systemCommands.py`

```python
import subprocess
import socket
import platform
import threading
from typing import List, Dict, Callable, Optional
import time

class SystemCommandExecutor:
    def __init__(self):
        self.command_handlers: Dict[str, Callable] = {
            'ping': self.handle_ping,
            'network_scan': self.handle_network_scan,
            'ipconfig': self.handle_ipconfig,
        }

    def execute_command(self, command_type: str, params: str) -> str:
        if command_type in self.command_handlers:
            return self.command_handlers[command_type](params)
        return "不支持的命令类型"

    def handle_ping(self, host: str) -> str:
        try:
            param = '-n' if platform.system().lower() == 'windows' else '-c'
            command = ['ping', param, '4', host]
            result = subprocess.run(command, capture_output=True, text=True, timeout=10)
            return result.stdout
        except subprocess.TimeoutExpired:
            return "ping 命令执行超时"
        except Exception as e:
            return f"执行ping命令失败: {str(e)}"

    def handle_ipconfig(self, params: str = '') -> str:
        try:
            if platform.system().lower() == 'windows':
                command = ['ipconfig']
            else:
                command = ['ifconfig']  # 对Linux/Mac系统使用ifconfig

            result = subprocess.run(command, capture_output=True, text=True, timeout=5)
            return result.stdout
        except subprocess.TimeoutExpired:
            return "命令执行超时"
        except Exception as e:
            return f"执行命令失败: {str(e)}"

    def handle_network_scan(self, subnet: Optional[str] = None) -> str:
        if not subnet:
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            subnet = '.'.join(local_ip.split('.')[:-1])

        alive_hosts: List[str] = []
        def ping_host(ip: str) -> None:
            try:
                param = '-n' if platform.system().lower() == 'windows' else '-c'
                command = ['ping', param, '1', ip]
                result = subprocess.run(command, capture_output=True, timeout=2)
                if result.returncode == 0:
                    alive_hosts.append(ip)
            except:
                pass

        threads = []
        for i in range(1, 255):
            ip = f"{subnet}.{i}"
            t = threading.Thread(target=ping_host, args=(ip,))
            t.start()
            threads.append(t)

        for t in threads:
            t.join(timeout=0.5)

        return f"存活主机列表:\n" + "\n".join(alive_hosts)
```



### 命令裁决逻辑

`commandInterpreter.py`

```python
import json
from typing import Optional, Tuple, Dict, Any

class CommandInterpreter:
    @staticmethod
    def parse_response(response: str) -> Tuple[bool, Optional[Dict[str, Any]], str]:
        """
        解析AI响应，判断是否包含命令
        返回: (是否是命令, 命令数据, 原始响应)
        """
        if response.startswith('{"command":'):
            try:
                command_data = json.loads(response)
                return True, command_data, response
            except json.JSONDecodeError:
                pass
        return False, None, response
```



### 界面逻辑

`chatGUI.py`

```python
import tkinter as tk
import threading
from datetime import datetime
from connectionHuyuan import HunyuanChat
from tkinter import ttk, scrolledtext, messagebox  # 添加 messagebox
import time

class HunyuanChatGUI:
    def __init__(self):
        self.chat_bot = HunyuanChat()  # 实例化核心对话类
        self.setup_window()
        self.create_widgets()
        self.setup_tags()  # 设置文本样式标签
        self.show_welcome_message()

    def setup_window(self):
        self.window = tk.Tk()
        self.window.title("腾讯混元AI助手")
        self.window.geometry("800x600")

        # 配置样式
        style = ttk.Style()
        style.configure("Send.TButton", font=('微软雅黑', 10))

    def create_widgets(self):
        # 创建聊天显示区域
        self.chat_display = scrolledtext.ScrolledText(
            self.window,
            wrap=tk.WORD,
            font=('微软雅黑', 10),
            bg='#f5f5f5'
        )
        self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        self.chat_display.config(state='disabled')

        # 创建底部输入框架
        input_frame = ttk.Frame(self.window)
        input_frame.pack(padx=10, pady=(0, 10), fill=tk.X)

        # 创建输入框
        self.input_box = ttk.Entry(
            input_frame,
            font=('微软雅黑', 10)
        )
        self.input_box.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        # 创建发送按钮
        self.send_button = ttk.Button(
            input_frame,
            text="发送",
            style="Send.TButton",
            command=self.send_message
        )
        self.send_button.pack(side=tk.RIGHT)

        # 绑定回车键发送消息
        self.input_box.bind('<Return>', lambda e: self.send_message())

    def setup_tags(self):
        # 设置各种文本样式标签
        self.chat_display.tag_configure("welcome_title",
                                        font=('微软雅黑', 14, 'bold'),
                                        foreground='#2C3E50',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_content",
                                        font=('微软雅黑', 10),
                                        foreground='#666666',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_divider",
                                        font=('微软雅黑', 10),
                                        foreground='#95A5A6',
                                        justify='center'
                                        )

    def show_welcome_message(self):
        self.chat_display.config(state='normal')

        # 添加装饰性分隔线
        self.chat_display.insert(tk.END, "\n" + "=" * 50 + "\n\n", "welcome_divider")

        # 添加标题
        self.chat_display.insert(tk.END, "欢迎使用腾讯混元AI助手\n\n", "welcome_title")

        # 添加内容
        welcome_content = """您可以在下方输入框中输入问题，按回车键或点击发送按钮与AI进行对话。祝您使用愉快！"""
        self.chat_display.insert(tk.END, welcome_content + "\n", "welcome_content")

        # 添加底部分隔线
        self.chat_display.insert(tk.END, "=" * 50 + "\n\n", "welcome_divider")

        self.chat_display.config(state='disabled')

    def append_message(self, role, message):
        self.chat_display.config(state='normal')
        timestamp = datetime.now().strftime('%H:%M:%S')

        if role == "user":
            self.chat_display.insert(tk.END, f"\n你 ({timestamp}):\n", "user")
        else:
            self.chat_display.insert(tk.END, f"\n小小混元 ({timestamp}):\n", "assistant")

        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)
        self.chat_display.config(state='disabled')

    def send_message(self):
        user_input = self.input_box.get().strip()
        if not user_input:
            return

        # 清空输入框
        self.input_box.delete(0, tk.END)

        # 显示用户输入
        self.append_message("user", user_input)

        # 禁用发送按钮，防止重复发送
        self.send_button.config(state='disabled')
        self.input_box.config(state='disabled')

        # 在新线程中处理API请求
        def process_response():
            response = self.chat_bot.chat(user_input)

            # 如果响应包含系统命令，显示确认对话框
            if "执行结果：" in response:
                # 使用 self.window.after 来确保在主线程中显示对话框
                dialog_result = []
                self.window.after(0, lambda: dialog_result.append(
                    messagebox.askyesno("确认", "此操作将执行系统命令，是否继续？")
                ))

                # 等待对话框结果
                while not dialog_result:
                    time.sleep(0.1)

                if not dialog_result[0]:
                    self.window.after(0, lambda: self.append_message("assistant", "已取消执行命令。"))
                    self.window.after(0, lambda: self.send_button.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.focus())
                    return

            # 在主线程中更新UI
            self.window.after(0, lambda: self.append_message("assistant", response))
            self.window.after(0, lambda: self.send_button.config(state='normal'))
            self.window.after(0, lambda: self.input_box.config(state='normal'))
            self.window.after(0, lambda: self.input_box.focus())

        threading.Thread(target=process_response, daemon=True).start()

    def run(self):
        self.window.mainloop()
```





## V3框架式理解和转换式命令

### 启动逻辑

`main.py`

```python
from chatGUI import HunyuanChatGUI

def main():
    try:
        app = HunyuanChatGUI()
        app.run()
    except Exception as e:
        print(f"程序运行出错: {str(e)}")

if __name__ == "__main__":
    main()
```



### 连接逻辑

`connectionHuyuan.py`

```python
from openai import OpenAI
from systemCommands import SystemCommandExecutor
from commandInterpreter import CommandInterpreter


class HunyuanChat:
    def __init__(self):
        self.client = OpenAI(
            api_key="",
            base_url="https://api.hunyuan.cloud.tencent.com/v1",
        )
        self.command_executor = SystemCommandExecutor()
        self.command_interpreter = CommandInterpreter()

    def chat(self, prompt: str) -> str:
        try:
            # 首先让AI理解用户意图并转换为系统命令
            messages = [
                {"role": "system", "content": self.command_interpreter.system_prompt},
                {"role": "user", "content": prompt}
            ]

            response = self.client.chat.completions.create(
                model="hunyuan-pro",
                messages=messages,
                max_tokens=1000,
                temperature=0.7,
            )

            response_text = response.choices[0].message.content
            is_command, command_data, original_response = self.command_interpreter.parse_response(response_text)

            if is_command and command_data:
                intro = f"执行命令: {command_data['description']}\n"
                result = self.command_executor.execute_command(command_data['command'])
                return f"{intro}\n{result}"

            # 如果不是系统命令，进行普通对话
            messages = [
                {"role": "system", "content": "你是一个友好的AI助手。"},
                {"role": "user", "content": prompt}
            ]

            response = self.client.chat.completions.create(
                model="hunyuan-pro",
                messages=messages,
                max_tokens=1000,
                temperature=0.7,
            )

            return response.choices[0].message.content

        except Exception as e:
            return f"调用失败: {str(e)}"
```



### 命令执行逻辑

`systemCommands.py`

```python
import subprocess
import platform
from typing import Optional
from typing import  Iterator
import time

class SystemCommandExecutor:
    def __init__(self):
        self.os_type = platform.system().lower()

    def execute_command(self, command: str, timeout: int = 10) -> str:
        """
        执行系统命令的通用方法

        Args:
            command: 要执行的命令
            timeout: 命令超时时间（秒）

        Returns:
            命令执行结果
        """
        try:
            # 将命令字符串分割成列表
            if isinstance(command, str):
                command = command.split()

            # 执行命令
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            if result.returncode == 0:
                return result.stdout
            else:
                return f"命令执行失败:\n{result.stderr}"

        except subprocess.TimeoutExpired:
            return f"命令执行超时（{timeout}秒）"
        except Exception as e:
            return f"执行出错: {str(e)}"
```



### 命令裁决逻辑

`commandInterpreter.py`

```python
from typing import Optional, Tuple, Dict, Any
import json
import platform


class CommandInterpreter:
    def __init__(self):
        self.os_type = platform.system().lower()
        self.system_prompt = """你是一个系统命令解释器。
        当用户用自然语言描述想要执行的操作时，请将其转换为对应的系统命令。

        请按以下格式返回：
        {
            "command": "实际的系统命令",
            "description": "命令的简短描述",
            "risk_level": "low/medium/high"  # 命令的风险等级
        }

        注意事项：
        1. 仅返回JSON格式，不要包含其他文字
        2. 仅处理查询类和信息获取类命令，不处理修改系统的命令
        3. 不允许执行危险命令，如删除、格式化等
        4. Windows和Linux命令可能不同，请根据上下文选择合适的命令

        示例：
        用户：查看当前目录下的文件
        返回：{
            "command": "dir" if windows else "ls -l",
            "description": "列出当前目录文件",
            "risk_level": "low"
        }
        """

    def parse_response(self, response: str) -> Tuple[bool, Optional[Dict[str, Any]], str]:
        """解析AI响应，判断是否包含合法的系统命令"""
        try:
            command_data = json.loads(response)
            # 检查必要字段
            if all(k in command_data for k in ['command', 'description', 'risk_level']):
                # 检查风险等级
                if command_data['risk_level'] not in ['low', 'medium', 'high']:
                    return False, None, "无效的风险等级"
                # 不执行高风险命令
                if command_data['risk_level'] == 'high':
                    return False, None, "命令风险等级过高"
                return True, command_data, response
        except json.JSONDecodeError:
            pass
        return False, None, response
```



### 界面逻辑

`chatGUI.py`

```python
import tkinter as tk
import threading
from datetime import datetime
from connectionHuyuan import HunyuanChat
from tkinter import ttk, scrolledtext, messagebox  # 添加 messagebox
import time

class HunyuanChatGUI:
    def __init__(self):
        self.chat_bot = HunyuanChat()  # 实例化核心对话类
        self.setup_window()
        self.create_widgets()
        self.setup_tags()  # 设置文本样式标签
        self.show_welcome_message()

    def setup_window(self):
        self.window = tk.Tk()
        self.window.title("腾讯混元AI助手")
        self.window.geometry("800x600")

        # 配置样式
        style = ttk.Style()
        style.configure("Send.TButton", font=('微软雅黑', 10))

    def create_widgets(self):
        # 创建聊天显示区域
        self.chat_display = scrolledtext.ScrolledText(
            self.window,
            wrap=tk.WORD,
            font=('微软雅黑', 10),
            bg='#f5f5f5'
        )
        self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        self.chat_display.config(state='disabled')

        # 创建底部输入框架
        input_frame = ttk.Frame(self.window)
        input_frame.pack(padx=10, pady=(0, 10), fill=tk.X)

        # 创建输入框
        self.input_box = ttk.Entry(
            input_frame,
            font=('微软雅黑', 10)
        )
        self.input_box.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        # 创建发送按钮
        self.send_button = ttk.Button(
            input_frame,
            text="发送",
            style="Send.TButton",
            command=self.send_message
        )
        self.send_button.pack(side=tk.RIGHT)

        # 绑定回车键发送消息
        self.input_box.bind('<Return>', lambda e: self.send_message())

    def setup_tags(self):
        # 设置各种文本样式标签
        self.chat_display.tag_configure("welcome_title",
                                        font=('微软雅黑', 14, 'bold'),
                                        foreground='#2C3E50',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_content",
                                        font=('微软雅黑', 10),
                                        foreground='#666666',
                                        justify='center'
                                        )
        self.chat_display.tag_configure("welcome_divider",
                                        font=('微软雅黑', 10),
                                        foreground='#95A5A6',
                                        justify='center'
                                        )

    def show_welcome_message(self):
        self.chat_display.config(state='normal')

        # 添加装饰性分隔线
        self.chat_display.insert(tk.END, "\n" + "=" * 50 + "\n\n", "welcome_divider")

        # 添加标题
        self.chat_display.insert(tk.END, "欢迎使用腾讯混元AI助手\n\n", "welcome_title")

        # 添加内容
        welcome_content = """您可以在下方输入框中输入问题，按回车键或点击发送按钮与AI进行对话。祝您使用愉快！"""
        self.chat_display.insert(tk.END, welcome_content + "\n", "welcome_content")

        # 添加底部分隔线
        self.chat_display.insert(tk.END, "=" * 50 + "\n\n", "welcome_divider")

        self.chat_display.config(state='disabled')

    def append_message(self, role, message):
        self.chat_display.config(state='normal')
        timestamp = datetime.now().strftime('%H:%M:%S')

        if role == "user":
            self.chat_display.insert(tk.END, f"\n你 ({timestamp}):\n", "user")
        else:
            self.chat_display.insert(tk.END, f"\n小小混元 ({timestamp}):\n", "assistant")

        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)
        self.chat_display.config(state='disabled')


    def update_assistant_message(self, message):
        """更新助手消息的内容"""
        self.chat_display.config(state='normal')
        # 删除原有内容并插入新内容
        self.chat_display.delete(f"{self.message_placeholder} linestart", f"{self.message_placeholder} lineend")
        self.chat_display.insert(f"{self.message_placeholder} linestart", message)
        self.chat_display.see(tk.END)
        self.chat_display.config(state='disabled')

    def send_message(self):
        user_input = self.input_box.get().strip()
        if not user_input:
            return

        # 清空输入框
        self.input_box.delete(0, tk.END)

        # 显示用户输入
        self.append_message("user", user_input)

        # 禁用发送按钮，防止重复发送
        self.send_button.config(state='disabled')
        self.input_box.config(state='disabled')

        # 在新线程中处理API请求
        def process_response():
            response = self.chat_bot.chat(user_input)

            # 如果响应包含系统命令，显示确认对话框
            if "执行结果：" in response:
                # 使用 self.window.after 来确保在主线程中显示对话框
                dialog_result = []
                self.window.after(0, lambda: dialog_result.append(
                    messagebox.askyesno("确认", "此操作将执行系统命令，是否继续？")
                ))

                # 等待对话框结果
                while not dialog_result:
                    time.sleep(0.1)

                if not dialog_result[0]:
                    self.window.after(0, lambda: self.append_message("assistant", "已取消执行命令。"))
                    self.window.after(0, lambda: self.send_button.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.focus())
                    return

            # 在主线程中更新UI
            self.window.after(0, lambda: self.append_message("assistant", response))
            self.window.after(0, lambda: self.send_button.config(state='normal'))
            self.window.after(0, lambda: self.input_box.config(state='normal'))
            self.window.after(0, lambda: self.input_box.focus())

        threading.Thread(target=process_response, daemon=True).start()

    def run(self):
        self.window.mainloop()
```



## V4首版终极版傻瓜式运行命令

### 配置文件

`CONFIG.py`

```python
"""
配置文件
"""

# API配置
API_KEY = ""
BASE_URL = "https://api.hunyuan.cloud.tencent.com/v1"
MODEL_NAME = "hunyuan-pro"
MAX_TOKENS = 1000
TEMPERATURE = 0.7

# 对话历史配置
MAX_HISTORY_TURNS = 10

# GUI配置
WINDOW_TITLE = "腾讯混元AI助手"
WINDOW_SIZE = "800x600"
FONT_FAMILY = "微软雅黑"
FONT_SIZE = 10
BG_COLOR = "#f5f5f5"

# 提示词配置
BASE_SYSTEM_PROMPT = """你是腾讯混元AI助手。请以对话的方式回答问题。
只有当用户明确要求执行系统操作时，才考虑转换为系统命令。
对于一般性的问题（如"你是谁"），请直接回答而不是执行系统命令。

以下是之前的对话历史，请基于这些历史信息回答用户的问题：
"""

COMMAND_INTERPRETER_PROMPT = """你是一个系统命令解释器。
当用户用自然语言描述想要执行的操作时，请将其转换为对应的系统命令。

请按以下格式返回：
{
    "command": "实际的系统命令",
    "description": "命令的简短描述",
    "risk_level": "low/medium/high"  # 命令的风险等级
}

注意事项：
1. 仅返回JSON格式，不要包含其他文字
2. 仅处理查询类和信息获取类命令，不处理修改系统的命令
3. 不允许执行危险命令，如删除、格式化等
4. Windows和Linux命令可能不同，请根据上下文选择合适的命令
"""

# 欢迎信息配置
WELCOME_TITLE = "欢迎使用腾讯混元AI助手"
WELCOME_CONTENT = """您可以在下方输入框中输入问题，按回车键或点击发送按钮与AI进行对话。祝您使用愉快！"""

# 命令执行配置
COMMAND_TIMEOUT = 10
COMMAND_TRIGGER_KEYWORDS = ["请帮我执行" , "运行命令"]

```



### 主逻辑

`main.py`

```python
from ChatGUI import HunyuanChatGUI
import CONFIG
from typing import Dict, Any


def get_config() -> Dict[str, Any]:
    """获取配置字典"""
    return {k: v for k, v in CONFIG.__dict__.items()
            if not k.startswith('_')}


def main():
    try:
        config_dict = get_config()
        app = HunyuanChatGUI(config_dict)
        app.run()
    except Exception as e:
        print(f"程序运行出错: {str(e)}")


if __name__ == "__main__":
    main()
```



### 连接逻辑

`ConnectToHunyuan.py`

```python
from openai import OpenAI
from SystemRunCommands import SystemCommandExecutor
from CommandInterpreter import CommandInterpreter
from typing import Dict, Any


class HunyuanChat:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.client = OpenAI(
            api_key=config['API_KEY'],
            base_url=config['BASE_URL'],
        )
        self.command_executor = SystemCommandExecutor(config)
        self.command_interpreter = CommandInterpreter(config)
        self.chat_history = []
        self.base_system_prompt = config['BASE_SYSTEM_PROMPT']

    def format_history(self):
        """将历史记录格式化为文本"""
        history_text = "\n\n历史对话：\n"
        for msg in self.chat_history:
            role = "用户" if msg["role"] == "user" else "助手"
            history_text += f"{role}：{msg['content']}\n"
        return history_text

    def chat(self, prompt: str) -> str:
        try:
            # 构建包含历史记录的完整提示
            full_prompt = self.base_system_prompt + self.format_history() + "\n当前用户问题：" + prompt

            # 首先进行普通对话
            messages = [
                {"role": "system", "content": full_prompt},
                {"role": "user", "content": prompt}
            ]

            response = self.client.chat.completions.create(
                model=self.config['MODEL_NAME'],
                messages=messages,
                max_tokens=self.config['MAX_TOKENS'],
                temperature=self.config['TEMPERATURE'],
            )

            response_text = response.choices[0].message.content

            # 仅当回答中包含明确的系统操作请求时，才尝试解释为命令
            if any(keyword in prompt.lower() for keyword in self.config['COMMAND_TRIGGER_KEYWORDS']):
                command_messages = [
                    {"role": "system", "content": self.command_interpreter.system_prompt},
                    {"role": "user", "content": prompt}
                ]

                command_response = self.client.chat.completions.create(
                    model=self.config['MODEL_NAME'],
                    messages=command_messages,
                    max_tokens=self.config['MAX_TOKENS'],
                    temperature=self.config['TEMPERATURE'],
                )

                is_command, command_data, _ = self.command_interpreter.parse_response(
                    command_response.choices[0].message.content
                )

                if is_command and command_data:
                    intro = f"执行命令: {command_data['description']}\n"
                    result = self.command_executor.execute_command(command_data['command'])
                    response_text = f"{intro}\n{result}"

            # 更新对话历史
            self.chat_history.append({"role": "user", "content": prompt})
            self.chat_history.append({"role": "assistant", "content": response_text})

            # 保持历史记录在合理范围内
            if len(self.chat_history) > self.config['MAX_HISTORY_TURNS'] * 2:
                self.chat_history = self.chat_history[-self.config['MAX_HISTORY_TURNS']*2:]

            return response_text

        except Exception as e:
            return f"调用失败: {str(e)}"
```

### 命令执行逻辑

`Commandinterpreter.py`

```python
from typing import Optional, Tuple, Dict, Any
import json
import platform


class CommandInterpreter:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.os_type = platform.system().lower()
        self.system_prompt = config['COMMAND_INTERPRETER_PROMPT']

    def parse_response(self, response: str) -> Tuple[bool, Optional[Dict[str, Any]], str]:
        """解析AI响应，判断是否包含合法的系统命令"""
        try:
            command_data = json.loads(response)
            # 检查必要字段
            if all(k in command_data for k in ['command', 'description', 'risk_level']):
                # 检查风险等级
                if command_data['risk_level'] not in ['low', 'medium', 'high']:
                    return False, None, "无效的风险等级"
                # 不执行高风险命令
                if command_data['risk_level'] == 'high':
                    return False, None, "命令风险等级过高"
                return True, command_data, response
        except json.JSONDecodeError:
            pass
        return False, None, response
```

### 命令裁决逻辑

`CommandInterpreter.py`

```python
from typing import Optional, Tuple, Dict, Any
import json
import platform


class CommandInterpreter:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.os_type = platform.system().lower()
        self.system_prompt = config['COMMAND_INTERPRETER_PROMPT']

    def parse_response(self, response: str) -> Tuple[bool, Optional[Dict[str, Any]], str]:
        """解析AI响应，判断是否包含合法的系统命令"""
        try:
            command_data = json.loads(response)
            # 检查必要字段
            if all(k in command_data for k in ['command', 'description', 'risk_level']):
                # 检查风险等级
                if command_data['risk_level'] not in ['low', 'medium', 'high']:
                    return False, None, "无效的风险等级"
                # 不执行高风险命令
                if command_data['risk_level'] == 'high':
                    return False, None, "命令风险等级过高"
                return True, command_data, response
        except json.JSONDecodeError:
            pass
        return False, None, response
```

### 界面逻辑

`ChatGUI.py`

```python
import tkinter as tk
import threading
from datetime import datetime
from ConnectToHunyuan import HunyuanChat
from tkinter import ttk, scrolledtext, messagebox
import time
from typing import Dict, Any


class HunyuanChatGUI:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.chat_bot = HunyuanChat(config)
        self.setup_window()
        self.create_widgets()
        self.setup_tags()
        self.show_welcome_message()

    def setup_window(self):
        self.window = tk.Tk()
        self.window.title(self.config['WINDOW_TITLE'])
        self.window.geometry(self.config['WINDOW_SIZE'])

        # 配置样式
        style = ttk.Style()
        style.configure("Send.TButton", font=(self.config['FONT_FAMILY'], self.config['FONT_SIZE']))

    def create_widgets(self):
        # 创建聊天显示区域
        self.chat_display = scrolledtext.ScrolledText(
            self.window,
            wrap=tk.WORD,
            font=(self.config['FONT_FAMILY'], self.config['FONT_SIZE']),
            bg=self.config['BG_COLOR']
        )
        self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
        self.chat_display.config(state='disabled')

        # 创建底部输入框架
        input_frame = ttk.Frame(self.window)
        input_frame.pack(padx=10, pady=(0, 10), fill=tk.X)

        # 创建输入框
        self.input_box = ttk.Entry(
            input_frame,
            font=(self.config['FONT_FAMILY'], self.config['FONT_SIZE'])
        )
        self.input_box.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        # 创建发送按钮
        self.send_button = ttk.Button(
            input_frame,
            text="发送",
            style="Send.TButton",
            command=self.send_message
        )
        self.send_button.pack(side=tk.RIGHT)

        # 绑定回车键发送消息
        self.input_box.bind('<Return>', lambda e: self.send_message())

    def setup_tags(self):
        # 设置各种文本样式标签
        self.chat_display.tag_configure("welcome_title",
                                      font=(self.config['FONT_FAMILY'], 14, 'bold'),
                                      foreground='#2C3E50',
                                      justify='center'
                                      )
        self.chat_display.tag_configure("welcome_content",
                                      font=(self.config['FONT_FAMILY'], self.config['FONT_SIZE']),
                                      foreground='#666666',
                                      justify='center'
                                      )
        self.chat_display.tag_configure("welcome_divider",
                                      font=(self.config['FONT_FAMILY'], self.config['FONT_SIZE']),
                                      foreground='#95A5A6',
                                      justify='center'
                                      )

    def show_welcome_message(self):
        self.chat_display.config(state='normal')

        # 添加装饰性分隔线
        self.chat_display.insert(tk.END, "\n" + "=" * 50 + "\n\n", "welcome_divider")

        # 添加标题
        self.chat_display.insert(tk.END, f"{self.config['WELCOME_TITLE']}\n\n", "welcome_title")

        # 添加内容
        self.chat_display.insert(tk.END, f"{self.config['WELCOME_CONTENT']}\n", "welcome_content")

        # 添加底部分隔线
        self.chat_display.insert(tk.END, "\n" + "=" * 50 + "\n\n", "welcome_divider")

        self.chat_display.config(state='disabled')

    def append_message(self, role, message):
        self.chat_display.config(state='normal')
        timestamp = datetime.now().strftime('%H:%M:%S')

        if role == "user":
            self.chat_display.insert(tk.END, f"\n你 ({timestamp}):\n", "user")
        else:
            self.chat_display.insert(tk.END, f"\n小小混元 ({timestamp}):\n", "assistant")

        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)
        self.chat_display.config(state='disabled')

    def send_message(self):
        user_input = self.input_box.get().strip()
        if not user_input:
            return

        # 清空输入框
        self.input_box.delete(0, tk.END)

        # 显示用户输入
        self.append_message("user", user_input)

        # 禁用发送按钮，防止重复发送
        self.send_button.config(state='disabled')
        self.input_box.config(state='disabled')

        # 在新线程中处理API请求
        def process_response():
            response = self.chat_bot.chat(user_input)

            # 如果响应包含系统命令，显示确认对话框
            if "执行命令:" in response:
                # 使用 self.window.after 来确保在主线程中显示对话框
                dialog_result = []
                self.window.after(0, lambda: dialog_result.append(
                    messagebox.askyesno("确认", "此操作将执行系统命令，是否继续？")
                ))

                # 等待对话框结果
                while not dialog_result:
                    time.sleep(0.1)

                if not dialog_result[0]:
                    self.window.after(0, lambda: self.append_message("assistant", "已取消执行命令。"))
                    self.window.after(0, lambda: self.send_button.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.config(state='normal'))
                    self.window.after(0, lambda: self.input_box.focus())
                    return

            # 在主线程中更新UI
            self.window.after(0, lambda: self.append_message("assistant", response))
            self.window.after(0, lambda: self.send_button.config(state='normal'))
            self.window.after(0, lambda: self.input_box.config(state='normal'))
            self.window.after(0, lambda: self.input_box.focus())

        threading.Thread(target=process_response, daemon=True).start()

    def run(self):
        self.window.mainloop()
```



